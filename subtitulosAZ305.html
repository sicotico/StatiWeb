<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="UTF-8">
    <title>HTML 5</title>
    </head>
    <body>
        <p>
            00:00:00.001 --> 00:00:03.520
            Hey, this is Andrew Brown over here at free code camp bringing you another free cloud

            00:00:03.520 --> 00:00:07.600
            certification study course. And this time, it's the Azure solutions architect expert,

            00:00:07.600 --> 00:00:13.520
            also known as the AZ 305. And the way we're going to achieve Azure certification is through

            00:00:13.520 --> 00:00:18.880
            lecture content, hands on labs. And as always, I provide you a free practice exam. That way,

            00:00:18.880 --> 00:00:23.680
            you can go get that certification to put it on your resume or LinkedIn to go get that solutions

            00:00:23.680 --> 00:00:30.400
            architecture role. If you like these kind of free cloud study courses, the best way to support more

            00:00:30.400 --> 00:00:36.720
            of these materials is by purchasing the optional paid materials over on the exam pro platform exam

            00:00:36.720 --> 00:00:41.840
            pro.co. If you don't know me, I'm Andrew Brown. And I've taught a lot of different cloud

            00:00:41.840 --> 00:00:48.160
            certification study courses here, Azure, AWS, GCP, Kubernetes, Terraform, you name it, I've

            00:00:48.160 --> 00:00:54.160
            taught it so you're in great hands. And I will see you in class in a moment. Ciao.

            00:00:54.160 --> 00:01:00.560
            Hey, everyone, it's Andrew Brown. And we're at the start of our journey asking the most

            00:01:00.560 --> 00:01:08.000
            important question first, which is, what is the AZ 305? So the AZ 305 is a certification or an exam

            00:01:08.000 --> 00:01:14.320
            to get the certification Microsoft Azure solution architect expert. I use funny wording there,

            00:01:14.320 --> 00:01:21.440
            because previously, you had to take two separate exams, the 303 and the 304. And then that would

            00:01:21.440 --> 00:01:27.600
            get you the certification. But Microsoft has seen the light. And now we just have one exam for

            00:01:27.600 --> 00:01:32.480
            certification. It looks like it's mostly like that now. But just understand the future. They might

            00:01:32.480 --> 00:01:38.800
            change that. But yeah, the AZ 305 more or less means Microsoft Azure solutions architect expert

            00:01:38.800 --> 00:01:44.560
            going to get off screen here now. But yeah, it is an expert level certification. And it's focusing on

            00:01:44.560 --> 00:01:50.560
            comprehensive strategies for designing solutions on Azure. It has a deeper dive into advanced

            00:01:50.560 --> 00:01:54.960
            networking configurations. You don't see me doing this, but I'm doing quotations,

            00:01:54.960 --> 00:02:01.200
            air quotations here, sorry, air quotations for the word advanced because it's not as in depth as

            00:02:01.200 --> 00:02:07.520
            something like the the AZ 700 advanced networking. But yes, you do need to know your networking,

            00:02:07.520 --> 00:02:11.840
            your cloud networking very well for the certification. It has a broad examination

            00:02:11.840 --> 00:02:17.920
            of data and security solutions and Azure. The SC 900 is a great recommendation for that. But we'll

            00:02:17.920 --> 00:02:23.760
            talk about that when we look at the roadmap here. And this has extensive hands on knowledge,

            00:02:23.760 --> 00:02:29.760
            you should know how to do things in the Azure portal, arm templates and other resilient

            00:02:29.760 --> 00:02:37.360
            architectural tools. All Azure exams are very code and script driven. So having great developer

            00:02:37.360 --> 00:02:45.280
            experience is a must make sure you do things in the portal. Now this one, the 305 is not as

            00:02:45.280 --> 00:02:52.080
            technically heavy like the 104 in terms of hands on, but it still is a great challenge because of

            00:02:52.080 --> 00:02:58.640
            how broad the information is being covered in the 305. Who's the certification for will consider

            00:02:58.640 --> 00:03:04.640
            this certification if you're looking to get an Azure solutions architect expert role,

            00:03:05.360 --> 00:03:10.000
            your design solutions using Microsoft Azure, you're implementing and monitoring Azure

            00:03:10.000 --> 00:03:14.880
            infrastructure, you're creating configuring resources for Azure applications. Enjoy crafting

            00:03:14.880 --> 00:03:23.680
            resilient and scalable cloud architectures. I want to warn you, this is a hard exam is very common to

            00:03:23.680 --> 00:03:29.920
            fail this exam. Even if you practice a lot and you do your best job, it may just come down to the type

            00:03:29.920 --> 00:03:34.960
            of questions you get. So you know, we do the best to give you practice exams and all the information

            00:03:34.960 --> 00:03:39.920
            here. Just understand when you get to expert level or professional level certifications.

            00:03:39.920 --> 00:03:45.120
            It's not you, it's just the questions and you might have to try multiple times. So don't get

            00:03:45.120 --> 00:03:51.360
            discouraged if you if you take an exam, and you're just like one point shy away. That is what it's

            00:03:51.360 --> 00:03:55.920
            like doing these professional or expert certifications. Let's take a look at our Azure

            00:03:55.920 --> 00:04:00.400
            roadmap. And I'm right away, I'm already noticing that this is a bit buggy. This is supposed to just

            00:04:00.400 --> 00:04:06.320
            say 305. But just you know, ignore that one little bug there. That's his 305. But anyway,

            00:04:06.320 --> 00:04:13.200
            we have a bunch of Azure certifications, Microsoft certifications, this isn't the full list.

            00:04:13.200 --> 00:04:19.760
            In fact, there are some that I probably would even recommend on route there. But definitely before you

            00:04:19.760 --> 00:04:26.640
            go for expert, you should have your AZ 9, AZ 900 gives you a good broad view of all services. The

            00:04:26.640 --> 00:04:33.600
            AZ 104 is generally what is a word absolutely recommended on path to the 305. I would also pick

            00:04:33.600 --> 00:04:39.120
            up the tool for on the way. In fact, in this course, a lot of the content, not a lot of the

            00:04:39.120 --> 00:04:44.000
            content, but a good chunk of the content came from our 104 and our tour for and then we had to

            00:04:44.000 --> 00:04:48.960
            round it out with other things. So understand that these two are part of the course, if you've done

            00:04:48.960 --> 00:04:54.240
            the 104 to four, you're going to be in really good shape, or well aligned for the 305. And then you

            00:04:54.240 --> 00:04:58.640
            can spend time trying to figure out case studies and things like that. I would probably also add

            00:04:58.640 --> 00:05:06.080
            the SC 900. On here. That is a fundamental certification, the DP 900 would be also a good

            00:05:06.080 --> 00:05:10.400
            one. I'm just kind of running out of space for all these things. That's why I don't have them

            00:05:10.400 --> 00:05:14.560
            all listed. Like here, you can see I have the networking one shoved down in here. But Azure

            00:05:14.560 --> 00:05:22.720
            just has a lot, a lot of certifications. Okay. But anyway, how long would it take to pass for

            00:05:22.720 --> 00:05:26.800
            studying? Well, if you're a beginner, don't do this exam is not a beginner certification, it

            00:05:26.800 --> 00:05:32.800
            would take you well over a month. If you're a beginner, start in the fundamentals, do the

            00:05:32.800 --> 00:05:38.080
            associates and work your way up to it. If you're experienced, you already have that to for that,

            00:05:38.080 --> 00:05:44.240
            that are in the 104. And you already have multiple years working experience, it might not take you

            00:05:44.240 --> 00:05:50.320
            that long to study. But you know, on average, I think 50 hours is for somebody in the mid tier

            00:05:50.320 --> 00:05:57.440
            area. We're looking at 50% lecture 50% practice, or sorry, 50% lecture labs, 50% practice exams,

            00:05:57.440 --> 00:06:02.080
            I actually probably would even bump this up a bit more, try to get your hands on as many practice

            00:06:02.080 --> 00:06:10.640
            exams as you can. The huge challenge with Microsoft certifications is they have a rich type of exam

            00:06:10.640 --> 00:06:17.040
            questions. And not everyone can emulate those questions. So a lot of times you are needing to

            00:06:17.040 --> 00:06:24.480
            overstudy with simpler exam type questions in order to try to be able to tackle the harder exam. So

            00:06:24.480 --> 00:06:29.920
            just understand that that is something you have to consider. 30 days, absolutely, you need a whole

            00:06:29.920 --> 00:06:36.320
            month for this exam. For for for studying a recommended study one to two hours, really max

            00:06:36.320 --> 00:06:42.560
            your time out and so that you are in the best shape possible. What other things should we consider?

            00:06:42.560 --> 00:06:48.000
            Well, make sure you watch the video lecture content, do the hands on labs, absolutely do all

            00:06:48.000 --> 00:06:53.280
            of them and do the best that you can. In fact, there are labs that we wanted to record, but they

            00:06:53.280 --> 00:06:57.680
            were so hard to do. And this course was already so long that we didn't even record them and put them

            00:06:57.680 --> 00:07:03.120
            in here. But we actually do have, I believe additional labs with the instructions on our

            00:07:03.120 --> 00:07:09.920
            platform. So you know, max out as many labs as you can to make sure or hands on work, make sure you're

            00:07:09.920 --> 00:07:16.320
            in good shape. Absolutely do paid online practice exams, we have our own sets here. Just ignore

            00:07:16.320 --> 00:07:22.240
            these numbers here. I just did not feel like taking a new screenshot. But yeah, just the times are a

            00:07:22.240 --> 00:07:27.440
            little bit different here, because you actually get 120 minutes. And it's more around 60 questions.

            00:07:27.440 --> 00:07:35.600
            So 57 makes sense. But anyway, yeah, you definitely want to look into that. In terms of the actual

            00:07:35.600 --> 00:07:40.640
            exam guide outline, there are four domains, and each domain has its own weighting. This determines

            00:07:40.640 --> 00:07:45.520
            how many questions in a domain that will show up. Microsoft exams, they like to do a range of

            00:07:45.520 --> 00:07:50.320
            questions, which is not great for the test taker, but I guess it makes the exam harder.

            00:07:50.320 --> 00:07:56.160
            You know, I don't personally like this, I don't like that they do ranges like this. But you know,

            00:07:56.160 --> 00:08:01.120
            I guess they think that makes it if it's more more confusing, then therefore the exam must be

            00:08:01.760 --> 00:08:07.360
            more worth it for the end result. I don't know. So the first domain, or section, whatever you

            00:08:07.360 --> 00:08:13.040
            want to call it, it's between 25 and 30% of the exams, this design, design identity governance,

            00:08:13.040 --> 00:08:19.280
            monitoring solutions, the next one is 20 to 25%. For design data storage solutions, the next one

            00:08:19.280 --> 00:08:26.800
            is 12 to 20%. So design business continuity solutions, and then 30 to 35% design infrastructure

            00:08:26.800 --> 00:08:32.640
            solutions. Where are you going to take this exam, it's going to be with Pearson view. Previously,

            00:08:32.640 --> 00:08:39.040
            Microsoft, I think they offered it, I think it had PSI online before, even eight of us is doing the

            00:08:39.040 --> 00:08:44.960
            same thing, they're just doing Pearson. So Pearson and Pearson view. So you can do it in person test

            00:08:44.960 --> 00:08:49.120
            center or online for the convenience of your home from your own home. So what we're talking about

            00:08:49.120 --> 00:08:54.400
            is Pearson view online, this is the online project exam system. And then you have the Pearson view

            00:08:54.400 --> 00:08:59.600
            network of test centers is where you do it in person. The word proctor means a supervisor,

            00:08:59.600 --> 00:09:08.080
            so someone is going to monitor you during this exam. Sometimes when you go for your exam, they're

            00:09:08.080 --> 00:09:15.680
            like online, they will go and actually call and talk to you and ask you to show the room and it

            00:09:15.680 --> 00:09:20.720
            can be very involved. So just understand that there is somebody watching while you take these exams.

            00:09:21.360 --> 00:09:27.840
            The grading for this one is 700 out of 1000 points. So basically, it's around 70%. I say

            00:09:27.840 --> 00:09:36.080
            around 70% because Azure uses scaled scoring. So technically, it's not exactly 70%. It's 700 out of

            00:09:36.080 --> 00:09:42.560
            1000. I know that's confusing. But generally, what you want to do is aim to go get 80 80%.

            00:09:42.560 --> 00:09:48.560
            I always think if you have a margin of 10% above that you're passing for practice exams,

            00:09:48.560 --> 00:09:52.560
            then you're giving yourself a buffer, you might even want to go higher and try to target 85%.

            00:09:52.560 --> 00:10:00.080
            And in the result, you will actually probably get 70%. In terms of the amount of questions,

            00:10:00.080 --> 00:10:06.000
            there's between 40 and 60. So you should be able to get 12 and 18 questions wrong, though,

            00:10:06.000 --> 00:10:09.920
            the thing is, is that when we save 12 to 18, that's not exactly true, because you have to

            00:10:09.920 --> 00:10:15.760
            understand the format of the questions for Microsoft Azure exams. And they have a lot

            00:10:15.760 --> 00:10:20.080
            of different kinds of formatted questions, you got multiple choice, you got multiple answer,

            00:10:20.080 --> 00:10:25.200
            you got drag and drop, you got build list reorder, you have active screen, you got hot areas,

            00:10:25.200 --> 00:10:29.840
            you have case studies, you'll absolutely see case studies in this exam. And then questions can have

            00:10:29.840 --> 00:10:35.040
            exhibits. So it can get really complex. In terms of what you will see will be different from other

            00:10:35.040 --> 00:10:38.800
            folks, you definitely will see multiple choice, multiple answer, you'll definitely see case

            00:10:38.800 --> 00:10:43.680
            studies, and some of these other ones might show up. Some questions are worth more than one points,

            00:10:43.680 --> 00:10:50.160
            there is no penalty for wrong questions. So do not do not leave any questions blank. Some questions

            00:10:50.160 --> 00:10:56.640
            cannot be skipped, and you have to fill them in. So yeah, there's a lot going on there. The duration

            00:10:56.640 --> 00:11:03.520
            is two hours. I could have swore that the tool for was three hours, but I looked it up. And maybe

            00:11:03.520 --> 00:11:08.080
            they changed the time. But I really thought they would give you more time for this exam. But yeah,

            00:11:08.080 --> 00:11:13.760
            it's just two hours. So it is still a stressor. You get two minutes per question, basically. So

            00:11:13.760 --> 00:11:19.760
            we're looking at an exam time of 120 minutes, but your seat time is 150 minutes, all we do is we add

            00:11:19.760 --> 00:11:26.560
            30 minutes to make the seat time, the seat time refers to the amount that you should allocate

            00:11:26.560 --> 00:11:33.040
            for the exam. So this includes time to review instructions, show online proctor your workspace,

            00:11:33.040 --> 00:11:39.360
            read and accept the NDA, complete the exam provide feedback at the end of the exam. The reason I

            00:11:39.360 --> 00:11:44.560
            include this here is just to remind you that when you're when you're planning this, you have to plan

            00:11:44.560 --> 00:11:50.640
            for all of the time, not just exam, but also the time around the exam. This exam is only valid for

            00:11:50.640 --> 00:11:57.120
            12 months. This is something different. So as you're used to have two years, and then you'd

            00:11:57.120 --> 00:12:04.000
            have to pay every time. Now they're doing every 12 months. So every year you recertify. However,

            00:12:04.000 --> 00:12:10.160
            the recertification process supposedly isn't as hard because renewals are free. And I think you

            00:12:10.160 --> 00:12:16.240
            can even check in like six months into it if you want to do if you want to do it sooner. But we'll

            00:12:16.240 --> 00:12:21.600
            take a look at that. Because again, those are new things to me and I want to share those with you.

            00:12:21.600 --> 00:12:26.160
            But yeah, hopefully that gives you an idea of the exam guide itself. But we'll see in the next one.

            00:12:26.160 --> 00:12:38.080
            Okay, ciao. Hey, this is Andrew Brown. And welcome to the marketing site on Microsoft for the AZ 305.

            00:12:38.080 --> 00:12:42.560
            And you'll notice the name of this is actually called designing Microsoft Azure infrastructure

            00:12:42.560 --> 00:12:49.440
            solutions. And it gets you that badge, the solutions expert. But the strange thing is that

            00:12:49.440 --> 00:12:54.720
            Microsoft does not name the badge, the same thing as the exam. It's not that strange. If you

            00:12:54.720 --> 00:13:00.560
            understand the history of their certifications, they like to sometimes have more than one exam

            00:13:00.560 --> 00:13:05.520
            that you have to pass in order to get a badge. And so they don't name them the same as the badge. So

            00:13:05.520 --> 00:13:11.200
            that's just what's there. And the old exam used to have to the 304 and the 303. But we'll go down

            00:13:11.200 --> 00:13:16.400
            here below. Because the reason I'm on this page is I want to show you the sandbox. If you go here to

            00:13:16.400 --> 00:13:22.560
            the sandbox, and we'll open this up, we can see the formatting of the questions. Now it's not example

            00:13:22.560 --> 00:13:28.480
            questions. We have example ones on our platform, and we have we should have a free set. But what

            00:13:28.480 --> 00:13:32.720
            we'll do is we'll go ahead and click Next. And this is just like if you were to take it online

            00:13:32.720 --> 00:13:39.120
            or to test center. And we'll click through. And we'll go here. And there's just 10 questions.

            00:13:39.120 --> 00:13:43.120
            And the purpose of the sandbox is to show you the formatting of the questions. I'm going to get out

            00:13:43.120 --> 00:13:48.800
            of the way. There we go. And so the first one we have is a multiple choice, pretty straightforward.

            00:13:48.800 --> 00:13:53.760
            It says what is your favorite sound, we'll say a bell, we'll click Next. This one is multiple

            00:13:53.760 --> 00:13:59.120
            choice. So here we can checkbox two things, we'll do that. The next one here is drag and drop. So

            00:13:59.120 --> 00:14:05.120
            you have these things you drag and then you drop them into the area on the right here. Notice that

            00:14:05.120 --> 00:14:12.240
            I can actually fill in multiple. So you know, it can vary based on the type of questions. So it

            00:14:12.240 --> 00:14:19.920
            might not just be one to one, these things might still remain in here. Then we have a build order

            00:14:19.920 --> 00:14:24.320
            build list reorder. So which five tasks should you do in the correct order. So you say making

            00:14:24.320 --> 00:14:31.200
            a sandwich will add the pickles, the mayo, the ketchup, this, that this, whoops, this and that.

            00:14:31.200 --> 00:14:36.480
            Okay, and then you can move them around. Notice that this actually has more than five questions.

            00:14:36.480 --> 00:14:40.240
            These are draggable here, you'll notice these everywhere, we'll go ahead and hit Next.

            00:14:42.080 --> 00:14:47.440
            This question is an active screen. So which option should you choose to achieve this goal?

            00:14:47.440 --> 00:14:53.600
            So we'll scroll on down here. To answer select the appropriate setting in the applications example

            00:14:53.600 --> 00:14:58.880
            properties window in the answer area. So notice here, if we hover over, it might be hard to see,

            00:14:58.880 --> 00:15:03.200
            but there is a blue line. So it's showing like, where do you click, right? So here, that's the

            00:15:03.200 --> 00:15:07.920
            only one, we drop it down, then we choose an option here. So it's kind of like simulating

            00:15:09.440 --> 00:15:15.280
            components without actually having the environment. We'll go to the next one here. So this one is an

            00:15:15.280 --> 00:15:19.040
            active screen. So you need to implement self serving provisions of virtual machines. This

            00:15:19.040 --> 00:15:23.120
            actually kind of sounds like a proper question. The solution must ensure that the user can start

            00:15:23.120 --> 00:15:28.080
            the virtual machines, etc. What do you choose? So we'll go here and we'll choose option one.

            00:15:28.080 --> 00:15:34.800
            And then option to notice that these are relaying to this table here. But this is just, you know,

            00:15:34.800 --> 00:15:41.280
            another way that we could be working with stuff. Here we have a hot area. So it says,

            00:15:41.280 --> 00:15:45.840
            which services should you configure? So we'll go take a look here and notice that

            00:15:45.840 --> 00:15:51.440
            we can select something from the hot area. So it's very similar to that other one, active screen.

            00:15:51.440 --> 00:15:57.520
            Again, you're just like clicking on stuff, we'll go to the next one here. And so this is a case

            00:15:57.520 --> 00:16:03.680
            study. So case studies are pretty complex. The idea is you can click around here and read

            00:16:03.680 --> 00:16:09.440
            all of this stuff. Okay, so you read through all of this stuff. And then what you're going to do

            00:16:09.440 --> 00:16:13.280
            is go back to your question at the top, I know it's confusing, but that's where it is. And then

            00:16:13.280 --> 00:16:19.120
            you can go ahead and answer the question, we'll go back and hit next, then you have exhibits. So

            00:16:19.120 --> 00:16:23.920
            exhibits are basically just tabs. The idea is that you read the question, and you can go look at

            00:16:23.920 --> 00:16:29.120
            exhibit, there can also be multiple exhibits. So I think this one, here's an example where you have

            00:16:29.120 --> 00:16:34.960
            multiples, and then you go back to your question, and then you answer it. Okay. So you know,

            00:16:34.960 --> 00:16:41.360
            hopefully that makes things really clear. You can see that they really do have a lot of different

            00:16:41.360 --> 00:16:47.360
            formatted questions. And that can make this quite challenging. We want to read about the specifics

            00:16:47.360 --> 00:16:55.040
            of the exam, we can go to the study guide. Now, I remember there being at least in previous exams,

            00:16:55.040 --> 00:17:00.400
            or in other exams used to have a PDF, you can download, I can't seem to find that anymore.

            00:17:00.400 --> 00:17:04.480
            All there is is the marketing site here, maybe that's what they want to do. But you can go

            00:17:04.480 --> 00:17:10.240
            through here and read about like the certification renewals, the scoring, all the stuff here.

            00:17:10.240 --> 00:17:15.120
            We're mentioning about certification renewal. So if you want to read a bit more about that,

            00:17:15.120 --> 00:17:20.000
            or they talk about how renewals are free, and you have a six month renewal window and things like

            00:17:20.000 --> 00:17:25.200
            that, you can read all about it. But yeah, there you go. And we'll see in the next one.

            00:17:25.200 --> 00:17:36.080
            Hey, this is Andrew Brown. And before we get into Azure AD, I need to point something out.

            00:17:36.080 --> 00:17:41.760
            It's not called Azure AD anymore. It's called Microsoft Entre ID. Microsoft decided to change

            00:17:41.760 --> 00:17:48.320
            the name of Azure AD. Why? Nobody knows. But I can tell you no customer likes this particular change.

            00:17:49.040 --> 00:17:54.720
            Somebody who just had a lot of time on their hands over at Microsoft. But we do need to address this.

            00:17:54.720 --> 00:18:00.400
            I need to point out that I'm not refilming all of the content that I made just to change the name

            00:18:00.400 --> 00:18:06.160
            because that's crazy. I will at some point when when the content is stale, but the content is not

            00:18:06.160 --> 00:18:12.560
            stale, they just changed the name on us. But I want to just go over that quickly here. So the

            00:18:12.560 --> 00:18:20.080
            names here we have Azure AD is now Microsoft Entre ID, then the Azure AD tiers is from p1 p2,

            00:18:20.080 --> 00:18:26.240
            still p1 p2. The Azure AD external identities is now called Microsoft Entre external identities.

            00:18:26.240 --> 00:18:32.320
            If we scroll on down, we have a logo change. So instead of this, which by the way, I really like

            00:18:32.320 --> 00:18:38.160
            the old logo. They didn't need to muck with it. But anyway, we have the older ones here. And so

            00:18:38.160 --> 00:18:43.920
            this is the new one here. And so there are some name changes here, Azure AD single sign ons now

            00:18:43.920 --> 00:18:51.280
            Microsoft Entre Entre, single sign on, we'll go down below here. And you can see more name changes.

            00:18:51.280 --> 00:18:58.720
            Okay, so anyway, yeah, they renamed it. And you know, customers are just going to take a while

            00:18:58.720 --> 00:19:02.560
            to get used to it. I still like calling Azure AD. I know a lot of other people that like still

            00:19:02.560 --> 00:19:08.240
            calling it Azure AD. But it's at some point, we'll get moved over to it. And we're just gonna use

            00:19:08.240 --> 00:19:15.120
            both names. Okay. Now coming over to the portal, I need to show you that if you type in Azure AD,

            00:19:15.120 --> 00:19:21.360
            it's still going to pull up Microsoft Entre ID. Okay. Now you don't want Azure AD B2C,

            00:19:21.360 --> 00:19:29.440
            which is interesting. They didn't rename that which is a is part of Azure AD kind of in a sense,

            00:19:29.440 --> 00:19:37.120
            but it's more for if you're building applications, and you want to have authentication into it. So

            00:19:37.120 --> 00:19:41.360
            just understand that there's not consistency all over the place, especially even their documentation,

            00:19:41.360 --> 00:19:46.640
            the marketplace still says Azure AD all over the place. Even down below, you know, Azure AD

            00:19:46.640 --> 00:19:52.080
            notification. So you know, there's just going to be that legacy of Azure AD. But anyway, yeah,

            00:19:52.080 --> 00:19:56.960
            what you want to do is go over to Microsoft Entre ID, it all looks the same. It's just some name

            00:19:56.960 --> 00:20:07.520
            changes. Okay. But yeah, there you go. See in the next one. Hey, this is Andrew Brown from exam Pro.

            00:20:07.520 --> 00:20:11.520
            And we're looking at Azure Active Directory. And this is a cloud based identity and access

            00:20:11.520 --> 00:20:17.280
            management service to manage users sign ins and access to ad related resources. So Azure Active

            00:20:17.280 --> 00:20:21.920
            Directory is Microsoft's cloud based identity and access management service, which helps you

            00:20:21.920 --> 00:20:27.120
            your employees sign in and access resources. So that could be external resources like Microsoft

            00:20:27.120 --> 00:20:32.880
            Office 365, Azure portal, SAS applications, or internal resources. So applications within your

            00:20:32.880 --> 00:20:38.240
            internal networking, or access to workstations on premise. And you can use Azure AD to implement

            00:20:38.240 --> 00:20:44.400
            single sign on. So you can see that Azure AD is basically like the the one solution to log into

            00:20:44.400 --> 00:20:50.800
            everything. And we actually use it at exam Pro, we use it with Microsoft Teams, or, you know,

            00:20:50.800 --> 00:20:55.600
            for the exam Pro platform, our mid panels tied to it. So when we want to log into the mid panel

            00:20:55.600 --> 00:21:01.440
            with credentials, we have it there. We use it with AWS to log into there. And we use it to log into

            00:21:01.440 --> 00:21:05.840
            Azure. So it has a lot of flexibility. And if you're building out applications for enterprises,

            00:21:05.840 --> 00:21:10.800
            they're likely using ad. And so this is the reason why everybody adopts it or needs to understand it.

            00:21:10.800 --> 00:21:15.120
            So it's a service, I really, really do want you to understand and know, as your Active Directory

            00:21:15.120 --> 00:21:21.840
            comes in four editions, we have the free tier. And by the way, each tier that goes up has the

            00:21:21.840 --> 00:21:27.440
            features before it. But free has MFA SSO, basic security usage reports and user management,

            00:21:27.440 --> 00:21:33.120
            then you have the Office 365 apps, which is revolves around if you're using that suite.

            00:21:33.120 --> 00:21:38.400
            So you have company branding, SLA to sync between on premise and cloud. And then the premium tiers,

            00:21:38.400 --> 00:21:44.560
            which really comes into enterprise or, or on premise hybrid architecture. So hybrid architectures,

            00:21:44.560 --> 00:21:49.520
            advanced group access, conditional access, premium to identity protection and identity

            00:21:49.520 --> 00:21:54.400
            governance. One thing I don't like about Azure ad is that you can't really create your custom

            00:21:54.400 --> 00:21:57.760
            access controls unless you have premium one or premium two, but that's just how they do it. So

            00:21:57.760 --> 00:22:06.800
            there you go. So let's take a look at the use case for Azure ad. And we basically covered it in the

            00:22:06.800 --> 00:22:11.360
            introduction. But I just want to reiterate it in a different way with a bit of a visual,

            00:22:11.360 --> 00:22:16.560
            so that it really helps it sink into your brain there. So Azure ad can authorize and

            00:22:16.560 --> 00:22:21.120
            authenticate to multiple sources. So it can authenticate to your on premise ad to your web

            00:22:21.120 --> 00:22:28.000
            application allow users to log in with IP D's. So identity providers could be like use Facebook or

            00:22:28.000 --> 00:22:35.040
            Google login, you can use it with Office 365, or as Azure Microsoft. And so just a visual here,

            00:22:35.040 --> 00:22:41.040
            notice that we have Azure ad. And using Azure ad connect, we can connect to on premise through

            00:22:41.040 --> 00:22:47.840
            app registrations, we're able to connect our web application to Azure ad with external identities,

            00:22:47.840 --> 00:22:57.200
            we can use Facebook or Google login. And then for cloud applications, we can connect to Office 365,

            00:22:57.200 --> 00:23:07.520
            or Microsoft Azure. So Active Directory existed way before Azure. And so let's just do a quick

            00:23:07.520 --> 00:23:13.600
            rundown of the history. So we have an idea of what we're looking at. So Microsoft introduced

            00:23:13.600 --> 00:23:18.320
            Active Directory domain services in Windows 2000. To give organizations the ability to manage

            00:23:18.320 --> 00:23:23.440
            multiple on premise infrastructure components and systems using a single identity per user. So it's

            00:23:23.440 --> 00:23:28.240
            been around for 20 years. And Azure ad takes this approach to the next level by providing

            00:23:28.240 --> 00:23:35.680
            organizations with identity as a service. So ID as solution for their apps across cloud and on

            00:23:35.680 --> 00:23:40.800
            premise. And both versions are still used today because they just have different utility. And so

            00:23:40.800 --> 00:23:45.120
            we have Active Directory, which is for on premise. And then you have Azure ad, which is just the

            00:23:45.120 --> 00:23:51.120
            cloud hosted version. And in many regards, these can also be connected together. But there you go.

            00:23:51.120 --> 00:24:00.160
            So remember that the domain controller is the server that users are going to be using to

            00:24:00.160 --> 00:24:05.760
            authenticate to the directory service. And so when you create an Active Directory, Azure sets one up

            00:24:05.760 --> 00:24:10.160
            for you. But there's some cases where you might want to set one up yourself. And the reason why

            00:24:10.160 --> 00:24:14.720
            is that you could be like an on like an enterprise where you already have your own Active Directory

            00:24:14.720 --> 00:24:19.920
            on premise, but you've decided that you want to move it over to Azure ad, because you just want

            00:24:19.920 --> 00:24:25.760
            to fully managed Active Directory and you want to tap into the cloud. But the thing is, is that some

            00:24:25.760 --> 00:24:30.560
            domain services, those are features on your domain controller just might not be available. And that's

            00:24:30.560 --> 00:24:34.080
            where you're going to need to set up your own domain controller. And that's where Azure Active

            00:24:34.080 --> 00:24:40.080
            Directory domain services come into play because these provide managed domain services. And so

            00:24:40.080 --> 00:24:48.480
            they have managed domain services such as domain joins, group policies, LDA, P's, curb, be Ross,

            00:24:48.480 --> 00:24:54.240
            never can say that properly, ntlm authentication. And so the great thing is here is you can have

            00:24:54.240 --> 00:24:58.480
            these domain services, but you're not going to have to deploy them, manage them, patch them,

            00:24:58.480 --> 00:25:08.640
            they're just good at work. So there you go. So let's talk about the term tenant. And a tenant

            00:25:08.640 --> 00:25:14.320
            represents an organization in an Active Directory in a tenant is dedicated to the Azure ad service

            00:25:14.320 --> 00:25:20.080
            instance. A tenant is automatically created when you sign up for either Microsoft Azure,

            00:25:20.080 --> 00:25:26.720
            or Microsoft Intune, or Microsoft 365. And each Azure Azure ad tenant is distinct and separate

            00:25:26.720 --> 00:25:34.720
            from other Azure ad tenants. And so if you if you're in Azure ad, and you click on your tenant

            00:25:34.720 --> 00:25:38.480
            information, that's, that's basically what that is, right. So that's my exam pro one, and it has

            00:25:38.480 --> 00:25:44.160
            its own special tenant ID. And we can see that it's licensed for Office 365. And so that tells

            00:25:44.160 --> 00:25:55.280
            you that I'm using the Office 365 tier of Azure ad. So now let's take a look at some of the ad

            00:25:55.280 --> 00:26:00.400
            objects starting with users. So users represent an identity for a person or employee in your domain,

            00:26:00.400 --> 00:26:06.160
            and a user has login credentials, and can use them to log into the Azure portal. So here I am a user,

            00:26:06.160 --> 00:26:10.480
            and you can see it shows how many times I've logged in, and I'm part of different ad groups.

            00:26:10.480 --> 00:26:16.160
            And so you can assign roles and administrative roles to users, you can add users to groups,

            00:26:16.160 --> 00:26:21.840
            you can enforce authentication by like with MFA, you can track user sign ins, as you can see on the

            00:26:21.840 --> 00:26:28.960
            right hand side, you can track device devices, users login, and allow or deny devices, you can

            00:26:28.960 --> 00:26:34.640
            assign Microsoft licenses, Azure ad has two kinds of users, we have users, that's a user that belongs

            00:26:34.640 --> 00:26:40.160
            to an organization and guest users, this is a guest is a user that belongs from another organization.

            00:26:40.160 --> 00:26:46.720
            And we'll cover Azure ad roles in the role section here, because that is what's that you're going to

            00:26:46.720 --> 00:26:56.560
            be using to apply to these users. So groups in Azure ad lets resource owners assign a set of

            00:26:56.560 --> 00:27:00.560
            access permissions to all members of the group instead of having to provide the rights one by

            00:27:00.560 --> 00:27:04.960
            one. And so on the right hand side here, you can see I have a bunch of groups in exam Pro,

            00:27:04.960 --> 00:27:09.360
            and groups can contain owners and owners have permissions to add or remove members. And then

            00:27:09.360 --> 00:27:15.120
            the members have rights to do things, okay. And so for assignment, you can assign roles directly to

            00:27:15.120 --> 00:27:20.960
            a group, you can assign applications directly to a group, and to request join groups. So the group

            00:27:20.960 --> 00:27:26.080
            owner can let users find their own groups to join instead of assigning them to them. And the owner

            00:27:26.080 --> 00:27:31.280
            can set up the group to automatically accept all users that join or require approval, this is really

            00:27:31.280 --> 00:27:36.240
            great when you just want people to do the work themselves, as opposed to having to do all that

            00:27:36.240 --> 00:27:45.120
            manual labor of adding them to groups. Let's talk about how we're going to give users rights to

            00:27:45.120 --> 00:27:49.440
            access resources. And there are four different ways to do that. The first is direct assignment.

            00:27:49.440 --> 00:27:53.360
            This is where the resource owner is going to directly assign the user to the resource,

            00:27:53.360 --> 00:27:58.800
            then you have group assignment, this is where the resource owner assigns a group to the resource,

            00:27:58.800 --> 00:28:03.280
            which automatically gives all group members access to the resource, then you have rule based

            00:28:03.280 --> 00:28:08.000
            assignment. This is resource owner, this is where the resource owner creates a group and uses a rule

            00:28:08.000 --> 00:28:13.200
            to define which users are assigned to a specific resource. And then you have external authority

            00:28:13.200 --> 00:28:17.120
            assignment. This is this access comes from an external source such as an on premise directory

            00:28:17.120 --> 00:28:20.640
            or SAS application. I just want you to know that there's four different ways to do it. So

            00:28:21.360 --> 00:28:30.080
            to get access to resources. All right, let's take a look at managed identities for Microsoft

            00:28:30.080 --> 00:28:36.160
            Enter ID or Azure ID. Managed identities is a concept in Microsoft Enter ID that associates

            00:28:36.160 --> 00:28:40.400
            identities with internal resources where these identities have their own roles and tokens.

            00:28:40.400 --> 00:28:45.920
            Managed identities increases security by allowing you to link directly resources to other resources

            00:28:45.920 --> 00:28:50.720
            without having to share any security information over the network. Those resources will be

            00:28:50.720 --> 00:28:55.040
            authenticated against Enter ID to see if they have the necessary permissions to manipulate other

            00:28:55.040 --> 00:29:00.000
            resources. For example, we can allow our applications to access Azure key vault in

            00:29:00.000 --> 00:29:06.080
            order to retrieve a secret without exposing any passwords. Managed identities is available in two

            00:29:06.080 --> 00:29:12.000
            types. System aside identities are created and managed by Enter ID when you create a managed

            00:29:12.000 --> 00:29:17.360
            identity in a service instance. Only the Azure resource can use this identity to request tokens

            00:29:17.360 --> 00:29:24.080
            from Enter ID. User assigned identities are created and managed manually. The identity is

            00:29:24.080 --> 00:29:29.840
            managed separately from the resources that use it. The table provides a comparison between system

            00:29:29.840 --> 00:29:36.000
            assigned and user assigned features in the context of Azure creation for system assigned. The identity

            00:29:36.000 --> 00:29:41.200
            is created as part of an Azure resource. Whereas user assigned the identity is created as a standalone

            00:29:41.200 --> 00:29:46.720
            Azure resource life cycle for system assigned. The identity shares its lifecycle with the Azure

            00:29:46.720 --> 00:29:51.600
            resource it's associated with. While user assigned the identity has an independent life cycle

            00:29:51.600 --> 00:29:57.600
            deletion for system assigned when the associated Azure resource is deleted. The identity is also

            00:29:57.600 --> 00:30:04.080
            deleted. Whereas user assigned the identity must be deleted explicitly sharing across Azure resources

            00:30:04.080 --> 00:30:09.360
            for system assigned. The identity cannot be shared and is associated with only a single Azure resource.

            00:30:09.360 --> 00:30:13.840
            Whereas user assigned the identity can be shared and can be associated with more than one Azure

            00:30:13.840 --> 00:30:21.200
            resource. Managed identity is under the identity blade for an Azure resource. You assign roles to

            00:30:21.200 --> 00:30:26.640
            provide permissions to a managed identity. In summary, managed identities enhance security

            00:30:26.640 --> 00:30:31.840
            through seamless resource integration, eliminating exposed credentials. With system assigned and user

            00:30:31.840 --> 00:30:41.440
            assigned options, Azure bolsters efficient, flexible resource management. Let's talk about

            00:30:41.440 --> 00:30:45.920
            external identities. So external identities in Azure ad allows people outside your organization

            00:30:45.920 --> 00:30:51.280
            to access your apps and resources while letting them sign in and use whatever identity they prefer.

            00:30:51.280 --> 00:30:56.320
            So your partners, distributors, suppliers, vendors or other guests can bring their own identities,

            00:30:56.320 --> 00:31:01.600
            such as Google or Facebook, you can share apps with external users. That's for b2b stuff.

            00:31:01.600 --> 00:31:06.720
            If you develop apps intended for Azure ad tenants, for single tenor multi tenant,

            00:31:06.720 --> 00:31:10.640
            you can do that as well. You can develop white label apps for consumers and customers.

            00:31:11.200 --> 00:31:15.200
            This would be like Azure ad b2c. So there you go.

            00:31:15.200 --> 00:31:24.320
            Hey, this is Andrew Brown from exam Pro. And the next topic we'll be exploring our access reviews

            00:31:24.320 --> 00:31:30.560
            in Microsoft Enter ID or Azure ad access reviews in Microsoft Enter ID allow you to regularly

            00:31:30.560 --> 00:31:36.000
            review and manage access to resources in your organization. With access reviews, you can review

            00:31:36.000 --> 00:31:41.520
            who has access to resources and determine whether their access is still necessary. Access reviews

            00:31:41.520 --> 00:31:46.320
            are useful in maintaining security and compliance by ensuring that only authorized individuals have

            00:31:46.320 --> 00:31:52.080
            access to sensitive resources. Access reviews can be conducted for various types of resources,

            00:31:52.080 --> 00:31:57.520
            such as applications, groups and SharePoint online sites. You can configure access reviews

            00:31:57.520 --> 00:32:02.240
            to occur on a regular schedule and select reviewers to conduct the reviews. reviewers can

            00:32:02.240 --> 00:32:07.760
            be internal or external to your organization. During an access review, the reviewer will be

            00:32:07.760 --> 00:32:11.840
            presented with a list of people who have access to the resource being reviewed, they can choose

            00:32:11.840 --> 00:32:17.360
            to approve or revoke access for each individual. Access can be revoked immediately or scheduled for

            00:32:17.360 --> 00:32:22.960
            a later date. reviewers can also provide a reason for their decision which can be useful for auditing

            00:32:22.960 --> 00:32:28.720
            purposes. Access reviews are crucial in large organizations to regularly identify and resolve

            00:32:28.720 --> 00:32:34.480
            access issues. They ensure resources are accessed only by necessary users and that access is revoked

            00:32:34.480 --> 00:32:40.320
            when no longer needed. Overall access reviews maintain security by assessing user access,

            00:32:40.320 --> 00:32:44.960
            ensuring compliance, preventing breaches and safeguarding data promoting a security aware

            00:32:44.960 --> 00:32:49.760
            culture. Make sure to know access reviews because it did show up a few times on the exam.

            00:32:54.800 --> 00:33:00.240
            The next topic we'll be covering is single sign on and enter ID. Single sign on and enter ID is a

            00:33:00.240 --> 00:33:04.800
            feature that allows users to authenticate once with enter ID and then access multiple applications

            00:33:04.800 --> 00:33:09.600
            and services without having to authenticate again. When a user signs into enter ID with

            00:33:09.600 --> 00:33:14.160
            their credentials, enter ID creates a security token that can be used to access other resources

            00:33:14.160 --> 00:33:18.880
            within the same organization. This token can be used to authenticate the user to other cloud based

            00:33:18.880 --> 00:33:24.160
            or on premises applications that have been integrated with enter ID. SSO supports a wide

            00:33:24.160 --> 00:33:30.240
            range of applications including cloud based applications such as Microsoft 365, Salesforce,

            00:33:30.240 --> 00:33:36.400
            and Dropbox as well as on premises applications such as SharePoint and SAP. SSO can also be used

            00:33:36.400 --> 00:33:41.920
            with custom built applications using industry standard protocols such as SAML, OpenID Connect,

            00:33:41.920 --> 00:33:47.600
            and OAuth. There are several ways you can configure an application for SSO. Choosing an

            00:33:47.600 --> 00:33:53.200
            SSO method depends on how the application is configured for authentication. Cloud applications

            00:33:53.200 --> 00:33:59.200
            can use OpenID Connect, OAuth, SAML, password based, or linked for SSO. Single sign on could

            00:33:59.200 --> 00:34:05.440
            also be disabled. On premises applications can use password based, integrated windows authentication,

            00:34:05.440 --> 00:34:10.720
            header based, or linked for SSO. The on premises choices work when applications are configured for

            00:34:10.720 --> 00:34:16.560
            application proxy. This flowchart can help you decide which SSO method is best for your situation.

            00:34:18.080 --> 00:34:24.480
            The main SSO protocols supported in Azure include OpenID Connect and OAuth. OpenID Connect is an

            00:34:24.480 --> 00:34:29.520
            identity layer built on top of OAuth 2.0. It allows for authentication and authorization

            00:34:29.520 --> 00:34:36.080
            of users in a secure and standardized manner. It is SAML. SAML is an XML based protocol used

            00:34:36.080 --> 00:34:40.400
            for exchanging authentication and authorization data between an identity provider and a service

            00:34:40.400 --> 00:34:45.920
            provider. It is commonly used for federated authentication scenarios. Task word based

            00:34:45.920 --> 00:34:50.640
            authentication. This refers to the traditional username password authentication method where

            00:34:50.640 --> 00:34:55.760
            users provide their credentials directly to authenticate. Linked authentication. Azure

            00:34:55.760 --> 00:34:59.920
            provides the ability to link multiple accounts from different identity providers to a single

            00:34:59.920 --> 00:35:05.520
            user identity. This allows users to authenticate using any of their linked accounts. Integrated

            00:35:05.520 --> 00:35:10.720
            windows authentication. It will let users access applications using their windows domain credentials

            00:35:10.720 --> 00:35:15.840
            utilizing their current windows session for authentication. Header based authentication.

            00:35:15.840 --> 00:35:19.920
            In this method, the application accepts an authentication token in the form of a header

            00:35:19.920 --> 00:35:24.240
            in each request. The token is validated by the application to authenticate the user.

            00:35:24.240 --> 00:35:28.960
            You'll need to be familiar with these SSO protocols as there will be questions asking

            00:35:28.960 --> 00:35:35.600
            you which SSO protocol is best suited for a specific application. What is multi-factor

            00:35:35.600 --> 00:35:40.960
            authentication as security control where after you fill in your username, email and password,

            00:35:40.960 --> 00:35:44.560
            you have to use a second device such as a phone to confirm that it's you logging in.

            00:35:44.560 --> 00:35:50.800
            MFA protects against people who have stolen your password. MFA is an option in most cloud

            00:35:50.800 --> 00:35:56.240
            providers and even social media websites such as Facebook. So that's an overview of single

            00:35:56.240 --> 00:36:05.120
            sign on and enter ID. The next topic we'll be going over is conditional access.

            00:36:05.760 --> 00:36:10.480
            Conditional access provides an extra layer of security before allowing authenticated users to

            00:36:10.480 --> 00:36:16.320
            access data or other assets. Conditional access is implemented via conditional access policies,

            00:36:16.320 --> 00:36:20.320
            which are a set of rules that specify the conditions under which sign ins are evaluated

            00:36:20.320 --> 00:36:24.880
            and allowed. For example, you can create a conditional access policy that states,

            00:36:24.880 --> 00:36:29.840
            if the user account name is a member of a group for users that are assigned the exchange user

            00:36:29.840 --> 00:36:35.360
            password security SharePoint or global administrator roles require MFA before allowing access.

            00:36:35.360 --> 00:36:40.720
            This policy enables MFA enforcement based on group membership, simplifying the process

            00:36:40.720 --> 00:36:47.120
            compared to configuring MFA for individual users when roles change. Conditional access policy

            00:36:47.120 --> 00:36:54.320
            analyzes signals including user and location, device application and real-time risk and verifies

            00:36:54.320 --> 00:37:00.000
            every access attempt via access controls. This requires MFA block access and allow access

            00:37:00.000 --> 00:37:06.560
            signals or metadata associated with an identity attempting to gain access, user or group

            00:37:06.560 --> 00:37:11.520
            membership policies target specific users and groups giving admins fine grained control over

            00:37:11.520 --> 00:37:17.680
            access. Named location information, IP location information, IP address ranges are used to permit

            00:37:17.680 --> 00:37:23.280
            or deny access based on geographical locations. Device policies can be applied based on the

            00:37:23.280 --> 00:37:29.520
            platform or status of a user's device application users attempting to access specific applications

            00:37:29.520 --> 00:37:35.600
            can trigger different conditional access policies. Real time sign in risk detection signals and Azure

            00:37:35.600 --> 00:37:41.120
            add identity protection detect risky sign ins. If risks emerge policies can prompt actions such as

            00:37:41.120 --> 00:37:45.920
            password resets, multi factor authentication or block access pending admin intervention.

            00:37:45.920 --> 00:37:51.200
            Cloud apps or actions can include or exclude cloud applications or user actions that will

            00:37:51.200 --> 00:37:57.680
            be subject to the policy. User risk for customers with identity protection user risk can be evaluated

            00:37:57.680 --> 00:38:02.640
            as part of a conditional access policy. User risk represents the probability that a given identity

            00:38:02.640 --> 00:38:08.560
            or account is compromised. Common decisions define the access controls that decide what

            00:38:08.560 --> 00:38:15.680
            level of access based on signal information. Block access most restrictive decision. Grant access

            00:38:15.680 --> 00:38:21.040
            least restrictive decision still require one or more of the following options. Require multi

            00:38:21.040 --> 00:38:26.640
            factor authentication require device to be marked as compliant require hybrid enter ID joined device

            00:38:26.640 --> 00:38:32.240
            require approved client app and require app protection policy. Conditional access policies

            00:38:32.240 --> 00:38:37.680
            are available and can be utilized with the following licensing plans Microsoft 365 business

            00:38:37.680 --> 00:38:44.320
            premium Microsoft 365 v3 and v5 enter ID premium p one and enter ID premium p two licenses.

            00:38:44.320 --> 00:38:50.400
            Overall conditional access acts as a robust security measure in Azure ensuring that authenticated

            00:38:50.400 --> 00:39:00.160
            users can only access data under specific conditions. Hey, this is Andrew Brown from

            00:39:00.160 --> 00:39:03.600
            exam Pro. And in this section, we'll be going over the types of Azure roles.

            00:39:03.600 --> 00:39:08.320
            roles can be a bit confusing. This is because Azure has three types of roles that can serve

            00:39:08.320 --> 00:39:13.200
            the same purpose. The first type of role or classic subscription administrator roles.

            00:39:13.200 --> 00:39:18.720
            This is the original role system. Next we have Azure roles. This is an authorization system

            00:39:18.720 --> 00:39:24.000
            that's also known as role based access controls and is built on top of Azure Resource Manager.

            00:39:24.000 --> 00:39:29.200
            Then we have Azure Active Directory roles. Azure ID roles are used to manage Azure ID resources

            00:39:29.200 --> 00:39:35.280
            in a directory. Azure Active Directory roles are used to manage Azure ID resources in a directory

            00:39:35.280 --> 00:39:39.840
            such as creating or editing users assigning administrative roles to others resetting user

            00:39:39.840 --> 00:39:45.520
            passwords managing user licenses and managing domains among other tasks. The roles follow

            00:39:45.520 --> 00:39:50.640
            a similar RBC model and include several built in roles like global admin, application admin,

            00:39:50.640 --> 00:39:55.280
            application developer and billing admin but also allow the creation of custom roles for more

            00:39:55.280 --> 00:40:01.440
            specific control. Azure roles specifically Azure role based access control is a system that provides

            00:40:01.440 --> 00:40:06.480
            fine grained access management for Azure resources allowing administrators to grant users specific

            00:40:06.480 --> 00:40:11.920
            rights to resources. There are several predefined roles in Azure like owner contributor reader and

            00:40:11.920 --> 00:40:17.200
            user access administrator each providing specific levels of access to Azure resources and custom

            00:40:17.200 --> 00:40:22.480
            roles can be defined as well. Classic subscription administrator roles refer to the older model of

            00:40:22.480 --> 00:40:27.120
            Azure access control and include three types account administrator service administrator and

            00:40:27.120 --> 00:40:31.600
            co administrator. Azure roles and classic subscription administrator roles can have

            00:40:31.600 --> 00:40:36.560
            overlapping responsibilities. For example, the service administrator in the classic model has

            00:40:36.560 --> 00:40:40.960
            a similar role to the owner role in the Azure RBC where both can manage resources in the

            00:40:40.960 --> 00:40:46.640
            subscription. However, Azure RBC roles provide a more granular level of control compared to classic

            00:40:46.640 --> 00:40:51.600
            roles offering more specific access management. They allow administrators to delegate specific

            00:40:51.600 --> 00:40:56.000
            tasks and grant specific permissions reducing the need to give full administrative privileges

            00:40:56.000 --> 00:41:06.080
            and therefore enhancing security. The next topic we'll be covering are the access controls.

            00:41:06.720 --> 00:41:11.680
            So identity access management essentially allows you to create an assigned roles to users.

            00:41:11.680 --> 00:41:17.040
            For the Azure roles or the RBC system rules restrict access to resource actions which are

            00:41:17.040 --> 00:41:22.240
            also known as operations. There are two types of roles. The first type are built in roles.

            00:41:22.240 --> 00:41:27.040
            These roles refer to the set of predefined roles offered by Microsoft and Azure. The roles are read

            00:41:27.040 --> 00:41:31.520
            only and cannot be altered cover a wide array of standard scenarios to facilitate efficient and

            00:41:31.520 --> 00:41:37.120
            secure access management for Azure resources. The second type of role or custom roles. These

            00:41:37.120 --> 00:41:41.280
            roles represent user defined roles in Azure tailored to incorporate unique permissions and

            00:41:41.280 --> 00:41:46.160
            logic based on specific requirements that aren't satisfied by the available built in roles.

            00:41:46.160 --> 00:41:52.080
            A role assignment is when you apply a role to a service principle which could be a user group to

            00:41:52.080 --> 00:41:58.080
            service principle or managed identity. Deny assignments block users from performing specific

            00:41:58.080 --> 00:42:02.720
            actions even if a role assignment grants them access. The only way to apply deny assignments

            00:42:02.720 --> 00:42:06.560
            is through Azure blueprints. So that's the access controls for Azure.

            00:42:06.560 --> 00:42:15.760
            Hey, this is Andrew Brown from exam Pro. And in this section, we'll be covering classic

            00:42:15.760 --> 00:42:20.960
            administrators. Classic administrators refer to the original role system in Azure. Despite the

            00:42:20.960 --> 00:42:24.960
            legacy status of classic administrators, understanding these roles can still be

            00:42:24.960 --> 00:42:29.760
            beneficial like when working with older Azure setups. However, it's recommended to use the

            00:42:29.760 --> 00:42:35.680
            new RBC system for managing access to resources given its enhanced granularity and flexibility.

            00:42:35.680 --> 00:42:40.720
            Classic administrators have three types of roles. The first type is account administrator. This

            00:42:40.720 --> 00:42:45.120
            role is essentially the billing owner of the Azure subscription. It's responsible for managing

            00:42:45.120 --> 00:42:50.080
            subscriptions, making payments and changing the billing details. The account admin has no access

            00:42:50.080 --> 00:42:54.880
            to the Azure portal, meaning they can't manage resources directly. The second type is service

            00:42:54.880 --> 00:42:59.360
            administrator. This role shares the same level of access as a user assigned the owner role at

            00:42:59.360 --> 00:43:04.400
            the subscription scope in the RBC model, they have full access to the Azure portal, meaning they can

            00:43:04.400 --> 00:43:09.760
            manage all resources within the subscription. The third type is co administrator. This has the same

            00:43:09.760 --> 00:43:14.400
            access level of a user who is assigned the owner role at the subscription scope. It's similar to a

            00:43:14.400 --> 00:43:18.800
            service admin. But the main difference is that there can be multiple co administrators offering

            00:43:18.800 --> 00:43:23.760
            shared management capabilities. You shouldn't have to worry much about the classic admin roles

            00:43:23.760 --> 00:43:28.080
            because I don't think I encountered any exam questions on it. It'll mostly be focused on the

            00:43:28.080 --> 00:43:33.840
            RBC and Azure ad roles. Also note that classic resources and classic administrators will be

            00:43:33.840 --> 00:43:45.360
            retired on August 31 2024. The next topic we'll be covering is the Azure role based access control.

            00:43:45.360 --> 00:43:49.920
            So as your role based access control helps you manage who has access to Azure resources,

            00:43:49.920 --> 00:43:55.040
            what actions they can perform on resources and in what scope which are the areas they have access to

            00:43:55.040 --> 00:43:59.920
            role assignments or the way you control access to resources by assigning a role to a security

            00:43:59.920 --> 00:44:04.960
            principle like a user group service principle or managed identity at a particular scope,

            00:44:04.960 --> 00:44:09.760
            you define who can perform what actions on which resources. A role assignment consists of these

            00:44:09.760 --> 00:44:15.920
            three elements, scope, role definition, and security principle. There are four fundamental

            00:44:15.920 --> 00:44:20.720
            Azure roles which include owner contributor, reader and user access administrator.

            00:44:20.720 --> 00:44:26.240
            Azure RBC includes over 70 built in roles. These roles are designed to serve many common use cases

            00:44:26.240 --> 00:44:30.800
            and range from broad to very specific permissions such as virtual machine contributor or network

            00:44:30.800 --> 00:44:37.120
            contributor. scope is the set of resources that access for the role assignment applies to scope

            00:44:37.120 --> 00:44:42.480
            access controls at the management subscription resource group and resource level. assigning a

            00:44:42.480 --> 00:44:47.680
            role at the management group level inherits it across all associated subscriptions and resources.

            00:44:47.680 --> 00:44:52.160
            At the subscription level, it applies to all resource groups and resources within the specific

            00:44:52.160 --> 00:44:57.440
            subscription. A role assigned at the resource group level affects all resources within that group.

            00:44:57.440 --> 00:45:01.280
            At the resource level, a role assignment applies only to that specific resource.

            00:45:01.280 --> 00:45:06.640
            A role definition is a set of permissions that determines what actions can be performed such as

            00:45:06.640 --> 00:45:12.240
            read, write or delete on various resources. roles range from broad such as owner with extensive

            00:45:12.240 --> 00:45:17.520
            management permissions to specific such as virtual machine reader with more targeted permissions.

            00:45:17.520 --> 00:45:22.960
            Azure has built in roles and you can define custom roles. This table shows the four fundamental built

            00:45:22.960 --> 00:45:28.080
            in roles. The owner role has full access to all resources including the right to delegate access

            00:45:28.080 --> 00:45:33.120
            to others. The contributor role can manage all types of Azure resources including the ability

            00:45:33.120 --> 00:45:39.040
            to create update and delete but can't grant access to others. The reader role has the ability to view

            00:45:39.040 --> 00:45:44.400
            existing Azure resources but can't make changes or grant access to others. The user access

            00:45:44.400 --> 00:45:49.440
            administrator role has the ability to manage user access to Azure resources including granting and

            00:45:49.440 --> 00:45:56.160
            revoking access but can't create update or delete resources. As security principle represents the

            00:45:56.160 --> 00:46:01.360
            identities requesting access to an Azure resource such as a user which is an individual who has a

            00:46:01.360 --> 00:46:07.280
            profile in Azure Active Directory, a group which is a set of users created in Azure Active Directory,

            00:46:07.280 --> 00:46:12.960
            a service principle which is a security identity used by applications or services to access

            00:46:12.960 --> 00:46:18.640
            specific Azure resources, or a managed identity which is an identity in Azure Active Directory

            00:46:18.640 --> 00:46:24.160
            that is automatically managed by Azure. So that's an overview of Azure role based access control.

            00:46:29.360 --> 00:46:34.720
            The last type of role we'll be covering are Azure AD roles. Azure AD roles are used to manage Azure

            00:46:34.720 --> 00:46:40.720
            AD resources in a directory such as create or edit users, assign administrative roles to others,

            00:46:40.720 --> 00:46:47.120
            reset user passwords, manage user licenses, and manage domains. We'll go over a few important

            00:46:47.120 --> 00:46:52.400
            built in Azure AD roles. So here are some that you should know. The first one is global administrator.

            00:46:52.400 --> 00:46:57.760
            This grants you full access to everything all the features in Azure AD. Another important role is

            00:46:57.760 --> 00:47:03.040
            user administrator. This grants you full access to create and manage users. For the billing

            00:47:03.040 --> 00:47:07.760
            administrator role, this role can make purchases, manage subscriptions and support tickets,

            00:47:07.760 --> 00:47:12.640
            including monitor service health. Not all organizations needs can be satisfied by these

            00:47:12.640 --> 00:47:17.680
            predefined roles. Therefore, you can create custom roles which are very flexible and can define the

            00:47:17.680 --> 00:47:22.160
            exact set of permissions that you need. Keep in mind that you'll need to purchase either

            00:47:22.160 --> 00:47:28.560
            Azure AD Premium P1 or P2 to create custom roles. So that's a short overview of Azure AD roles.

            00:47:28.560 --> 00:47:38.400
            Hey, this is Andrew Brown from exam Pro. And in this section, we'll be covering the anatomy of

            00:47:38.400 --> 00:47:43.280
            an Azure role. So it's important to know that the property names in an Azure role definition can

            00:47:43.280 --> 00:47:47.680
            vary depending on whether you're using Azure PowerShell or Azure CLI. The two different

            00:47:47.680 --> 00:47:52.800
            interfaces use different syntax and terminology. We have an example here on the right and we'll

            00:47:52.800 --> 00:47:57.280
            go through the properties together. A role definition in Azure consists of these properties.

            00:47:57.280 --> 00:48:02.960
            Name, this is the display name of the custom role. Also note that the ones highlighted in blue is the

            00:48:02.960 --> 00:48:08.800
            syntax for Azure PowerShell and bold black is for Azure CLI. So it's named for Azure PowerShell and

            00:48:08.800 --> 00:48:14.480
            role name is for Azure CLI. The next property is ID. This is a unique ID of the custom role and

            00:48:14.480 --> 00:48:19.600
            it is auto generated for you is custom. This indicates whether this is a custom role, it can

            00:48:19.600 --> 00:48:25.840
            be either true or false. Description, this property describes the role actions. This is an array of

            00:48:25.840 --> 00:48:30.960
            strings that specify the management operations that the role is allowed to perform, not actions

            00:48:30.960 --> 00:48:35.040
            an array of strings that specify the management operations that are excluded from the allowed

            00:48:35.040 --> 00:48:40.720
            actions. Data actions. This is an array of strings that specify data operations, the role is allowed

            00:48:40.720 --> 00:48:46.000
            to perform to your data within that object, not data actions. This is an array of strings that

            00:48:46.000 --> 00:48:51.600
            specify the data operations that are excluded from the allowed data actions. Assignable scopes. This

            00:48:51.600 --> 00:48:56.080
            is an array of strings that specify the scopes that the custom role is available for assignment.

            00:48:56.080 --> 00:48:59.680
            You can only define one management group and assignable scopes of a custom role.

            00:48:59.680 --> 00:49:05.120
            So in this example, we see that there is an asterisk symbol that's used in the specific

            00:49:05.120 --> 00:49:11.200
            actions and the actions property like storage, network, compute, etc. This is called the wildcard

            00:49:11.200 --> 00:49:16.960
            permission symbol represented as an asterisk. This is used in the actions, not actions, data actions

            00:49:16.960 --> 00:49:22.880
            and not data actions properties to represent all or any operations. And wildcard allows you to apply

            00:49:22.880 --> 00:49:30.400
            to match everything. In the example of actions, Microsoft dot storage slash asterisk slash read

            00:49:30.400 --> 00:49:34.720
            in a role definition, this means that the role is granted the permission to perform read operations

            00:49:34.720 --> 00:49:40.880
            on all resource types under the Microsoft storage resource provider. So the wildcard essentially

            00:49:40.880 --> 00:49:45.840
            allows you to either grant or deny a wide range of permissions with a single statement. However,

            00:49:45.840 --> 00:49:49.760
            it should be used with caution because it can grant or deny more permissions that intended if

            00:49:49.760 --> 00:50:00.320
            not properly managed. It can be a bit confusing to distinguish between Azure policies and Azure

            00:50:00.320 --> 00:50:04.960
            roles. So we'll do a little comparison to help you understand the key differences. For the Azure

            00:50:04.960 --> 00:50:10.240
            policies, they are used to ensure compliance of resources. They evaluate the state by examining

            00:50:10.240 --> 00:50:14.480
            properties on resources that are represented in resource manager and properties of some resource

            00:50:14.480 --> 00:50:20.400
            provider. It doesn't restrict actions, which are also called operations. They ensure that resource

            00:50:20.400 --> 00:50:24.640
            state is complied to your business rules without concern for who made the change or who has

            00:50:24.640 --> 00:50:30.160
            permission to make a change. Even if an individual has access to perform an action, if the result is

            00:50:30.160 --> 00:50:36.000
            a non compliant resource, Azure policy still blocks the creator update. As for the Azure roles,

            00:50:36.000 --> 00:50:41.680
            they are used to control access to Azure resources. They focus on managing user actions at different

            00:50:41.680 --> 00:50:48.320
            levels of scopes. And Azure roles do restriction on Azure resources. Another thing people tend to

            00:50:48.320 --> 00:50:54.320
            get confused between our Azure ID roles versus Azure roles. For Azure ID roles, they are used

            00:50:54.320 --> 00:51:00.080
            for managing Azure ID resources. For Azure roles, they are used for fine grained access control to

            00:51:00.080 --> 00:51:07.520
            Azure resources. Active Directory resources include users, groups, billing, licensing,

            00:51:07.520 --> 00:51:15.040
            application registration, etc. Azure resources included virtual machines, databases, cloud

            00:51:15.040 --> 00:51:21.760
            storage, cloud networking, etc. By default, Azure roles and Azure ID roles are separate and do not

            00:51:21.760 --> 00:51:26.880
            span Azure and Azure ID. By default, the global administrator doesn't have permissions to manage

            00:51:26.880 --> 00:51:31.920
            Azure resources. Global administrator can gain access to Azure resource if granted the user

            00:51:31.920 --> 00:51:37.920
            access administrator role. So Azure ID roles are specifically for managing Azure ID resources

            00:51:37.920 --> 00:51:48.960
            while Azure roles focus on access control to Azure resources. Hey, this is Andrew Brown from exampro.

            00:51:48.960 --> 00:51:54.000
            And in this section, we'll be covering Azure policies. Azure policies enforce organizational

            00:51:54.000 --> 00:51:59.440
            standards and assess compliance at scale. policies do not restrict access, they only observe for

            00:51:59.440 --> 00:52:04.320
            compliance. Here is an image with a list of built in policies that you can use right away from

            00:52:04.320 --> 00:52:10.320
            Azure. Let's go over a few key aspects of Azure policies. The first one or policy definitions,

            00:52:10.320 --> 00:52:15.760
            which is a JSON file used to describe business rules to control access to resources. Then we

            00:52:15.760 --> 00:52:20.640
            have policy assignment. This is the scope of a policies effect, it can be assigned to a user,

            00:52:20.640 --> 00:52:26.240
            a resource group or management group. Next, we have policy parameters. These are the values you

            00:52:26.240 --> 00:52:30.640
            can pass into your policy definition, which makes your policies more flexible for reuse.

            00:52:30.640 --> 00:52:35.840
            And we have initiative definitions. This is a collection of policy definitions that you can

            00:52:35.840 --> 00:52:42.560
            assign, for example, a group of policies to enforce PCI DSS compliance. Next, we'll look

            00:52:42.560 --> 00:52:48.240
            at viewing non compliant resources. Once a policy is assigned, it will periodically evaluate the

            00:52:48.240 --> 00:52:54.000
            compliance state. You can see how compliant we are on the compliance tab. According to the example

            00:52:54.000 --> 00:52:58.720
            in the image, it shows that we are non compliant, it can occur due to many factors, but it's most

            00:52:58.720 --> 00:53:04.000
            likely because virtual machines should have disaster recovery enabled. So let's look at some

            00:53:04.000 --> 00:53:09.600
            of the main use cases for Azure policy, organizational compliance, Azure policy enforces

            00:53:09.600 --> 00:53:14.560
            standards and assesses compliance at scale such as enforcing compliance labels on all resources.

            00:53:14.560 --> 00:53:20.320
            Cost control policies can prevent over provisioning to save costs like limiting the creation of high

            00:53:20.320 --> 00:53:26.240
            cost VNs. Security enhancements policies can improve security by enforcing configurations,

            00:53:26.240 --> 00:53:32.320
            for example, requiring secure transfer for all storage accounts. Resource consistency policies

            00:53:32.320 --> 00:53:36.880
            can enforce consistent configurations like a specific naming convention or tax structure.

            00:53:37.600 --> 00:53:43.280
            Regulatory compliance policies can ensure specific configurations for regulatory compliance,

            00:53:43.280 --> 00:53:47.040
            such as data hosting in specific regions for data sovereignty.

            00:53:47.040 --> 00:53:49.520
            So that's a brief overview of Azure policies.

            00:53:49.520 --> 00:53:59.680
            The scope of an Azure policy is the set of resources that the policy is applied to.

            00:53:59.680 --> 00:54:03.440
            When you assign a policy, you define the scope at which the policy is enforced.

            00:54:04.000 --> 00:54:08.400
            This could be as broad as a management group or as specific as a single resource.

            00:54:08.400 --> 00:54:13.520
            The hierarchy of scopes in Azure are like other scopes like Azure Resource Manager or RBC.

            00:54:13.520 --> 00:54:17.840
            It moves from broad to specific in the following order management group greater than subscription

            00:54:17.840 --> 00:54:22.720
            greater than resource group greater than resource. At each level, you can apply different policies

            00:54:22.720 --> 00:54:27.360
            as per your requirements. Policies applied at higher levels of the hierarchy are inherited

            00:54:27.360 --> 00:54:33.040
            by all the lower levels. This structure provides a powerful mechanism for applying broad organizational

            00:54:33.040 --> 00:54:38.480
            policies while still allowing for flexibility and customization at lower levels. It's a key part of

            00:54:38.480 --> 00:54:42.880
            how Azure enables you to manage and control your resources effectively and in a way that suits your

            00:54:42.880 --> 00:54:52.960
            organizational needs. Hey, this is Andrew Brown from exam Pro. And we'll go over the anatomy of

            00:54:52.960 --> 00:54:58.880
            an Azure policy definition file display name. This serves as an identifier for the policy and has a

            00:54:58.880 --> 00:55:05.280
            128 character limit. Type this field which is read only indicates the source of the policy.

            00:55:05.280 --> 00:55:12.000
            It could be built in maintained by Microsoft custom created by you or static Microsoft owned

            00:55:12.000 --> 00:55:17.360
            and typically pertains to regulatory compliance description. This provides the context of the

            00:55:17.360 --> 00:55:23.360
            policy metadata. This optional field is used to store key value information on the policy.

            00:55:23.360 --> 00:55:28.080
            Though this determines which resource types are evaluated and changes whether resource provider

            00:55:28.080 --> 00:55:34.000
            or Azure Resource Manager is used. Resource Manager modes include all this includes resource

            00:55:34.000 --> 00:55:39.120
            groups, subscriptions and all resource types and indexed. This only includes resource types that

            00:55:39.120 --> 00:55:44.800
            support tags and location. Resource Provider modes were used in deprecated services like Microsoft

            00:55:44.800 --> 00:55:49.600
            Container Service data and are now primarily utilized in services like Microsoft Kubernetes

            00:55:49.600 --> 00:55:55.600
            data and Microsoft Key Vault data. Moving on to parameters, parameters are values passed into the

            00:55:55.600 --> 00:56:01.440
            policy to improve its flexibility. A parameter has the following properties, name the identifier for

            00:56:01.440 --> 00:56:08.240
            the parameter type could be a string array object Boolean integer float or date time metadata

            00:56:08.240 --> 00:56:12.960
            utilized by Azure to display user friendly information such as description display name

            00:56:12.960 --> 00:56:19.360
            strong type assign permissions, default value and optional field to set a default parameter value,

            00:56:19.360 --> 00:56:24.320
            allowed values and optional field for setting accepted parameter values. You reference

            00:56:24.320 --> 00:56:30.880
            parameters by using field and in. Next, let's go over the policy rule. So this consists of if and

            00:56:30.880 --> 00:56:35.920
            then blocks and the if block you define one or more conditions that specify when the policy is

            00:56:35.920 --> 00:56:41.440
            enforced. You can apply logical operators to these conditions to precisely define the scenario for a

            00:56:41.440 --> 00:56:47.680
            policy. The next concept we'll look into is the policy rule and policy effect, which is important

            00:56:47.680 --> 00:56:54.160
            in determining the impact of the policy. So we'll go over a list of common policy effects. Deny if

            00:56:54.160 --> 00:56:59.680
            a resource's creation or update doesn't adhere to the policy it fails. Audit this creates a warning

            00:56:59.680 --> 00:57:04.400
            event in the activity log when evaluating a non compliant resource but it doesn't stop the request

            00:57:04.400 --> 00:57:10.080
            append this effect adds extra parameters or fields to the resource during its creation or update.

            00:57:10.080 --> 00:57:15.040
            For example, it could append tags on resources like cost center or specify allowed IP addresses

            00:57:15.040 --> 00:57:20.560
            for a storage resource. Audit if not exists. Similarly to the audit effect, this creates a

            00:57:20.560 --> 00:57:25.120
            warning event in the activity log when a resource doesn't comply with the policy but it doesn't stop

            00:57:25.120 --> 00:57:29.760
            the request audit is used to audit the properties of a resource while audit if not exists is used

            00:57:29.760 --> 00:57:35.280
            to audit the existence of a related resource. Deploy if not exists. This effect executes a

            00:57:35.280 --> 00:57:40.560
            template deployment when a specific condition is met. For example, if SQL encryption is enabled on

            00:57:40.560 --> 00:57:45.360
            a database, a template can be executed after the database creation to configure it in a specific

            00:57:45.360 --> 00:57:51.360
            way. And the last one is disabled. This effect turns off the policy rule often used for testing

            00:57:51.360 --> 00:57:56.320
            purposes. These policy effects provide a range of responses to non compliance,

            00:57:56.320 --> 00:58:00.640
            enabling you to manage your resources according to your organization specific requirements.

            00:58:00.640 --> 00:58:09.920
            Hey, this is Andrew Brown from exam Pro. And we're going to take a look at how to

            00:58:09.920 --> 00:58:14.480
            keep things compliant within our Azure account with Azure policies. Let's make our way over to

            00:58:14.480 --> 00:58:20.160
            the Azure policy portal by typing policy at the top here. And right away, you can see already that

            00:58:20.160 --> 00:58:25.200
            I have a policy assigned. I didn't sign this as your did this for me by default. And it's a great

            00:58:25.200 --> 00:58:29.600
            way to start understanding how this is useful. So I'm going to go ahead and just click into that one

            00:58:29.600 --> 00:58:34.880
            there. And this is an initiative policy, meaning that it's made up of a bunch of policies. We'll

            00:58:34.880 --> 00:58:38.800
            go over that over in a moment. But you can see here that saying, hey, you should turn on all

            00:58:38.800 --> 00:58:42.560
            these things. They're not turned on by default. So you should turn them on. And these are ones

            00:58:42.560 --> 00:58:46.640
            that you have not turned on, you might not want to consider turning some of these on,

            00:58:46.640 --> 00:58:51.680
            if you have to consider costs, but I think most of these are free. But that's something that you'll

            00:58:51.680 --> 00:58:56.400
            have to decide on your own. But that gives you a general idea there. So let's go back to policy at

            00:58:56.400 --> 00:59:01.520
            the top. On the left hand side here, we can see our assignments. And here I have that initiative

            00:59:01.520 --> 00:59:06.800
            type there, if I click into it allows me to edit it there. And what's really nice is if I want to

            00:59:06.800 --> 00:59:11.280
            disable it, I could just disable it. But I think this is a default one. So Oh, no, I can disable

            00:59:11.280 --> 00:59:16.960
            it. Okay, great. And you can see it was assigned by who, and then you can also take remediation

            00:59:16.960 --> 00:59:21.760
            actions here. So by default, this assignment will only take effect on newly created resources,

            00:59:21.760 --> 00:59:26.720
            existing resources can be updated via remediation task after the policy is assigned. So if you need

            00:59:26.720 --> 00:59:33.200
            this applied to ones that are created, or prior, or updated, that's something you might want to do.

            00:59:33.200 --> 00:59:38.560
            But anyway, we'll get out of there. And we'll go take a look at all the big list of predefined

            00:59:38.560 --> 00:59:44.560
            definitions that Azure gives us. So this is a great way for us to get started. You'll notice

            00:59:44.560 --> 00:59:49.120
            on the right hand side, we have initiative and we have policy. Again, initiative is a collection of

            00:59:49.120 --> 00:59:54.240
            policies down below. And these are individual ones. Let's just go take a look at some policies.

            00:59:54.240 --> 00:59:59.520
            And maybe we can go apply one to like a virtual machine. So what I'm going to do is just drop down

            00:59:59.520 --> 01:00:07.200
            this here. And we can just unselect here. And let's just go take a look. Do we have one called

            01:00:07.200 --> 01:00:15.920
            virtual machines? Not really. What we go for compute here. And we just take a look here. So

            01:00:15.920 --> 01:00:19.920
            audit virtual machine without disaster recovery. Let's take a look at that one.

            01:00:19.920 --> 01:00:26.400
            And I just want to see the full description here. Audit virtual machine without disaster

            01:00:26.400 --> 01:00:30.320
            recovery configured. I think that sounds really good to me. So I'm going to go ahead and assign

            01:00:30.320 --> 01:00:36.640
            that. And we can choose a scope. And so I'm going to choose my subscription here. And then we can

            01:00:36.640 --> 01:00:40.480
            choose a resource group. And you're going to notice that I don't actually have any resources. So

            01:00:40.480 --> 01:00:45.680
            to scope that within, so what we'll go do is launch ourself a virtual machine.

            01:00:45.680 --> 01:00:50.960
            So make our way over to the virtual machine. portal here, we'll add a virtual machine.

            01:00:50.960 --> 01:00:56.240
            And I want something really cheap. And so here it's set to a more expensive one,

            01:00:56.240 --> 01:01:00.960
            because I was launching a Windows Server previously. But I want the cheapest server

            01:01:00.960 --> 01:01:05.440
            I can get. Actually, before I do that, I'm just going to go back and Oh, yeah, it's on Ubuntu,

            01:01:05.440 --> 01:01:13.040
            just making sure. And the one I had that was really cheap is the B one LS. And so I'm just

            01:01:13.040 --> 01:01:19.840
            going to go up here to the top. We'll name this a Bayshore. And we'll put in the Bayshore group there.

            01:01:19.840 --> 01:01:26.240
            This size does not support Azure spot, that's totally fine. I don't need spot. Did I turn

            01:01:26.240 --> 01:01:32.400
            that on by accident? Oh, I did. And this all looks fine to me, I'm not going to be logging

            01:01:32.400 --> 01:01:36.080
            into this machine, we just want to launch it up as an example, I'm going to move to standard SSD,

            01:01:36.080 --> 01:01:41.120
            because I don't need premium here. And this looks fine to me, we'll go ahead and hit review and

            01:01:41.120 --> 01:01:50.000
            create. So we'll go ahead and create that. And I guess we have to download that private key,

            01:01:50.000 --> 01:01:52.480
            probably a good idea. We're not going to use it for anything, but that's okay.

            01:01:52.480 --> 01:01:58.880
            And now that's deploying, let's see if we can select the scope as it's creating. I'm not sure

            01:01:58.880 --> 01:02:04.080
            if it'll let us do that, I'm just going to hit cancel here and reopen here. And let's see if

            01:02:04.080 --> 01:02:11.200
            it shows up. Now it doesn't. So we'll just wait a moment here. I'll go back to my policy here.

            01:02:11.200 --> 01:02:15.840
            And I'm just going to wait for this server to create. And once that is created,

            01:02:15.840 --> 01:02:21.120
            what we'll do is we'll just come back here and see if we can now scope that.

            01:02:21.120 --> 01:02:25.680
            Alright, so after a short little wait, our server is ready here. So let's make our way back to our

            01:02:25.680 --> 01:02:31.440
            policy here. And I guess I lost it. So I have to go back to definitions.

            01:02:31.440 --> 01:02:36.320
            And we'll drop down categories, do you select we'll go to compute.

            01:02:36.320 --> 01:02:42.560
            And we'll go ahead and click on disaster recovery. Again, here, you can see the policy in its

            01:02:42.560 --> 01:02:47.360
            entirety. So that's kind of nice. We'll go ahead and assign that and we'll choose our scope. So

            01:02:47.360 --> 01:02:52.400
            we'll go back here to subscription one. Now we should have a door. And I'll go ahead and hit

            01:02:52.400 --> 01:02:57.760
            select. We can assign exclusions, not something I'm going to do today. There is the name of it,

            01:02:57.760 --> 01:03:01.920
            that's totally fine. And we can hit enabled. And I'm the one who's enabling it. So that sounds like

            01:03:01.920 --> 01:03:07.200
            a good idea. We'll go next, we're going to leave remediation off, we don't need to do that today,

            01:03:07.200 --> 01:03:11.680
            we'll hit create. And so now this policy is assigned, it says here, please note that the

            01:03:11.680 --> 01:03:16.880
            assignment takes around 30 minutes to take effect. So we work our way back here and look at assignments.

            01:03:18.000 --> 01:03:24.800
            I don't see it here yet. So there it is. And it's probably not going to show us on there.

            01:03:24.800 --> 01:03:31.840
            So we'll go back to our overview. And so I want to see, it hasn't started yet. So we'll just wait

            01:03:31.840 --> 01:03:36.560
            for a while here might take 30 minutes might take 10, not sure. And we'll just see what happens.

            01:03:36.560 --> 01:03:41.680
            This should show up as non compliant. But let's see that actually happen. Alright, so after waiting a

            01:03:41.680 --> 01:03:46.080
            little while here, I think it was about 1520 minutes, we can now see that it's saying that

            01:03:46.080 --> 01:03:53.680
            it's non compliant. So we'll go ahead and click into there. We can see what exactly is complaining

            01:03:53.680 --> 01:04:00.800
            about. We click over to that resource. So there you go. It's not too complicated there. We'll go

            01:04:00.800 --> 01:04:08.240
            ahead and just delete that assignment. And if you're wondering where blueprints are, they're

            01:04:08.240 --> 01:04:12.000
            all the way over here, we talked about blueprints in the actual course, not something we actually

            01:04:12.000 --> 01:04:17.840
            have to do because it is probably a better way of doing things. I just wanted to point that out

            01:04:17.840 --> 01:04:21.120
            to you. But yeah, there you go. So it's as simple as that.

            01:04:21.120 --> 01:04:30.320
            Hey, this is Andrew Brown from exam Pro. And in this section, we'll be covering Azure Resource

            01:04:30.320 --> 01:04:35.440
            Manager. Azure Resource Manager is a service that allows you to manage Azure resources.

            01:04:35.440 --> 01:04:40.240
            Azure Resource Manager is a collection of services in the Azure portal. So you can't simply type in

            01:04:40.240 --> 01:04:45.600
            Azure Resource Manager in the search tab. It is a management layer that allows you to create,

            01:04:45.600 --> 01:04:51.680
            update or delete resources, apply management features such as access controls, locks or tags,

            01:04:51.680 --> 01:04:56.480
            and write infrastructure as code using JSON templates. We will be examining the following

            01:04:56.480 --> 01:05:01.520
            key components that form the Azure Resource Manager layer. We have subscriptions, management

            01:05:01.520 --> 01:05:06.480
            groups, resource groups, resource providers, resource locks, Azure blueprints, as well as

            01:05:06.480 --> 01:05:12.080
            resource tags, access control, role based access controls, Azure policies and ARM templates.

            01:05:12.080 --> 01:05:17.520
            You can think of Azure Resource Manager as a gatekeeper. All of the requests flow through

            01:05:17.520 --> 01:05:21.840
            ARM and it decides whether that request can be performed on a resource such as the creation,

            01:05:21.840 --> 01:05:26.400
            updating and deletion of a virtual machine and its arms responsibility to authenticate and

            01:05:26.400 --> 01:05:31.840
            authorize these requests. ARM uses Azure's role based access control to determine whether a user

            01:05:31.840 --> 01:05:36.800
            has the necessary permissions to carry out a request. When a request is made, ARM checks the

            01:05:36.800 --> 01:05:40.960
            user's assigned roles and the permissions associated with those roles. If the user has

            01:05:40.960 --> 01:05:47.680
            the necessary permissions, the request is allowed, otherwise it is denied. The next concept we'll go

            01:05:47.680 --> 01:05:52.400
            over is the scope for Azure Resource Manager. We've briefly covered scope in Azure Policy and

            01:05:52.400 --> 01:05:56.800
            Azure RBAC, but we'll go into more detail with them in the following sections for ARM.

            01:05:57.920 --> 01:06:02.640
            So scope is a boundary of control for Azure resources. It is a way to govern your resource

            01:06:02.640 --> 01:06:07.840
            by placing resources within a logical grouping and applying logical restrictions in the form of rules.

            01:06:07.840 --> 01:06:11.680
            Management groups are a logical grouping of multiple subscriptions.

            01:06:11.680 --> 01:06:16.720
            Subscriptions grant you access to Azure services based on a billing and support agreement.

            01:06:16.720 --> 01:06:22.720
            Resource groups are a logical grouping of multiple resources. And resources can be a specific Azure

            01:06:22.720 --> 01:06:30.000
            service such as Azure VMs. So that's an overview of Azure Resource Manager.

            01:06:30.000 --> 01:06:37.360
            Azure management groups provide a way to manage multiple subscriptions by organizing them into

            01:06:37.360 --> 01:06:42.480
            a hierarchical structure. Every directory is assigned a single top level management group

            01:06:42.480 --> 01:06:46.640
            known as the root management group. This root group forms the base of the hierarchy and can

            01:06:46.640 --> 01:06:52.080
            have multiple management groups or subscriptions nested under it. One of the key benefits of using

            01:06:52.080 --> 01:06:56.080
            management groups is that all subscriptions within a management group automatically inherit

            01:06:56.080 --> 01:07:00.960
            the conditions applied to the management group. Some important facts about management groups you

            01:07:00.960 --> 01:07:06.880
            should know are a single directory can support up to 10,000 management groups. The hierarchy of a

            01:07:06.880 --> 01:07:11.760
            management group tree can be up to six levels deep, not including the root level or the subscription

            01:07:11.760 --> 01:07:17.040
            level. Each management group and subscription could have only one parent. Each management

            01:07:17.040 --> 01:07:21.920
            group could have multiple children. All subscriptions and management groups exist within a single

            01:07:21.920 --> 01:07:26.560
            hierarchy in each directory. So that's a short overview of Azure management groups.

            01:07:26.560 --> 01:07:35.920
            Before you can do anything in your Azure account, you'll need to have a subscription.

            01:07:35.920 --> 01:07:41.200
            An Azure account can have multiple subscriptions and the most commonly used ones are free trial,

            01:07:41.200 --> 01:07:46.080
            pay as you go and Azure for students. For example, if you want a developer support,

            01:07:46.080 --> 01:07:50.880
            you would add a developer support subscription to your account. Once a subscription is set up,

            01:07:50.880 --> 01:07:55.680
            it provides you with the ability to configure various settings and features such as resource

            01:07:55.680 --> 01:08:00.320
            tags. These allow you to categorize your resources according to your organizational needs.

            01:08:00.320 --> 01:08:04.800
            Access controls helps manage access and permissions for your Azure resources.

            01:08:04.800 --> 01:08:09.840
            Resources groups are logical containers in which Azure resources are deployed and managed.

            01:08:09.840 --> 01:08:14.080
            Cost management and billing provides tools to track and manage your cloud spending

            01:08:14.080 --> 01:08:19.120
            and more. These features provide you with a high degree of flexibility and control over your Azure

            01:08:19.120 --> 01:08:22.640
            resources, allowing you to manage your resources effectively and securely.

            01:08:22.640 --> 01:08:32.480
            The next topic we'll be covering a resource groups. So a resource group is a container

            01:08:32.480 --> 01:08:37.120
            that holds related resources for an Azure solution. For example, you might have a resource

            01:08:37.120 --> 01:08:42.960
            group that contains multiple virtual machines for a specific project or application. As for resources,

            01:08:42.960 --> 01:08:47.520
            these are manageable items available through Azure, a resource could be an individual entity like a

            01:08:47.520 --> 01:08:53.360
            virtual machine. Next, we have resource providers. These are services that supply Azure resources.

            01:08:53.360 --> 01:08:58.480
            An example of a resource provider is Microsoft Compute, which provides compute resources like

            01:08:58.480 --> 01:09:04.720
            VMs. In order to use Azure resources, you have to register resource providers. Many resource

            01:09:04.720 --> 01:09:09.760
            providers are registered by default for you with your subscription. However, for certain resources,

            01:09:09.760 --> 01:09:14.320
            you may need to manually register the resource provider. This image shows a list of resource

            01:09:14.320 --> 01:09:18.720
            providers available in Azure and in the status, you can see if they are either registered or not

            01:09:18.720 --> 01:09:23.600
            registered. You can register resource providers under your subscription in the Azure portal

            01:09:23.600 --> 01:09:28.560
            through Azure PowerShell or Azure CLI. This ensures you have access to the latest resources

            01:09:28.560 --> 01:09:38.000
            and features provided by that service. The next topic we'll explore our resource tags.

            01:09:38.000 --> 01:09:43.280
            So a tag is a pair consisting of a key and a value that you can assign to Azure resources.

            01:09:43.280 --> 01:09:47.600
            These tags can be used to categorize resources based on different criteria relevant to your

            01:09:47.600 --> 01:09:54.400
            organization. Here are some examples of tags. Department equals finance, status equals approved,

            01:09:54.400 --> 01:10:00.080
            team equals compliance, environment equals production, project equals enterprise,

            01:10:00.080 --> 01:10:05.040
            location equals West US. Tags allow you to organize your resources in the following ways.

            01:10:05.040 --> 01:10:10.400
            Resource management tags can help you sort and manage resources based on specific workloads

            01:10:10.400 --> 01:10:15.840
            or environments such as developer environments. Cost management and optimization tags can be

            01:10:15.840 --> 01:10:21.040
            used for cost tracking, setting budgets and creating alerts. Operations management tags

            01:10:21.040 --> 01:10:25.200
            can be used to manage business commitments and service level agreement operations,

            01:10:25.200 --> 01:10:30.160
            such as mission critical services. Security tags can be used for classifying data and

            01:10:30.160 --> 01:10:35.760
            assessing security impact, helping you manage your security posture. Other helpful ways include

            01:10:35.760 --> 01:10:42.000
            governance and regulatory compliance, automation and workload optimization. All in all, tags provide

            01:10:42.000 --> 01:10:46.800
            a flexible, customizable method for managing your Azure resources according to your specific needs.

            01:10:46.800 --> 01:10:56.480
            The next topic we'll be covering are resource locks. Resource locks are a critical feature

            01:10:56.480 --> 01:11:01.520
            in Azure that helps safeguard important resources from accidental modifications or deletions.

            01:11:01.520 --> 01:11:06.480
            As an admin, you may need to lock a subscription, resource group, or resource to prevent other users

            01:11:06.480 --> 01:11:11.440
            from accidentally deleting or modifying critical resources, especially in environments with multiple

            01:11:11.440 --> 01:11:16.880
            administrators or automated processes. In the Azure portal, you can set the following lock levels.

            01:11:16.880 --> 01:11:22.400
            Cannot delete. This lock ensures authorized users can still read and modify a resource,

            01:11:22.400 --> 01:11:27.680
            but they can't delete the resource. Read only. This lock ensures authorized users can read a

            01:11:27.680 --> 01:11:32.560
            resource, but they can't delete or update the resource. There are a number of ways to manage

            01:11:32.560 --> 01:11:37.360
            locks. Here are some of them. Azure portal, you can easily create, view, and delete locks through

            01:11:37.360 --> 01:11:43.120
            the Azure portal. Azure PowerShell, use CMDlets like new as resource lock to manage locks.

            01:11:43.120 --> 01:11:48.640
            Azure CLI, commands like as lock create help manage locks. Azure Resource Manager templates,

            01:11:48.640 --> 01:11:50.880
            you could also define locks in your ARM templates.

            01:11:56.240 --> 01:12:01.280
            Hey, this is Andrew Brown from exam Pro, and in this section, we'll be covering Azure Blueprints.

            01:12:01.280 --> 01:12:06.080
            Azure Blueprints enable quick creation of governed subscriptions. The key term here is governed.

            01:12:06.080 --> 01:12:10.320
            While one can easily create a subscription in their account, a governed subscription indicates

            01:12:10.320 --> 01:12:14.640
            there's a process and set expectations for how the subscription should be configured.

            01:12:14.640 --> 01:12:19.040
            Azure Blueprints allow you to compose artifacts based on common patterns or those specific to

            01:12:19.040 --> 01:12:23.360
            an organization into reusable blueprints. The service is designed to help with environment

            01:12:23.360 --> 01:12:28.480
            setup. The service is designed to help with environment setup. Blueprints are a declarative

            01:12:28.480 --> 01:12:32.480
            way to orchestrate the deployment of various resource templates and other artifacts such as

            01:12:32.480 --> 01:12:39.600
            role assignments, policy assignments, Azure Resource Manager templates, resource groups.

            01:12:39.600 --> 01:12:43.840
            Azure Blueprint service is powered by the globally distributed Azure Cosmos DB,

            01:12:43.840 --> 01:12:48.400
            ensuring blueprint objects are replicated across multiple regions, providing redundancy and

            01:12:48.400 --> 01:12:53.600
            resilience. A common query is the difference between an ARM template and an Azure Blueprint.

            01:12:53.600 --> 01:12:58.000
            Nearly everything that you want to include for deployment in Azure Blueprints can be accomplished

            01:12:58.000 --> 01:13:03.200
            with an ARM template. With ARM templates, you can store them either locally or in source control.

            01:13:03.200 --> 01:13:07.600
            There isn't an active connection or relationship to the ARM template post-deployment.

            01:13:07.600 --> 01:13:12.240
            On the other hand, Azure Blueprints maintain a connection between the blueprint definition,

            01:13:12.240 --> 01:13:16.000
            what should be deployed, and the blueprint assignment, what has been deployed.

            01:13:16.000 --> 01:13:19.600
            Azure Blueprints could upgrade multiple subscriptions simultaneously if they're

            01:13:19.600 --> 01:13:23.920
            governed by the same blueprint. This means Azure Blueprint supports improved tracking

            01:13:23.920 --> 01:13:27.920
            and auditing of deployments. So that's an overview of Azure Blueprints.

            01:13:27.920 --> 01:13:37.440
            Hey, this is Andrew Brown from exam Pro. And what we're going to be doing is moving resources from

            01:13:37.440 --> 01:13:42.000
            one resource group to another and understanding the limitations around that. So I just have this

            01:13:42.000 --> 01:13:46.480
            page pulled up here, because I just want to emphasize that I've seen exam questions on this

            01:13:46.480 --> 01:13:52.080
            stuff. And there's a lot of little nitty gritty things that could show up as a solution. So the

            01:13:52.080 --> 01:13:56.960
            idea is that when you're talking about moving resources, you know, you're moving them into

            01:13:56.960 --> 01:14:00.480
            different regions or two different subscriptions or different resource groups. And generally,

            01:14:00.480 --> 01:14:06.000
            they're pretty straightforward. But there are some edge cases where things will not work as expected.

            01:14:06.000 --> 01:14:12.800
            And that's based on some particular services. So when we're looking at app services, DevOps services,

            01:14:12.800 --> 01:14:16.880
            classic deployment, network movement, guidance, recovery services, virtual machines,

            01:14:16.880 --> 01:14:22.240
            so I definitely know that for app services, you're going to run into issues. Like if you're moving

            01:14:22.240 --> 01:14:28.240
            from one subscription to another, and you already have a web app service in the one that you're

            01:14:28.240 --> 01:14:32.960
            moving it into, it won't allow you to do it. And so there's a lot of little things like that, okay.

            01:14:34.480 --> 01:14:40.240
            And also, if you are migrating them, you can go ahead and use the diagnostic tool to debug it.

            01:14:40.240 --> 01:14:45.520
            And it will tell you some additional information. So you will have to read through all of these,

            01:14:45.520 --> 01:14:51.280
            I just can't show you all that in a follow along. But what we'll do is we'll just go through the

            01:14:51.280 --> 01:14:56.080
            basics here of moving things between resource groups. And so what we'll need is a few resource

            01:14:56.080 --> 01:15:02.560
            groups, I'm going to add a new one. And we're going to call this one, the USS fed or the Federation

            01:15:02.560 --> 01:15:13.040
            planets. And we'll put that in East us. And then we will make another resource group,

            01:15:13.040 --> 01:15:22.320
            we'll call this the Klingon Empire. And for fun, we will place it in West.

            01:15:22.320 --> 01:15:31.360
            So we'll go ahead and create that. So now we just need something we can move around back and forth.

            01:15:31.360 --> 01:15:36.080
            So what I'm going to do is I'm going to make my way over to disk, because that's a great example

            01:15:36.080 --> 01:15:42.000
            of something we can move around and change. And so I'm going to add a new disk. And I'm going to

            01:15:42.000 --> 01:15:53.360
            place this in the Federation. And I'm just going to say, dilithium. I can never spell that right.

            01:15:53.360 --> 01:15:59.680
            Let's see if I can get the proper spelling for this thing that is not real dilithium here.

            01:16:01.120 --> 01:16:05.200
            And so it's going to be over here, I don't care about availability zones and stuff like that

            01:16:05.200 --> 01:16:12.000
            source type, this is fine. And so we have the initial size, I do not need to drive that big,

            01:16:12.000 --> 01:16:17.040
            let's go super small. We could even do an HDD, because those are even cheaper.

            01:16:17.040 --> 01:16:24.640
            And we'll just use the small size down here. And so we'll pick 32.

            01:16:27.360 --> 01:16:31.440
            And so this should be all final encryption networking, we don't really care, we're not

            01:16:31.440 --> 01:16:34.640
            doing anything other than moving this around. So we'll go ahead and review and create.

            01:16:34.640 --> 01:16:38.480
            Right. And so then we'll go create that resource.

            01:16:38.480 --> 01:16:44.160
            And we'll just wait a little while here, it shouldn't take too long.

            01:16:44.160 --> 01:16:51.520
            Alright, so the disk is ready. So we'll go to this resource. And here it is. So now let's say

            01:16:51.520 --> 01:16:57.360
            we want to move that to our other resource group, which is in another region, what we're going to do

            01:16:57.360 --> 01:17:00.640
            is we're going to go back to our resource groups

            01:17:00.640 --> 01:17:11.280
            here. And if we go into the Federation of planets, what we can do is go to overview,

            01:17:11.280 --> 01:17:16.960
            select the disk, go over here and say move to another resource group. And I'll just click these

            01:17:16.960 --> 01:17:22.160
            other ones to show you I don't have any other subscriptions to move this to. So I'll just go

            01:17:22.160 --> 01:17:25.200
            back there, I thought maybe I could show you some stuff, but I just realized I don't have much in

            01:17:25.200 --> 01:17:31.200
            this account, or with other subscriptions. So we'll just go back to overview here and just move

            01:17:31.200 --> 01:17:35.680
            it to another resource group. And technically, we're moving it to another region. So we'll see

            01:17:35.680 --> 01:17:44.080
            how that goes. And so we will select the Klingon Empire, I understand that the tools and scripts

            01:17:44.080 --> 01:17:48.000
            associated with the move will not work, etc, etc. So we'll hit OK.

            01:17:48.000 --> 01:17:58.560
            And that's going to take a little bit of time to move. So while that is going, I'm going to make a

            01:17:58.560 --> 01:18:02.880
            new tab so we don't lose that history there. And I just want to talk about some settings you can put

            01:18:02.880 --> 01:18:09.040
            on your resource groups. So if we go into the Klingon Empire, and we go down below here, we

            01:18:09.040 --> 01:18:14.480
            should have the ability to apply locks. And there are a few different types of locks, we have read

            01:18:14.480 --> 01:18:20.880
            only and delete. So read only means it's a read only resource. And delete means we cannot delete

            01:18:20.880 --> 01:18:25.280
            the resource, which makes sense, right? So read only should mean we shouldn't be able to modify

            01:18:25.280 --> 01:18:35.360
            this. So I'm going to say, don't touch, do not touch. And I say, Okay, here. And so what that

            01:18:35.360 --> 01:18:41.440
            means is that I should not be able to modify the resource, whether I can delete it or not is

            01:18:41.440 --> 01:18:46.400
            another story, we'll find that out. And another question is, can I move that resource outside of

            01:18:46.400 --> 01:18:51.200
            this if it's set to those modes? And that's what we're going to find out. So moving back over here,

            01:18:51.200 --> 01:18:56.160
            has this finished moving, it's still validating. So we're gonna have to wait a little bit here.

            01:18:56.160 --> 01:19:00.480
            And I'll see you back in a moment. Alright, so after waiting a little while here, I believe that

            01:19:00.480 --> 01:19:05.680
            it's done moving. So I'm still in my old resource group here, we'll do is click back into here,

            01:19:05.680 --> 01:19:10.640
            go to overview, and we see that it's no longer there. But if we go over to the Klingon Empire,

            01:19:10.640 --> 01:19:16.400
            we go back over, just click into overview. There it is. So we had no problems moving a disk to

            01:19:16.400 --> 01:19:23.280
            another region and another resource group. Now we did apply this lock over here. So what is going

            01:19:23.280 --> 01:19:29.680
            to happen when we try to modify this disk? I think you know the answer. But let's give it a go just

            01:19:29.680 --> 01:19:36.800
            to see what happens. So over here, we're going to want to resize it here. I'm going to pick 64,

            01:19:36.800 --> 01:19:42.080
            I'm going to go ahead, resize, and it says fail to update the disk. Because of that reason. So

            01:19:42.080 --> 01:19:48.080
            you cannot perform a right operation because of the lock. So there you go. Now let's go back.

            01:19:48.080 --> 01:19:54.880
            And we are going to go apply another lock here. This time, I'm going to make it so you can't

            01:19:54.880 --> 01:20:04.720
            delete it. And so we say don't do not delete me. All right. And so what we'll do is we'll go back

            01:20:04.720 --> 01:20:11.440
            and we'll try to delete it. So we'll hit the Delete button, we'll say yes. Again, it says

            01:20:11.440 --> 01:20:16.880
            you cannot do it. Now here's the next question, can you move that resource out or in to resource

            01:20:16.880 --> 01:20:24.560
            group if it has lock or read only on? And that's what I want you to guess whether you can or not,

            01:20:24.560 --> 01:20:28.320
            because you're in read only. So would you be able to move something that's read only.

            01:20:28.320 --> 01:20:32.880
            So we'll go ahead and move it, we're going to move this to another resource group. And I'm

            01:20:32.880 --> 01:20:38.000
            going to send it back to the Federation of planets. I say I understand hit OK.

            01:20:38.000 --> 01:20:44.000
            And it failed to check, we'll see why cannot perform the right operation. Because there are

            01:20:44.000 --> 01:20:48.640
            locks, please remove some of the locks. So which is it? Is it delete? Is it the read only do I have

            01:20:48.640 --> 01:20:54.720
            to remove both? So we need to go find out. So back in our resource group, I'm going to go ahead and

            01:20:54.720 --> 01:21:00.880
            first remove pair resource locks can't be edited here. Okay, that's fine. So we'll go back to here.

            01:21:00.880 --> 01:21:06.240
            And we will go into the locks. And we'll first delete the read only.

            01:21:06.240 --> 01:21:15.440
            And then what we'll do is we will attempt to delete this again.

            01:21:17.440 --> 01:21:24.240
            See what happens. It looks like it's moving. So it's not that you can't move it out. If it's in

            01:21:24.240 --> 01:21:29.120
            read only, or sorry, in delete, but you can't if it's read only because it's read only right.

            01:21:29.120 --> 01:21:33.760
            Now when we're talking about moving resources into a group that's set to read only, I'm almost

            01:21:33.760 --> 01:21:40.080
            certain that you can absolutely do that. So we could stage that, I guess, just to make sure.

            01:21:40.080 --> 01:21:47.040
            So what I'm going to do is I'm just going to set up a another resource group, just to make sure

            01:21:47.040 --> 01:21:53.120
            that we know this for certain, just in case I'm wrong, the star, the Romulan Star Empire,

            01:21:53.120 --> 01:21:59.520
            Romulan Star Empire, and I'm going to just leave it in the same region.

            01:21:59.520 --> 01:22:06.960
            And so for this one in particular, what I'm going to do is apply a read only, I might as well just

            01:22:06.960 --> 01:22:12.000
            put both on here, but I'll just add, I'm just going to do read only. And we'll say do not delete me.

            01:22:13.840 --> 01:22:16.800
            And then what I'll do is I'll go back to the Federation planets.

            01:22:16.800 --> 01:22:22.160
            And I'm just going to actually I'll just go to discs and we'll create a new disc here.

            01:22:22.160 --> 01:22:37.680
            And we will place it in the Federation here. And we will just say, dark matter, or anti matter.

            01:22:41.040 --> 01:22:48.320
            And we will just change this to HHD as small as we can go, we'll review and create that. And we'll

            01:22:48.320 --> 01:22:54.640
            go ahead and create that. And this will not take long, we do not have to wait that long for this.

            01:22:54.640 --> 01:22:59.520
            And notice here that

            01:22:59.520 --> 01:23:06.880
            we could not, this is interesting. So there was an error moving the resource moving resources

            01:23:06.880 --> 01:23:11.520
            failed because research group Federation has active deployment. So if you are moving stuff,

            01:23:11.520 --> 01:23:16.800
            and then you do deploy, it's going to cancel that deploy. So that's interesting to know.

            01:23:16.800 --> 01:23:25.920
            So I believe that this new one is deployed, I cannot remember, I think we set this one to

            01:23:25.920 --> 01:23:34.480
            have read only here on the what do you call it the Romulan star Empire, which isn't showing up,

            01:23:34.480 --> 01:23:40.640
            there it is. Just double check there. So the question is, can I move a resource into a read

            01:23:40.640 --> 01:23:49.040
            only? We'll go here. And I guess we need to actually go to the Federation of planets.

            01:23:49.040 --> 01:23:54.960
            Who would overview we have anti matter, and I want to move that

            01:23:57.440 --> 01:24:06.480
            into Romulan star Empire. See, I understand. It'll either say we can or we can't. And we absolutely

            01:24:06.480 --> 01:24:11.040
            can't otherwise it would air it out at this point. So hopefully you can keep that straight. So you

            01:24:11.040 --> 01:24:17.680
            can move a resource into a group that has read only, you cannot move it out. If it's set, you

            01:24:17.680 --> 01:24:22.160
            can absolutely move it out. If it's set to delete, delete just protects against delete. If you're

            01:24:22.160 --> 01:24:27.200
            moving a resource from one resource group to another, and then you deploy something, it's going

            01:24:27.200 --> 01:24:35.280
            to cause that movement to fail. And then there's those edge cases for moving resources with Azure.

            01:24:35.280 --> 01:24:40.320
            And that's something you should spend some time reading up on those use cases, or maybe we all

            01:24:40.320 --> 01:24:45.120
            just pick out the most important ones and put it into a cheat sheet. All right. And so what I'm

            01:24:45.120 --> 01:24:53.280
            going to do is just go ahead and clean this stuff up. So what I'm need to do here is go and remove

            01:24:53.280 --> 01:25:00.800
            the delete, I think it's only on here. So we go to my locks. I'm going to go back to resource groups

            01:25:00.800 --> 01:25:12.800
            here. And we will delete the locks here. And so now I can go ahead and delete these

            01:25:12.800 --> 01:25:24.480
            groups, I guess I have to do them one by one, which is kind of annoying, but that's just how it goes.

            01:25:24.960 --> 01:25:41.360
            And it says it's locked, it's not locked anymore. Oh, it's still there. Look at that. Okay.

            01:25:46.320 --> 01:25:50.800
            Go to swore, I definitely did something there. There we go.

            01:25:50.800 --> 01:25:55.600
            And we will go ahead and delete the last one.

            01:25:55.600 --> 01:26:02.720
            There we are. So yeah, hopefully, you know a bit more about moving resources around.

            01:26:02.720 --> 01:26:11.680
            Hey, this is Andrew Brown from exam Pro. And in this segment, we'll be diving into arm templates.

            01:26:12.240 --> 01:26:17.040
            So what exactly is infrastructure as code, infrastructure as code is the process of

            01:26:17.040 --> 01:26:21.680
            managing and provisioning computer data centers, such as those in Azure using machine readable

            01:26:21.680 --> 01:26:26.720
            definition files like JSON files, rather than depending on physical hardware configuration,

            01:26:26.720 --> 01:26:31.680
            or interactive configuration tools, you write a script that will set up cloud services for you.

            01:26:31.680 --> 01:26:37.680
            There are two main approaches to IAC declarative here, you describe your desired outcome,

            01:26:37.680 --> 01:26:43.200
            and the system figures out how to achieve it. imperative. Here, you provide specific instructions

            01:26:43.200 --> 01:26:48.800
            detailing exactly how to reach the desired state. arm templates are JSON files that define Azure

            01:26:48.800 --> 01:26:53.760
            resources you want to provision and Azure services you want to configure. With arm templates, you can

            01:26:53.760 --> 01:26:59.040
            ensure a declarative approach, meaning you merely define your intended setup and the system handles

            01:26:59.040 --> 01:27:04.720
            the rest, build, remove or share entire architectures in minutes, reduce configuration

            01:27:04.720 --> 01:27:09.840
            mistakes, and know exactly what you have defined for a stack to establish an architecture baseline

            01:27:09.840 --> 01:27:16.080
            for compliance. Moreover, arm templates empower you to establish an architecture baseline for

            01:27:16.080 --> 01:27:21.520
            compliance, achieve modularity, break up your architecture in multiple files and reuse them.

            01:27:21.520 --> 01:27:26.720
            Ensure extensibility add PowerShell and bash scripts to your templates. Test using the arm

            01:27:26.720 --> 01:27:31.920
            template toolkit. Preview changes before you create infrastructure via template, see what it will

            01:27:31.920 --> 01:27:37.840
            create. Built in validation will only deploy your template if it passes. Track deployments, keep

            01:27:37.840 --> 01:27:43.760
            track of changes to architecture over time. Policy as code, apply Azure policies to ensure you remain

            01:27:43.760 --> 01:27:48.800
            compliant. Use Microsoft blueprints which forge a connection between a resource and its template.

            01:27:48.800 --> 01:27:55.440
            Integrate with CI/CD pipelines. Utilize exportable code, letting you capture the current state of

            01:27:55.440 --> 01:28:00.400
            resource groups and individual resources. And benefit from advanced authoring tools,

            01:28:00.400 --> 01:28:04.720
            for instance, Visual Studio Code offers sophisticated features tailored for crafting

            01:28:04.720 --> 01:28:09.280
            arm templates. So as you can see, arm templates has quite a lot of uses.

            01:28:09.280 --> 01:28:18.800
            All right, moving forward, let's delve into the structure or the skeleton of arm templates.

            01:28:18.800 --> 01:28:23.760
            Skeleton is a term used to describe the basic framework or structure of an arm template.

            01:28:23.760 --> 01:28:27.680
            Think of it as the blueprint that guides how an arm template should be organized and what elements

            01:28:27.680 --> 01:28:32.480
            it should contain. Schema, this describes the properties that are available within a template.

            01:28:32.480 --> 01:28:37.680
            Content version, this denotes the version of your template. You can provide any value for this

            01:28:37.680 --> 01:28:43.920
            element. API profile, use this value to avoid having to specify API versions for each resource

            01:28:43.920 --> 01:28:48.720
            in the template. Parameters, these are the dynamic values you feed into your template when you're

            01:28:48.720 --> 01:28:53.200
            deploying or updating resources. It offers flexibility, enabling you to use the same

            01:28:53.200 --> 01:28:58.640
            template in different scenarios or environments just by changing the parameter values. Variables,

            01:28:58.640 --> 01:29:03.200
            this is where you can process or transform the parameters or resource properties. By using

            01:29:03.200 --> 01:29:07.600
            function expressions, you can manipulate input values, making your template more dynamic and

            01:29:07.600 --> 01:29:13.200
            adaptable. Functions, within the arm template, you can define user specific functions. This

            01:29:13.200 --> 01:29:17.520
            allows for reusable custom logic, reducing redundancy and simplifying the template.

            01:29:17.520 --> 01:29:22.640
            Resources, here you list out all the Azure resources you intend to deploy or update.

            01:29:22.640 --> 01:29:26.320
            It defines what your infrastructure looks like and how each component is configured.

            01:29:26.320 --> 01:29:32.000
            Outputs, after a successful deployment, you might want to retrieve specific values or results.

            01:29:32.000 --> 01:29:36.240
            The output section is where you define these values, be it the IP address of a newly created

            01:29:36.240 --> 01:29:41.600
            VM or the URL of a web app. Overall, an arm template skeleton provides a structured and

            01:29:41.600 --> 01:29:45.120
            consistent approach to define, deploy and manage Azure resources.

            01:29:50.720 --> 01:29:54.480
            Moving forward, let's discuss one of the pivotal components of the arm template,

            01:29:54.480 --> 01:30:00.000
            the resources. Resource, this represents any Azure component or service you wish to provision.

            01:30:00.000 --> 01:30:04.000
            It could be a virtual machine, a database or a network interface, etc.

            01:30:04.000 --> 01:30:09.040
            Type, this defines the kind of resource you're provisioning. This typically follows the format

            01:30:09.040 --> 01:30:13.840
            of resource provider slash resource type. For instance, if you're looking to create a storage

            01:30:13.840 --> 01:30:19.920
            account, you'd use the type Microsoft dot storage slash storage accounts. API version,

            01:30:19.920 --> 01:30:24.800
            each resource type corresponds to an API version, which is essentially the version of the rest API

            01:30:24.800 --> 01:30:29.280
            used for that particular resource. It's important to note that each resource provider published has

            01:30:29.280 --> 01:30:33.840
            its own API versions, so you need to ensure you're using the correct one for your chosen resource.

            01:30:33.840 --> 01:30:39.520
            Name, this attribute specifies the unique name of the resource. For example, if you're setting up a

            01:30:39.520 --> 01:30:44.960
            virtual machine, this could be my virtual machine. Location, this is a common attribute for most

            01:30:44.960 --> 01:30:49.840
            resources. It determines the Azure region where your resource will be deployed, such as ECUS or

            01:30:49.840 --> 01:30:55.280
            West Europe. Other properties beyond the basic attributes, each resource type has its own set

            01:30:55.280 --> 01:31:00.080
            of properties that allow for deeper configuration. These properties can vary widely depending on the

            01:31:00.080 --> 01:31:04.880
            resource. For a virtual machine, it could be the size or the operating system. For a database,

            01:31:04.880 --> 01:31:14.880
            it might be the capacity or replication settings. In this segment, we'll delve into a fundamental

            01:31:14.880 --> 01:31:20.240
            component of ARM templates, the parameters. Parameters play a critical role in ARM templates.

            01:31:20.240 --> 01:31:24.320
            They allow you to pass specific values into your template, thus allowing you to create more

            01:31:24.320 --> 01:31:30.160
            flexible and dynamic infrastructure configurations. Defining a parameter, as shown in the example,

            01:31:30.160 --> 01:31:34.640
            to define a parameter named storage name. It's of type string with a minimum length of five

            01:31:34.640 --> 01:31:39.760
            characters and a maximum length of 20 characters. Once you've defined a parameter, you can then

            01:31:39.760 --> 01:31:44.720
            reference it in various parts of your template, such as type, API version, name, and so forth.

            01:31:44.720 --> 01:31:50.320
            Type dictates the expected data type for the input value. Common types include string,

            01:31:50.320 --> 01:31:57.120
            secure a string, and bool object, secure object, and array. Default value, if no value is provided,

            01:31:57.120 --> 01:32:03.520
            it will be set to default value. Allowed values, this is an array of allowed values. Min value,

            01:32:03.520 --> 01:32:10.400
            the minimal possible value. Max value, the maximum possible value. Min length, the maximum

            01:32:10.400 --> 01:32:17.040
            length of characters or array. Max length, the maximum length of characters or array. Description,

            01:32:17.040 --> 01:32:21.040
            the description that will be displayed to the in the Azure portal. In summary,

            01:32:21.040 --> 01:32:24.160
            parameters are the gatekeepers of customization in ARM templates.

            01:32:29.600 --> 01:32:34.640
            The next topic we'll be covering are the ARM template functions. Functions in ARM templates

            01:32:34.640 --> 01:32:39.040
            are powerful tools that allow you to transform and manipulate your ARM variables. Think of them

            01:32:39.040 --> 01:32:43.120
            as the building blocks that enable you to create more dynamic and flexible configurations.

            01:32:43.120 --> 01:32:48.160
            Template functions, these are built in functions provided by Azure for a wide range of common

            01:32:48.160 --> 01:32:53.280
            tasks. User defined functions, these are custom functions you can create to cater to specific

            01:32:53.280 --> 01:32:57.520
            needs that aren't addressed by the built in template functions. Functions are called using

            01:32:57.520 --> 01:33:04.560
            parentheses eg, such as the example shown here. Categories of template functions. Array functions,

            01:33:04.560 --> 01:33:10.320
            tools for handling arrays, some of these include array concat, contains, create array, empty,

            01:33:10.320 --> 01:33:17.040
            first, etc. Comparison functions for equating or contrasting values. Coalesce equals, less,

            01:33:17.040 --> 01:33:22.960
            lesser equals, greater and greater or equals. Date functions to manipulate date and time. Date,

            01:33:22.960 --> 01:33:28.720
            time, add, UTC now. Deployment functions pertaining to the deployment itself. Deployment

            01:33:28.720 --> 01:33:36.240
            environment parameters and variables. Logical functions for logical operations. And or if not,

            01:33:36.240 --> 01:33:42.400
            numeric functions, mathematical and numeric operations. Add, copy, index, div, float, int,

            01:33:42.400 --> 01:33:49.040
            min, max, etc. Object functions for object manipulation. Contains, empty, intersection,

            01:33:49.040 --> 01:33:55.520
            JSON, length and union. Resource functions related to Azure resources. Extension resource ID,

            01:33:55.520 --> 01:34:01.360
            list account, SAS, list keys, list secrets, etc. String functions for string manipulation and

            01:34:01.360 --> 01:34:09.520
            evaluation. Base 64, base 64 to JSON, base 64 to string concat, contains, etc. We won't go over

            01:34:09.520 --> 01:34:13.040
            all of them. But this is just to show you that there are a lot of functions available to you.

            01:34:18.400 --> 01:34:23.840
            The next topic we'll cover are the ARM template variables. Template variables are used to simplify

            01:34:23.840 --> 01:34:28.560
            your ARM templates. You transform parameters and resource properties using functions and then

            01:34:28.560 --> 01:34:33.680
            assign them into a reusable variable. In this example, the storage name variable is computed

            01:34:33.680 --> 01:34:37.680
            by combining a parameter named storage name prefix with a unique string derived from the

            01:34:37.680 --> 01:34:43.840
            resource groups ID. To call a variable, you use the variable function as shown in this example.

            01:34:45.280 --> 01:34:48.960
            Sometimes your templates might become more intricate and you may need a hierarchical

            01:34:48.960 --> 01:34:54.160
            structure to your variables. That's where nested variables come in. You can use JSON

            01:34:54.160 --> 01:34:57.920
            object to have nested variables to scope your variables for multiple use cases.

            01:34:57.920 --> 01:35:03.680
            Scoping, nesting variables based on environment. Consider scenarios where you have configurations

            01:35:03.680 --> 01:35:08.480
            that vary based on the environment, like test or prod. You might want to neatly encapsulate

            01:35:08.480 --> 01:35:14.160
            variables specific to each environment within a JSON object as shown in the example. You can

            01:35:14.160 --> 01:35:19.440
            use parameters to choose the environment and then reference nested variables as followed in the

            01:35:19.440 --> 01:35:26.400
            example variables parentheses square brackets dot property. Overall, variables and ARM templates are

            01:35:26.400 --> 01:35:31.360
            powerful tools that can simplify your template, make it more adaptable and improve its maintainability.

            01:35:31.360 --> 01:35:40.720
            The ARM templates aren't just about defining and provisioning resources. They also offer a way to

            01:35:40.720 --> 01:35:45.120
            fetch information about the deployed resources. This is where the output section of your ARM

            01:35:45.120 --> 01:35:50.560
            templates comes into play. Outputs returns values from deployed resources so you can use them

            01:35:50.560 --> 01:35:55.440
            programmatically. For example, you might want to know the static IP of a created VM or the

            01:35:55.440 --> 01:36:01.280
            connection string of a deployed database. You specify the type and value under outputs. Here,

            01:36:01.280 --> 01:36:06.160
            the output name resources is capturing the ID of a public IP address resource. It's noteworthy that

            01:36:06.160 --> 01:36:11.520
            the type is explicitly mentioned ensuring type safety. Once your resources are deployed, these

            01:36:11.520 --> 01:36:18.160
            outputs can be fetched using Azure CLI PowerShell or the Azure SDKs. For instance, with Azure CLI,

            01:36:18.160 --> 01:36:22.720
            this command retrieves the resource at output value from a specific deployment in a resource group.

            01:36:22.720 --> 01:36:26.240
            So that's a quick overview of outputs in ARM templates.

            01:36:26.240 --> 01:36:35.760
            Hey, this is Andrew Brown from exam Pro. And we're looking at Azure Resource Manager templates,

            01:36:35.760 --> 01:36:40.880
            also known as ARM templates. And this helps you deliver infrastructure as code, meaning that

            01:36:40.880 --> 01:36:44.960
            when you have a resource such as a virtual machine or a storage account, instead of manually

            01:36:44.960 --> 01:36:50.640
            configuring it every single time through the portal, what you can do is provide a configuration

            01:36:50.640 --> 01:36:55.200
            file that defines all the properties that you want it to be configured with. And the idea is that you

            01:36:55.200 --> 01:37:01.360
            can keep this file and share with other other people so they can easily create the same resources

            01:37:01.360 --> 01:37:07.280
            as you. And then you know exactly how your stuff is is configured. So what we're going to do is

            01:37:07.280 --> 01:37:13.840
            launch a new template. Now you can't go up here and just type in arm, because these arm templates

            01:37:13.840 --> 01:37:18.640
            are managed at different levels. So at one level is a script subscription or their resource groups.

            01:37:18.640 --> 01:37:22.080
            So when you have a resource group, you have deployments within them. And that's where

            01:37:22.080 --> 01:37:27.120
            these templates are deployed. But just to deploy one from here, what we're going to do is type in

            01:37:27.120 --> 01:37:31.760
            deploy why they didn't make it so you can type in arm, I do not know. But if you go down here,

            01:37:31.760 --> 01:37:37.040
            we have deploy a custom template. And so from here, we have some common templates. So if I click into

            01:37:37.040 --> 01:37:41.760
            web app, and I go edit a template, we already have some stuff pre filled in, I'm just going to go

            01:37:41.760 --> 01:37:46.400
            back and discard that go back to select a template. And we're going to build our own. And by default,

            01:37:46.400 --> 01:37:52.400
            we'll have that schema that content version, which is 1.0 point 0.0, our parameters and our resources.

            01:37:52.400 --> 01:37:57.760
            So today, I want to launch a virtual machine. And what you normally would have to do is go here

            01:37:57.760 --> 01:38:02.960
            and look up what is that you want to create. So if it's this Microsoft Compute virtual machine,

            01:38:02.960 --> 01:38:08.480
            you'd go through here, and you'd have to make sure you have all these properties. So you define

            01:38:08.480 --> 01:38:14.480
            the resource here, right, the type. And then you define the properties that you want. And down

            01:38:14.480 --> 01:38:18.880
            below, you can go through here and see them all. That's a lot of work. I don't want to do that. So

            01:38:18.880 --> 01:38:24.800
            I'll go to add resource here, drop this down and click. Where's that virtual machine? Where are

            01:38:24.800 --> 01:38:30.400
            you? There you are. And I'm going to call this one warf. And then warf and warf, because it's

            01:38:30.400 --> 01:38:34.480
            not just going to create a virtual machine, it's going to create other things that I need with it

            01:38:34.480 --> 01:38:40.480
            as well, such as the storage account, the network interface, and the virtual network. So you can see

            01:38:40.480 --> 01:38:46.320
            that we have a bunch of parameters here. So the name of the type, the name, the admin username,

            01:38:46.320 --> 01:38:52.080
            the password and the OS version. Oh, you know what, I think I chose a Windows one, I do not

            01:38:52.080 --> 01:38:57.120
            want a Windows one, I want a Linux one. Because that is easier for me to work with here. So we

            01:38:57.120 --> 01:39:05.920
            choose Ubuntu. So I'll just fill this in again. All right. And so back up here, you know, we have

            01:39:05.920 --> 01:39:11.600
            the Ubuntu version between some versions here. And then there's the type. So that's for replication,

            01:39:11.600 --> 01:39:16.400
            then we have variables here. So if we go to VM size, this is the VM, it will it will set here,

            01:39:16.400 --> 01:39:22.400
            variables are either you can have string values, or you can use functions to transform other

            01:39:22.400 --> 01:39:27.520
            parameters into other stuff that you'll reference throughout your template, then down below,

            01:39:27.520 --> 01:39:34.000
            we have those resources here. So what we'll do is, actually, I'm going to copy this, because it's

            01:39:34.000 --> 01:39:38.080
            very highly likely we're going to want to make some kind of change. And so I have VS code over

            01:39:38.080 --> 01:39:43.360
            here on the on the left or right hand side, I'm just going to paste that on in there. And what we

            01:39:43.360 --> 01:39:50.000
            will do, this is a JSON file, make things a little bit easier here. Great. And what I'll do is just

            01:39:50.000 --> 01:39:55.280
            move that off screen. And we'll go ahead, and we will save this. And we'll see if we can deploy

            01:39:55.280 --> 01:40:02.800
            this. So I'm going to type in warfare, and we'll launch in Canada, East, I'll name this wharf,

            01:40:02.800 --> 01:40:09.360
            we will name the username warf, but lowercase, and then we'll do testing 123456. Capital on the T,

            01:40:09.360 --> 01:40:16.320
            notice that it is hidden there. And then we will choose 14, which is defaulted here and LRS,

            01:40:16.320 --> 01:40:23.360
            we'll go ahead and do review and create. And we'll hit Create here. So this is going to fail,

            01:40:23.360 --> 01:40:28.160
            I already know because it has a misconfiguration, it'll tell us how, but while that's going,

            01:40:28.160 --> 01:40:32.800
            we'll take a look at our input. So this is the values that were inputted. These are the outputs,

            01:40:32.800 --> 01:40:38.320
            if we had defined any, which we have not. And if we go back to our template, I just wanted to show

            01:40:38.320 --> 01:40:41.920
            you that we have that secure string. So when we were typing our password, that's why we didn't

            01:40:41.920 --> 01:40:49.600
            see it. So just things like that. So I'll go back up here and our deploy failed. Why what happened?

            01:40:49.600 --> 01:40:54.720
            So we open it up here, the requested VM size standard D one is not available in the current

            01:40:54.720 --> 01:41:00.880
            region. So the template we have is not that great. It needs some configuration, because we can't use

            01:41:00.880 --> 01:41:06.560
            D one, I think that doesn't exist anymore. And so what we really want to use is the standard B one

            01:41:06.560 --> 01:41:15.120
            LS. Right? Standard B one LS. So I'm going to cut that. And for the time being, I'm going to go back

            01:41:15.120 --> 01:41:23.520
            to our original template. And this is one big template. I got to look for those variables,

            01:41:23.520 --> 01:41:26.720
            or they're all the way at the bottom here. Nice. And so I'm going to just go ahead and paste that

            01:41:26.720 --> 01:41:36.320
            in. B one LS, just double check, make sure I spelt that right standard. Standard B one LS looks good

            01:41:36.320 --> 01:41:42.240
            to me. So I'm going to move that off screen. And the question is, what do we do? What do we do when

            01:41:42.240 --> 01:41:47.840
            a deploy fails? So let's go take a look at what has happened here. So this all got deployed into

            01:41:47.840 --> 01:41:53.040
            a resource group. And under here, this is where our deployments are. So when we look at this

            01:41:53.040 --> 01:41:59.760
            template, we can see that it failed, we can click into here get the same information. And if we click

            01:41:59.760 --> 01:42:04.400
            into here, it just brings us back to where we just were. But if we go look at what was actually

            01:42:04.400 --> 01:42:10.240
            deployed under our resource group, under the overview, we'll notice that it created the

            01:42:10.240 --> 01:42:14.560
            virtual network, the storage account and the network interface. So when it fails, it creates

            01:42:14.560 --> 01:42:20.320
            what it can, but it doesn't roll back. Okay. So the question is, is then how do you do cleanup?

            01:42:20.320 --> 01:42:25.600
            So you might think I'll go to deployments. And what I'll do is go ahead and delete that template.

            01:42:25.600 --> 01:42:30.400
            And we can go ahead and do that. Which by the way, you can't edit this template, all you can do is

            01:42:30.400 --> 01:42:35.360
            all we can do here, see, I just want to show you that you cannot edit it,

            01:42:35.360 --> 01:42:42.080
            we can download it and stuff like that. But so you might think, well, if I go ahead and delete

            01:42:42.080 --> 01:42:48.720
            that template, just making sure we're in the right place here. You might think that might roll back

            01:42:48.720 --> 01:42:53.440
            those resources, but it doesn't, it just deletes the template. So if you really want to get rid

            01:42:53.440 --> 01:42:58.400
            of this stuff, what you got to do is go ahead and delete all these resources manually.

            01:42:58.400 --> 01:43:04.720
            So I wish I kind of had a rollback feature, but that's just how it is.

            01:43:04.720 --> 01:43:10.160
            But there are some nice things that Azure does here, which we'll talk about in a moment. So

            01:43:10.160 --> 01:43:15.200
            I think we have adjusted it to the correct value now. So hopefully, this is going to be all we need

            01:43:15.200 --> 01:43:22.480
            to make it work. So what we'll do is go to our deployments here. And we can't do it here. But

            01:43:22.480 --> 01:43:28.080
            so we'll go back to the top here and type in deploy. And we'll go to custom template. And

            01:43:28.080 --> 01:43:34.160
            what we'll do is build our own template in our editor. And I'm just going to copy the contents

            01:43:34.160 --> 01:43:46.880
            here. Okay, we'll go copy. And I will go paste. And we will make sure that this is all good looks

            01:43:46.880 --> 01:43:52.880
            fine to me, we'll go ahead and hit save. And we will choose warf. So we don't have to make a new

            01:43:52.880 --> 01:43:59.200
            one. And we will fill in the name as warf. The username is warf. I'll call warf to just in case

            01:44:00.240 --> 01:44:05.280
            helps us keep track of what we're doing here. Testing 123456 with a capital on the T

            01:44:05.280 --> 01:44:14.320
            14. l r ls, lrs. And we'll go ahead l we have one issue here cannot deploy resource group

            01:44:14.320 --> 01:44:27.360
            warf deleting. We'll go back. And we will hit create here. I don't think I deleted the resource

            01:44:27.360 --> 01:44:32.880
            group. Let me just go double check. I almost I'm almost certain I deleted all the contents of it,

            01:44:32.880 --> 01:44:38.000
            right. So there's already one here. So we're just waiting for that to delete.

            01:44:38.000 --> 01:44:42.320
            It's gonna go delete for us, please. Thank you.

            01:44:42.320 --> 01:44:55.680
            It failed to delete. We'll go take a look as to why resources not found.

            01:44:56.480 --> 01:44:58.480
            Mm hmm.

            01:44:58.480 --> 01:45:07.920
            We'll go back to our resource groups. Give us a refresh here.

            01:45:07.920 --> 01:45:13.120
            Okay, so you know what, I must have deleted the resource group, which is totally fine.

            01:45:13.120 --> 01:45:19.120
            I could have sorry, I only delete the contents of it. But we'll just call this warf regular, then

            01:45:19.920 --> 01:45:26.880
            we'll go ahead and hit create here. And so this time, I have better feeling about this.

            01:45:26.880 --> 01:45:39.520
            And so we will just have to wait a little bit. It won't take too long.

            01:45:39.520 --> 01:45:45.520
            I'll see you back in a moment. Okay, so after waiting a little bit here,

            01:45:45.520 --> 01:45:50.400
            our, our thing seems to be deployed. So if we go to resource groups, we can see that our virtual

            01:45:50.400 --> 01:45:55.360
            machine is deployed. So that's pretty much all there is to it. One other thing I'd like to show

            01:45:55.360 --> 01:46:00.160
            you is that whatever you have, whatever is in your resource group, you can actually export the

            01:46:00.160 --> 01:46:04.560
            template. So if you did configure something manually, all you'd have to do is find the

            01:46:04.560 --> 01:46:12.400
            resource, go up here to it is export template. And there's your template. So it just has that

            01:46:12.400 --> 01:46:18.080
            single resource in there. I can't remember if, if I go into here, if I select multiples,

            01:46:18.080 --> 01:46:26.240
            and I go x, or where's it export template. Look, it's going to include all that stuff. So

            01:46:26.240 --> 01:46:31.200
            if you already have existing resources that you provisioned, and you want to have them,

            01:46:31.200 --> 01:46:34.640
            that's what you can do. Notice that some things won't be included in the template when you do

            01:46:34.640 --> 01:46:39.200
            that. But you can just go ahead and download them. And then you have them for later. So

            01:46:39.200 --> 01:46:45.040
            yeah, that's all there really is to arm other than learning the, the nitty gritties of the

            01:46:45.040 --> 01:46:49.680
            actual language. That's just how you work with it there. So what I'm going to do is make my way over

            01:46:49.680 --> 01:47:00.080
            to my resource group here. And I'm just going to go ahead and delete this here. And we're all good

            01:47:00.080 --> 01:47:11.200
            to go. Hey, this is Andrew Brown from exam Pro. And in this section, we'll be covering Azure

            01:47:11.200 --> 01:47:16.720
            Monitor. So as your monitor is a comprehensive solution for collecting, analyzing and acting

            01:47:16.720 --> 01:47:21.120
            on telemetry from your cloud and on premises environments, it serves as the backbone for

            01:47:21.120 --> 01:47:25.440
            gaining insight into the performance and health of your applications, infrastructure, and even

            01:47:25.440 --> 01:47:32.240
            the network. He features visual dashboards, a visual representation of your data, smart alerts,

            01:47:32.240 --> 01:47:37.680
            intelligent notifications based on specific conditions, automated actions, set automation

            01:47:37.680 --> 01:47:43.920
            based on certain triggers, log monitoring, track and analyze event logs. Many Azure services by

            01:47:43.920 --> 01:47:49.840
            default are already sending telemetry data to Azure Monitor. What is observability? It's the

            01:47:49.840 --> 01:47:53.760
            ability to measure and understand how internal systems work in order to answer questions

            01:47:53.760 --> 01:47:59.280
            regarding performance, tolerance, security and faults with a system or application. To obtain

            01:47:59.280 --> 01:48:04.960
            observability, you need to use metrics, logs and traces, you have to use them together using them

            01:48:04.960 --> 01:48:10.320
            in isolation does not gain you observability metrics, a number that is measured over a period

            01:48:10.320 --> 01:48:15.360
            of time. For example, if we measure the CPU usage and aggregated it over a period of time,

            01:48:15.360 --> 01:48:21.120
            we could have an average CPU metric logs, a text file where each line contains event data about

            01:48:21.120 --> 01:48:26.640
            what happened at a certain time, traces a history of requests that travels through multiple apps

            01:48:26.640 --> 01:48:31.200
            or services so we can pinpoint performance or failure. Looks like they should have called it

            01:48:31.200 --> 01:48:36.960
            the Triforce of observability. The sources of common monitoring data to populate data stores

            01:48:36.960 --> 01:48:43.360
            order by highest to lowest application operating system, Azure resources, Azure subscription,

            01:48:43.360 --> 01:48:48.800
            Azure tenant, custom sources. The two fundamental data stores are metrics and logs.

            01:48:49.680 --> 01:48:55.120
            Azure monitor functionalities, insights, this can be for applications, containers,

            01:48:55.120 --> 01:49:01.440
            VMs, or other monitoring solutions. Visualize using dashboards, views, Power BI and workbooks,

            01:49:01.440 --> 01:49:06.400
            you can create rich visual presentations of your data. Analyze this involves delving deep into

            01:49:06.400 --> 01:49:11.680
            metrics, analytics and log analytics. Respond based on data Azure monitor can alert you or

            01:49:11.680 --> 01:49:17.680
            even autoscale resources. Integrate extend the capabilities by using logic apps or export APS

            01:49:17.680 --> 01:49:23.120
            for more flexibility. Overall, Azure monitor is a comprehensive solution vital for ensuring that

            01:49:23.120 --> 01:49:27.680
            your applications and services run optimally and any issues are detected and dealt with properly.

            01:49:27.680 --> 01:49:37.120
            The next topic we'll be covering are the various sources from which Azure monitor collects data.

            01:49:37.120 --> 01:49:42.240
            Application code, Azure monitors, application insights offers robust metrics about the

            01:49:42.240 --> 01:49:46.960
            performance and functionality of your applications and code. You'll get performance traces,

            01:49:46.960 --> 01:49:52.240
            application logs and even user telemetry. You'll need to install instrumentation package in your

            01:49:52.240 --> 01:49:57.360
            application to collect data for application insights. Availability tests measure your

            01:49:57.360 --> 01:50:01.600
            applications responsiveness from different locations on the public internet. This helps

            01:50:01.600 --> 01:50:07.280
            in assessing the reliability and uptime of your services. Metrics descriptive data regarding your

            01:50:07.280 --> 01:50:13.120
            applications performance, operation and custom metrics. Logs store operational data about your

            01:50:13.120 --> 01:50:18.800
            application, including page views, application requests, exceptions and traces. You can send

            01:50:18.800 --> 01:50:24.480
            application data to Azure storage for archiving. View the details of availability test stored

            01:50:24.480 --> 01:50:29.120
            and debug snapshot data that is captured for a subset of exceptions is stored in Azure storage.

            01:50:29.120 --> 01:50:35.600
            Log analytics agent is installed for comprehensive monitoring. Dependency agent collects discovered

            01:50:35.600 --> 01:50:39.920
            data about processes running on the virtual machine and external process dependencies.

            01:50:40.560 --> 01:50:45.680
            Agents can be installed on the OS for VMs running in Azure on premises or other cloud providers.

            01:50:45.680 --> 01:50:50.160
            Diagnostics extension collect performance counters and store them in metrics.

            01:50:50.160 --> 01:50:55.200
            Application insights logs collect logs and performance counters from the compute resources

            01:50:55.200 --> 01:51:00.240
            supporting your application, allowing them to be analyzed alongside other application data.

            01:51:00.240 --> 01:51:05.120
            The Azure diagnostics extension always writes to an Azure storage account while Azure monitor for

            01:51:05.120 --> 01:51:10.160
            VMs uses the log analytics agent to store health state information in a custom location.

            01:51:10.160 --> 01:51:14.640
            The diagnostics extension can also stream data to other locations using event hubs.

            01:51:14.640 --> 01:51:20.400
            Resource logs provide insights into the internal operation of an Azure resource and are automatically

            01:51:20.400 --> 01:51:25.520
            created. However, you must create a diagnostic setting to specify a destination for each resource.

            01:51:25.520 --> 01:51:30.480
            Platform metrics will write to the Azure monitor metrics database with no configuration.

            01:51:30.480 --> 01:51:36.480
            You can access platform metrics from metrics Explorer for trending and other analyzes. Use

            01:51:36.480 --> 01:51:43.360
            log analytics. Copy platform metrics to logs. Send resource logs to Azure storage for archiving.

            01:51:43.360 --> 01:51:46.000
            Stream metrics to other locations using event hubs.

            01:51:46.000 --> 01:51:51.360
            Azure subscription. This includes telemetry related to the health and operation of your

            01:51:51.360 --> 01:51:55.600
            Azure subscription. Azure service health provides information about the health of

            01:51:55.600 --> 01:51:59.760
            the Azure services in your subscription that your application and resources rely on.

            01:51:59.760 --> 01:52:04.720
            Telemetry related to your Azure tenant is collected from tenant wide services such

            01:52:04.720 --> 01:52:09.440
            as Azure Active Directory. Azure Active Directory reporting contains the history

            01:52:09.440 --> 01:52:13.120
            of sign in activity and audit trail of changes made within a particular tenant.

            01:52:13.120 --> 01:52:17.280
            For resources that cannot be monitored using the other data sources,

            01:52:17.280 --> 01:52:20.800
            write this data to either metrics or logs using an Azure monitor API.

            01:52:20.800 --> 01:52:25.120
            This will allow you to collect log data from any rest client and store it in log

            01:52:25.120 --> 01:52:27.520
            analytics in the Azure monitor metrics database.

            01:52:32.720 --> 01:52:36.640
            Azure monitor is integral to maintaining the health and performance of your applications

            01:52:36.640 --> 01:52:40.640
            and resources. Collecting two fundamental types of data, logs and metrics.

            01:52:40.640 --> 01:52:45.360
            Azure monitor logs collects and organizes log in performance data from a variety of

            01:52:45.360 --> 01:52:51.120
            monitored resources. Data consolidation logs can be pulled from diverse sources such as platform

            01:52:51.120 --> 01:52:56.000
            logs from Azure services, log and performance data from agents on virtual machines and usage

            01:52:56.000 --> 01:53:00.720
            and performance data from applications. Workspaces. All these logs are organized

            01:53:00.720 --> 01:53:04.800
            into workspaces, providing a centralized repository for in depth analysis.

            01:53:04.800 --> 01:53:09.920
            Query language. Azure monitor logs offers a sophisticated query language which can

            01:53:09.920 --> 01:53:14.560
            quickly analyze millions of records, making it an ideal choice for complex data analytics.

            01:53:14.560 --> 01:53:19.120
            Log analytics. You can interactively work with log queries and their results using

            01:53:19.120 --> 01:53:24.720
            Azure's log analytics tool. In contrast, Azure monitor metrics collects numeric data and

            01:53:24.720 --> 01:53:30.000
            organizes it into a time series database. Here's why that's important. Numeric data

            01:53:30.000 --> 01:53:34.880
            metrics are numerical values captured at regular intervals. They are a snapshot that describes a

            01:53:34.880 --> 01:53:40.080
            particular aspect of a system at a specific moment in time. Lightweight metrics are designed

            01:53:40.080 --> 01:53:44.640
            to be lightweight, allowing for near real time data analysis. This makes them particularly

            01:53:44.640 --> 01:53:49.840
            useful for alerting and the rapid detection of issues. Metrics Explorer. The metrics explorer

            01:53:49.840 --> 01:53:54.320
            tool allows for interactive analysis of metric data, providing a more immediate understanding

            01:53:54.320 --> 01:54:03.600
            of your system's performance and health. The next topic we'll cover the data retention

            01:54:03.600 --> 01:54:08.800
            and archive policies of Azure monitor logs. This is an important aspect of your monitoring strategy,

            01:54:08.800 --> 01:54:12.320
            as it allows you to control how long your data remains stored and accessible.

            01:54:12.320 --> 01:54:18.320
            By default in the Azure portal, you can set this retention time anywhere from 30 to 730 days for

            01:54:18.320 --> 01:54:23.440
            the whole workspace. If you want, you can also specify different storage durations for certain

            01:54:23.440 --> 01:54:27.200
            tables within your workspace, letting you manage different types of data as needed.

            01:54:27.200 --> 01:54:32.160
            This gives you the flexibility to meet any business or regulatory rules about data storage.

            01:54:32.160 --> 01:54:36.960
            However, note that to tweak these retention settings, you have to be on the paid tier of

            01:54:36.960 --> 01:54:43.680
            Azure monitor logs. To set retention and archive policy by table, why didn't navigate to the Azure

            01:54:43.680 --> 01:54:49.280
            portal and go to the log analytics workspace where the data is stored to under the settings section,

            01:54:49.280 --> 01:54:56.080
            select usage and estimated costs. Three, then select data retention. For in the data retention

            01:54:56.080 --> 01:55:01.440
            blade, you can modify the retention period for each table by default, it is set to 31 days,

            01:55:01.440 --> 01:55:07.920
            but you can extend it up to 730 days. Five, for archiving data, you can use Azure Data Explorer,

            01:55:07.920 --> 01:55:12.240
            which lets you retain data beyond the two year limit and gives you a highly scalable analytic

            01:55:12.240 --> 01:55:17.440
            service. So that's an overview of the data retention and archive policies of Azure monitor

            01:55:17.440 --> 01:55:22.000
            logs. You'll most likely encounter a question related to this on the exam. So be sure to know

            01:55:22.000 --> 01:55:32.320
            this. Hey, this is Andrew Brown from exam Pro. And in this section, we'll be covering Azure log

            01:55:32.320 --> 01:55:38.000
            analytics. So log analytics is a tool in the Azure portal used to edit and run log queries with data

            01:55:38.000 --> 01:55:43.760
            in Azure monitor logs. Log analytics processes data from various sources and transforms it into

            01:55:43.760 --> 01:55:49.680
            actionable insights. It ingests data from Azure monitor Windows and Linux agents, Azure services

            01:55:49.680 --> 01:55:55.200
            and other sources. Once the data is collected, you can use log analytics query language to retrieve,

            01:55:55.200 --> 01:56:02.080
            consolidate and analyze the data. Log analytics uses a query language called KQL. Now we'll go

            01:56:02.080 --> 01:56:07.200
            over some of the benefits of log analytics. centralized log management, collect and analyze

            01:56:07.200 --> 01:56:11.760
            data from multiple sources, both on premises and in the cloud in a centralized location.

            01:56:12.400 --> 01:56:16.880
            Powerful analytics utilize the custom query language to run advanced analytics on large

            01:56:16.880 --> 01:56:22.000
            amounts of fast streaming data in real time. Custom dashboards create custom dashboards

            01:56:22.000 --> 01:56:27.440
            and visualizations to display real time data and trends. integration seamless integration with

            01:56:27.440 --> 01:56:33.440
            other Azure services and Microsoft solutions such as power bi and Azure automation, and alerting

            01:56:33.440 --> 01:56:38.160
            setup alerts based on specific criteria to proactively identify and respond to potential

            01:56:38.160 --> 01:56:43.360
            issues before they affect your users. Log analytics workspace is a unique environment

            01:56:43.360 --> 01:56:48.960
            for Azure monitor log data. Each workspace has its own data repository and configuration and

            01:56:48.960 --> 01:56:53.200
            data sources and solutions are configured to store their data in a particular workspace.

            01:56:53.200 --> 01:56:56.480
            So that's an overview of Azure log analytics.

            01:56:56.480 --> 01:57:06.720
            The log analytics agent is a lightweight agent that can be installed on Windows and Linux machines

            01:57:06.720 --> 01:57:12.160
            to collect and send log data to Azure monitor. It provides a way to centralize logs from various

            01:57:12.160 --> 01:57:17.360
            sources and enables the analysis of the data using tools like Azure monitor logs, Azure dashboards

            01:57:17.360 --> 01:57:23.120
            and Azure monitor workbooks. The agent can collect logs from various sources including Windows event

            01:57:23.120 --> 01:57:29.040
            logs, custom logs, performance counters and syslog. It supports both agent based and ageless

            01:57:29.040 --> 01:57:33.680
            data collection and can be configured to collect data from on premises and cloud based environments.

            01:57:34.640 --> 01:57:39.040
            The log analytics agent is set up to monitor certain Windows event logs like security

            01:57:39.040 --> 01:57:44.320
            system or application logs. The data from these logs is then gathered and sent to log analytics

            01:57:44.320 --> 01:57:49.600
            for analysis using queries and visualizations. The log analytics agent is set up to monitor

            01:57:49.600 --> 01:57:54.720
            syslog servers or network devices. It collects data from these sources and sends it to log

            01:57:54.720 --> 01:57:59.680
            analytics allowing for detailed analysis and troubleshooting. Both methods for collecting

            01:57:59.680 --> 01:58:04.400
            log data allow for centralized management and analysis of log data from multiple sources,

            01:58:04.400 --> 01:58:08.400
            which can help to improve visibility and streamline troubleshooting and issue resolution.

            01:58:08.400 --> 01:58:13.120
            You can expect to see a question related to log analytics agents and choosing either

            01:58:13.120 --> 01:58:17.680
            Windows event logs for a Windows agent or syslog for Linux agent on the exam.

            01:58:17.680 --> 01:58:28.880
            The next topic we'll be covering our application insights. Application insights is an application

            01:58:28.880 --> 01:58:34.000
            performance management service and it's a subservice of Azure monitor. APM is all about

            01:58:34.000 --> 01:58:38.720
            the monitoring and management of performance and availability of software apps. It strives to detect

            01:58:38.720 --> 01:58:43.440
            and diagnose complex application performance problems to maintain an expected level of service.

            01:58:43.440 --> 01:58:49.600
            So why use application insights, automatic detection of performance anomalies, application

            01:58:49.600 --> 01:58:54.800
            insights automatically identifies performance anomalies in your system. Powerful analytics

            01:58:54.800 --> 01:58:59.600
            tools. It comes with robust analytics tools to help you diagnose issues and understand what users do

            01:58:59.600 --> 01:59:04.720
            with your app. Continuous improvement. It is designed to help you continuously improve performance

            01:59:04.720 --> 01:59:11.040
            and usability of your applications. Platform agnostic. It works for apps on net node.js,

            01:59:11.040 --> 01:59:17.120
            Java and Python hosted on premises hybrid or any public cloud. DevOps integration. It can be

            01:59:17.120 --> 01:59:22.720
            integrated into your DevOps process and mobile app monitoring. It can monitor and analyze telemetry

            01:59:22.720 --> 01:59:28.400
            from mobile apps by integrating with Visual Studio App Center. To use application insights,

            01:59:28.400 --> 01:59:33.040
            you need to instrument your application. This involves installing the instrument package or

            01:59:33.040 --> 01:59:37.200
            enabling application insights using the application insights agents were supported.

            01:59:37.200 --> 01:59:42.400
            There are many ways to view your telemetry data. Apps can be instrumented from anywhere.

            01:59:42.400 --> 01:59:47.200
            When you set up application insights monitoring for your web app, you create an application

            01:59:47.200 --> 01:59:52.160
            insights resource in Microsoft Azure. You open this resource in the Azure portal in order to

            01:59:52.160 --> 01:59:57.600
            see and analyze the telemetry collected from your app. The resource is identified by an instrumentation

            01:59:57.600 --> 02:00:04.880
            key. What does application insights monitor request rates, response times and failure rates,

            02:00:04.880 --> 02:00:10.720
            dependency rates, response times and failure rates, exceptions, page views and load performance,

            02:00:10.720 --> 02:00:17.520
            Ajax calls, user and session counts, performance counters, host diagnostics, diagnostic trace logs,

            02:00:17.520 --> 02:00:24.560
            and custom events and metrics. Where do I see my telemetry, smart detection and manual alerts,

            02:00:24.560 --> 02:00:29.920
            application map, profiler usage analysis, diagnostic search for instance data,

            02:00:29.920 --> 02:00:36.160
            metrics explorer for a graded data, dashboards, live stream metrics, analytics, Visual Studio,

            02:00:36.160 --> 02:00:42.240
            etc. Overall, application insights is a comprehensive APM service that offers automatic

            02:00:42.240 --> 02:00:46.640
            detection of performance anomalies, powerful analytics tools, and is designed to help you

            02:00:46.640 --> 02:00:56.400
            continuously improve performance and usability. In this segment, we'll delve into the topic of

            02:00:56.400 --> 02:01:02.080
            application insights instrumentation. So what is instrumentation? In simple terms, it's a way to

            02:01:02.080 --> 02:01:06.960
            make your application smarter by adding a few lines of code or in some cases, not at all,

            02:01:06.960 --> 02:01:10.880
            you can monitor how your app performs and where it might be running into issues.

            02:01:10.880 --> 02:01:16.000
            You instrument your application by adding the Azure application insights SDK and implementing traces.

            02:01:16.640 --> 02:01:21.920
            In the case of a node.js application, you can install the Azure application insights SDK using

            02:01:21.920 --> 02:01:27.680
            NPM with the following command, NPM install application insights hyphen save application

            02:01:27.680 --> 02:01:32.480
            insights. This is the name of the package you are installing, which is Azure SDK for application

            02:01:32.480 --> 02:01:38.640
            insights hyphen save this flag saves the package as a dependency in your package dot json file.

            02:01:38.640 --> 02:01:41.600
            Here, this piece of code lets you configure what you want to collect.

            02:01:42.800 --> 02:01:48.560
            Azure supports the following languages dotnet Java, Python, node.js JavaScript.

            02:01:48.560 --> 02:01:53.680
            Auto instrumentation allows you to enable application monitoring with application

            02:01:53.680 --> 02:01:59.040
            insights without changing your code. This table shows which Azure services support application

            02:01:59.040 --> 02:02:03.360
            insights and in what programming languages the services range from Azure App Service on

            02:02:03.360 --> 02:02:08.240
            Windows and Linux to Azure Functions, Azure Spring Cloud, Azure Kubernetes Service and more.

            02:02:09.280 --> 02:02:14.800
            GA general availability, meaning it's fully supported and ready to use public preview still

            02:02:14.800 --> 02:02:20.160
            being tested, but you can use it not supported. You can't use application insights here.

            02:02:20.160 --> 02:02:23.760
            Through agent, you need to install a special piece of software to use this service.

            02:02:23.760 --> 02:02:29.840
            Oh, and bd on by default, meaning the feature is automatically enabled through extension available,

            02:02:29.840 --> 02:02:34.880
            but needs an extension to work. We won't go through the entire table, but we'll give a few examples.

            02:02:35.680 --> 02:02:39.760
            For applications written in dotnet and hosted on Azure App Service on Windows,

            02:02:39.760 --> 02:02:42.960
            application insights is generally available and enabled by default.

            02:02:42.960 --> 02:02:47.040
            For applications written in Python and hosted on Azure Functions,

            02:02:47.040 --> 02:02:51.840
            application insights is available and enabled by default, but for dependencies monitoring,

            02:02:51.840 --> 02:02:57.280
            you will need to use an extension. So that's an overview of application insights instrumentation.

            02:03:02.960 --> 02:03:07.920
            Hey, this is Andrew Brown from exam Pro. And in this section, we'll be covering Microsoft Sentinel,

            02:03:07.920 --> 02:03:13.120
            formerly known as Azure Sentinel. Microsoft Sentinel is a scalable cloud native solution

            02:03:13.120 --> 02:03:18.480
            that encompasses two key functionalities. Security Information Event Management. This

            02:03:18.480 --> 02:03:23.040
            is all about collecting and analyzing security related data to provide real time analysis of

            02:03:23.040 --> 02:03:28.240
            security alerts generated by applications and network hardware. Security Orchestration

            02:03:28.240 --> 02:03:33.280
            Automated Response. This refers to the collection of tools that enable an organization to define,

            02:03:33.280 --> 02:03:38.800
            standardize, measure and automate responses to security events. Microsoft Sentinel delivers

            02:03:38.800 --> 02:03:43.040
            intelligent security analytics and threat intelligence across the enterprise providing

            02:03:43.040 --> 02:03:49.440
            a single solution for alert detection, threat visibility, proactive hunting, and threat

            02:03:49.440 --> 02:03:55.520
            response. With Microsoft Sentinel, you can collect data at cloud scale across all users, devices,

            02:03:55.520 --> 02:04:01.600
            applications and infrastructure, both on premises and in multiple clouds. Detect previously undetected

            02:04:01.600 --> 02:04:05.920
            threats and minimize false positives using Microsoft's analytics and unparalleled threat

            02:04:05.920 --> 02:04:11.600
            intelligence. Investigate threats with artificial intelligence and hunt for suspicious activities at

            02:04:11.600 --> 02:04:17.360
            scale tapping into years of cybersecurity work at Microsoft. Respond to incidents rapidly with

            02:04:17.360 --> 02:04:22.880
            built in orchestration and automation of common tasks. Microsoft Sentinel comes with a number of

            02:04:22.880 --> 02:04:31.280
            connectors for Microsoft solutions such as Microsoft 365 Defender, Office 365, Azure AD or

            02:04:31.280 --> 02:04:38.400
            Microsoft Enter ID, Microsoft Defender for Identity, and Microsoft Defender for Cloud Apps. You can use

            02:04:38.400 --> 02:04:46.320
            common event formats, Syslog, REST API, Windows event logs, common event format, and trusted

            02:04:46.320 --> 02:04:52.080
            automated exchange of indicator information. One notable feature of Microsoft Sentinel is the

            02:04:52.080 --> 02:04:57.280
            ability to create Azure Monitor workbooks. Workbooks provide a flexible canvas for data

            02:04:57.280 --> 02:05:02.240
            analysis and the creation of rich visual reports within the Azure portal. They allow you to tap

            02:05:02.240 --> 02:05:07.200
            into multiple data sources from across Azure and combine them into unified interactive experiences.

            02:05:07.200 --> 02:05:12.400
            It tells a story about the performance and availability about your applications and services.

            02:05:12.400 --> 02:05:17.520
            Workbooks are temporary workspaces to define a document like format with visualization

            02:05:17.520 --> 02:05:23.440
            intertwined to help investigate and discuss performance. Microsoft Sentinel uses analytics

            02:05:23.440 --> 02:05:28.640
            to correlate alerts into incidents. Incidents are groups of related alerts that together create an

            02:05:28.640 --> 02:05:34.400
            actionable possible threat that you can investigate and resolve. Microsoft Sentinel's automation and

            02:05:34.400 --> 02:05:39.360
            orchestration solution provides a highly extensible architecture that enables scalable automation as

            02:05:39.360 --> 02:05:46.000
            new technologies and threats emerge. Built on the foundation of Azure Logic Apps, includes 200 plus

            02:05:46.000 --> 02:05:52.240
            connectors for services. Microsoft Sentinel also offers deep investigation tools that help you to

            02:05:52.240 --> 02:05:56.560
            understand the scope and find the root cause of a potential security threat. You can choose an

            02:05:56.560 --> 02:06:01.120
            entity on the interactive graph to ask interesting questions for a specific entity and drill down

            02:06:01.120 --> 02:06:06.320
            into that entity and its connections to get to the root cause of the threat. Additionally,

            02:06:06.320 --> 02:06:11.040
            Microsoft Sentinel's powerful hunting search and query tools based on the MITRE framework

            02:06:11.040 --> 02:06:15.520
            enable you to proactively hunt for security threats across your organization's data sources

            02:06:15.520 --> 02:06:21.040
            before an alert is triggered. After you discover which hunting query provides high value insights

            02:06:21.040 --> 02:06:25.840
            into possible attacks, you can also create custom detection rules based on your query and service

            02:06:25.840 --> 02:06:31.520
            those insights as alerts to your security incident responders. While hunting, you can create bookmarks

            02:06:31.520 --> 02:06:35.680
            for interesting events, enabling you to return to them later, share them with others, and group

            02:06:35.680 --> 02:06:41.040
            them with other correlating events to create a compelling incident for investigation. Lastly,

            02:06:41.040 --> 02:06:46.400
            let's talk about pricing. Microsoft Sentinel has two different pricing models. Capacity

            02:06:46.400 --> 02:06:50.800
            reservations, this involves being billed a fixed fee based on the selected tier, enabling a

            02:06:50.800 --> 02:06:56.080
            predictable total cost for Microsoft Sentinel. Pay as you go. With this option, bill per gigabyte

            02:06:56.080 --> 02:07:00.480
            for the volume of data ingested for analysis in Microsoft Sentinel and stored in the Azure

            02:07:00.480 --> 02:07:06.480
            Monitor Log Analytics workspace. And there you have it, a comprehensive look at Microsoft Sentinel,

            02:07:06.480 --> 02:07:10.640
            a robust seam and source solution that can help protect your organization's infrastructure,

            02:07:10.640 --> 02:07:21.120
            applications and data. Hey, this is Andrew Brown from exam Pro. And in this section,

            02:07:21.120 --> 02:07:25.680
            we'll be covering the identity management best practices. We'll start things off by discussing

            02:07:25.680 --> 02:07:30.960
            the principle of least privilege, a term you may have come across before. So the principle of least

            02:07:30.960 --> 02:07:35.920
            privilege is a security principle that states that users applications and services should be granted

            02:07:35.920 --> 02:07:40.640
            only the minimum access necessary to perform their assigned tasks and no more. In Microsoft

            02:07:40.640 --> 02:07:44.880
            Azure, the principle of least privilege is a critical aspect of security that helps prevent

            02:07:44.880 --> 02:07:50.320
            unauthorized access data breaches and other security incidents. The principle of least

            02:07:50.320 --> 02:07:54.880
            privilege in Azure involves limiting access to Azure resources such as virtual machines,

            02:07:54.880 --> 02:08:00.160
            storage accounts and databases as well as Azure services such as Azure Active Directory and Azure

            02:08:00.160 --> 02:08:06.160
            Key Vault. Azure role based access control permits administrators to grant roles to users groups and

            02:08:06.160 --> 02:08:11.040
            apps based on their access levels. Following the principle of least privilege helps minimize

            02:08:11.040 --> 02:08:16.080
            unauthorized access risks and potential harm from compromised credentials, thus reducing the Azure

            02:08:16.080 --> 02:08:21.920
            environments attack surface. Following the principle of least privilege can help organizations comply

            02:08:21.920 --> 02:08:27.200
            with regulatory requirements and best practices for security. To implement the principle of least

            02:08:27.200 --> 02:08:32.400
            privilege in Azure administrators should follow these best practices. Assign roles based on the

            02:08:32.400 --> 02:08:37.440
            least amount of privilege needed to perform the task. Monitor role assignments and permissions

            02:08:37.440 --> 02:08:42.240
            regularly to ensure they align with business requirements. Limit the use of shared accounts

            02:08:42.240 --> 02:08:47.680
            and use individual user accounts where possible. Implement multi-factor authentication to prevent

            02:08:47.680 --> 02:08:53.360
            unauthorized access to user accounts. Use Azure policy to enforce compliance with organizational

            02:08:53.360 --> 02:08:58.960
            policies and industry regulations. Implement network security groups and firewalls to control

            02:08:58.960 --> 02:09:04.400
            traffic to and from Azure resources and regularly review access control policies and adjust as

            02:09:04.400 --> 02:09:09.680
            necessary to ensure that they remain effective. So that's an overview of the principle of least

            02:09:09.680 --> 02:09:20.400
            privilege. The next topic will cover our privileged identity management or PIM for short within Azure

            02:09:20.400 --> 02:09:25.920
            AD. Now why should you care about PIM? Because it's like a VIP lounge for your most sensitive

            02:09:25.920 --> 02:09:31.440
            resources controlling who gets in when and what they can do once they're inside. So privileged

            02:09:31.440 --> 02:09:36.400
            identity management is an Azure AD service enabling you to manage control and monitor access to

            02:09:36.400 --> 02:09:43.040
            important resources in your organization. You can manage resources from Azure AD, Azure, Microsoft

            02:09:43.040 --> 02:09:50.480
            365, Microsoft Intune, and more. So what are the key features of PIM? Just in time access,

            02:09:50.480 --> 02:09:55.600
            this feature allows you to grant privileged access to Azure AD and Azure resources only when needed.

            02:09:55.600 --> 02:10:00.800
            Assign time-bound access to resources using start and end dates. Required approval to activate

            02:10:00.800 --> 02:10:07.120
            privileged roles. Enforce multi-factor authentication to activate any role. Use justification to

            02:10:07.120 --> 02:10:13.120
            understand why users activate. Get notifications when privileged roles are activated. Conduct

            02:10:13.120 --> 02:10:18.560
            access reviews to ensure users still need roles. And download audit history for internal or external

            02:10:18.560 --> 02:10:23.600
            audit. It's important to note that PIM is part of Azure AD Premium too, so you'll need that

            02:10:23.600 --> 02:10:29.120
            subscription to access these features. By taking advantage of PIM and its features, you can ensure

            02:10:29.120 --> 02:10:38.880
            a more secure and controlled environment for your organization. Next, we'll be diving into another

            02:10:38.880 --> 02:10:44.880
            critical topic, Azure AD Identity Protection. So what does it do? Identity protection is a feature

            02:10:44.880 --> 02:10:50.240
            of Azure AD that enables you to detect, investigate, remediate, and export identity-based risks for

            02:10:50.240 --> 02:10:56.320
            future analysis. Microsoft analyzes a staggering 6.5 trillion signals per day to identify and

            02:10:56.320 --> 02:11:03.440
            protect customers from threats. Identity protection can notice risky users, risky sign-ins, and risk

            02:11:03.440 --> 02:11:09.040
            detections. Let's take a closer look at the types of risks that identity protection can identify.

            02:11:09.040 --> 02:11:14.400
            Anonymous IP address. This is a sign-in from an anonymous IP address like those used by the Tor

            02:11:14.400 --> 02:11:20.160
            browser or anonymizer VPNs. Atypical travel. This refers to a sign-in from a location that is

            02:11:20.160 --> 02:11:25.280
            atypical based on the user's recent sign-ins. Malware-linked IP address. A sign-in from an

            02:11:25.280 --> 02:11:30.480
            IP address linked to malware. Unfamiliar sign-in properties. A sign-in with properties that haven't

            02:11:30.480 --> 02:11:35.360
            been seen recently for the given user. Leaked credentials. Indicates that the user's valid

            02:11:35.360 --> 02:11:40.560
            credentials have been leaked. Password spray. This involves multiple usernames being attacked

            02:11:40.560 --> 02:11:46.480
            using common passwords in a unified, brute force manner. Azure AD threat intelligence. This is when

            02:11:46.480 --> 02:11:50.400
            Microsoft's internal and external threat intelligence sources have identified a known

            02:11:50.400 --> 02:11:55.600
            attack pattern. And there are others detected by Microsoft Defender for cloud apps such as

            02:11:55.600 --> 02:12:00.480
            new country activity, activity from anonymous IP addresses, and suspicious inbox forwarding.

            02:12:00.480 --> 02:12:06.080
            The risk signals can trigger remediation efforts such as requiring users to use Azure AD

            02:12:06.080 --> 02:12:11.360
            multi-factor authentication, reset their password using self-service password reset, or even blocking

            02:12:11.360 --> 02:12:17.600
            until an administrator takes action. Identity protection categorizes risk into three tiers,

            02:12:17.600 --> 02:12:23.920
            low, medium, and high. And administrators can use key reports for investigations such as risky users,

            02:12:23.920 --> 02:12:29.680
            risky sign-ins, and risk detections reports. In the risky users report, you'll find comprehensive

            02:12:29.680 --> 02:12:34.480
            details about detected risks, a complete history of all risky sign-ins, as well as the user's

            02:12:34.480 --> 02:12:40.240
            overall risk history to give you a full picture of security concerns. In the risky sign-ins report,

            02:12:40.240 --> 02:12:45.120
            you'll see sign-ins categorized as at risk, confirmed compromised, confirmed safe, dismissed,

            02:12:45.120 --> 02:12:50.160
            or remediate. This report provides both real-time and aggregate risk levels associated with each

            02:12:50.160 --> 02:12:55.040
            sign-in attempt. It also includes the types of risk detections triggered, the conditional access

            02:12:55.040 --> 02:13:00.000
            policies applied, multi-factor authentication details, and information about the device,

            02:13:00.000 --> 02:13:06.080
            application, and location involved in the sign-in. Risk detections offers filterable data covering up

            02:13:06.080 --> 02:13:10.880
            to the past 90 days. It provides detailed information about each type of risk detected,

            02:13:10.880 --> 02:13:14.880
            as well as other risks that were triggered simultaneously and the locations of the sign-in

            02:13:14.880 --> 02:13:21.840
            attempts. Admin follow-up actions. Admins can take various actions like resetting the user password,

            02:13:21.840 --> 02:13:29.200
            confirming a user compromise, dismissing user risk, blocking user sign-ins, and investigate

            02:13:29.200 --> 02:13:34.880
            further using Azure App. So with Azure AD Identity Protection, you're not just identifying risks,

            02:13:34.880 --> 02:13:45.200
            but you're also given powerful tools to act on them. Hey, this is Andrew Brown from exam Pro.

            02:13:45.200 --> 02:13:49.760
            In this segment, we'll delve deep into Azure Key Vault, a pivotal tool to ensure the security of

            02:13:49.760 --> 02:13:55.120
            your cloud applications and services. Azure Key Vault helps you safeguard cryptographic keys and

            02:13:55.120 --> 02:14:00.640
            other secrets used by cloud apps and services. Azure Key Vault focuses on three things.

            02:14:00.640 --> 02:14:05.520
            Certificate management. This feature allows for easy provision, management, and deployment of both

            02:14:05.520 --> 02:14:10.160
            public and private SSL certificates. These certificates can be used with Azure and internally

            02:14:10.160 --> 02:14:15.680
            connected resources. Key management. This enables the creation and control of encryption keys used

            02:14:15.680 --> 02:14:20.720
            to encrypt your data. Secrets management. Here, you have a secure space to store and tightly

            02:14:20.720 --> 02:14:27.360
            control access to tokens, passwords, certificates, API keys, and other secrets. Note that certificates

            02:14:27.360 --> 02:14:31.840
            contain a key pair, which is a combination of a key and a secret. This should not be confused

            02:14:31.840 --> 02:14:37.680
            with key management and secrets management, which are distinct functionalities. Moving forward,

            02:14:37.680 --> 02:14:42.800
            let's talk about HSMs, or hardware security modules. These are dedicated hardware devices

            02:14:42.800 --> 02:14:48.240
            specifically designed to securely store encryption keys. When it comes to adhering to standards,

            02:14:48.240 --> 02:14:53.120
            we reference the Federal Information Processing Standard, or FIPS. This is a guideline recognized

            02:14:53.120 --> 02:14:57.840
            by the US and Canadian governments that specifies the security requirements for cryptographic

            02:14:57.840 --> 02:15:03.120
            modules that protect sensitive information. In line with FIPS, we have two levels of compliance

            02:15:03.120 --> 02:15:09.680
            for HSMs. FIPS 100 Fortiminus II Level 2 compliant. This compliance level is for multi-tenant HSMs

            02:15:09.680 --> 02:15:15.840
            where multiple customers are virtually isolated on a single HSM. FIPS 100 Fortiminus II Level 3

            02:15:15.840 --> 02:15:21.360
            compliant. This level, on the other hand, pertains to single-tenant HSMs where one customer utilizes

            02:15:21.360 --> 02:15:26.960
            a dedicated HSM. In essence, Azure Key Vault is an indispensable tool for ensuring that your cloud

            02:15:26.960 --> 02:15:32.000
            data remains both accessible and secure. Whether you're working with certificates, encryption keys,

            02:15:32.000 --> 02:15:41.520
            or various secrets, Azure Key Vault has you covered. All right, let's dive into the core

            02:15:41.520 --> 02:15:46.560
            of Azure Key Vault, the vault itself. A vault is where your secrets and keys reside, safeguarded

            02:15:46.560 --> 02:15:52.240
            either by software or by HSMs validated to the standards of FIPS 100 Fortiminus II Level 2.

            02:15:52.240 --> 02:15:57.680
            Azure Key Vault provides two types of containers. Vaults. These containers support both software

            02:15:57.680 --> 02:16:04.480
            and HSM-backed keys. HSM pools. These are specialized containers solely for HSM-backed keys.

            02:16:04.480 --> 02:16:10.320
            To activate your HSM, you will need to provide a minimum of three RSA key pairs up to a maximum

            02:16:10.320 --> 02:16:15.360
            of 10, and specify the minimum number of keys required to decrypt the security domain, called

            02:16:15.360 --> 02:16:20.080
            a quorum. You do not choose the container on creation, you just choose between standard and

            02:16:20.080 --> 02:16:25.520
            premium. When you choose premium and create enough RSA key pairs, you will begin to use HSM pools.

            02:16:25.520 --> 02:16:31.120
            Diving a bit into technicalities, Azure Key Vault REST API is used for programmatically

            02:16:31.120 --> 02:16:36.480
            managing Azure Key Vault resources, allowing you to perform operations such as create a key or

            02:16:36.480 --> 02:16:42.960
            secret, import a key or secret, revoke a key or secret, delete a key or secret, authorize user

            02:16:42.960 --> 02:16:49.120
            or apps to access its keys or secrets, and monitor and manage key usage. Azure Key Vault REST API

            02:16:49.120 --> 02:16:54.800
            supports three different types of authentication. Managed identities. An identity managed by Azure

            02:16:54.800 --> 02:17:00.560
            AD, recommended as best practice. Service principle and certificate. This method uses a certificate

            02:17:00.560 --> 02:17:06.480
            for authentication. Service principle and secret. A combination of a user identity and a secret key.

            02:17:06.480 --> 02:17:11.440
            One feature to note is the soft delete functionality. Soft delete allows you to

            02:17:11.440 --> 02:17:15.600
            recover or permanently delete a key vault and secrets for the duration of the retention period.

            02:17:15.600 --> 02:17:21.200
            This feature is enabled by default on creation. Mandatory retention period prevents the permanent

            02:17:21.200 --> 02:17:26.720
            deletion of key vaults or secrets prior to the retention period elapsing. Furthermore, enabling

            02:17:26.720 --> 02:17:31.360
            purge protection safeguards your secrets from being prematurely purged, either by users or by

            02:17:31.360 --> 02:17:41.360
            Microsoft, bolstering the security of your vault. Next up on our agenda is breaking down the

            02:17:41.360 --> 02:17:45.600
            pricing of Azure Key Vault. Knowing how you're billed for this service can help you make informed

            02:17:45.600 --> 02:17:51.520
            decisions and optimize your costs. Azure Key Vault offers two pricing tiers, standard and premium.

            02:17:51.520 --> 02:17:56.000
            The notable distinction between the two is that while both tiers support software protected keys,

            02:17:56.000 --> 02:18:01.680
            only the premium tier allows for HSM protected keys. Here's a closer look at the pricing tiers.

            02:18:01.680 --> 02:18:07.120
            First 250 keys, regardless of whether you're on the standard or premium tier, you'll be billed

            02:18:07.120 --> 02:18:15.680
            $5 per key every month. 251 1500 keys, the price drops to $2.50 per key monthly, again consistent

            02:18:15.680 --> 02:18:22.080
            across both tiers. 1501 to 4000 keys, the cost further reduces to 90 cents for each key every

            02:18:22.080 --> 02:18:27.840
            month. 4001 plus keys, for larger key volumes beyond this point, you'll be charged at a rate

            02:18:27.840 --> 02:18:33.440
            of 40 cents per key per month. Secrets operations, both tiers are priced at three cents for every

            02:18:33.440 --> 02:18:39.280
            10,000 transactions involving secrets. Certificate operations, exclusive to the premium tier,

            02:18:39.280 --> 02:18:45.040
            each certificate renewal request is billed at $3. Managed Azure Storage Account key rotation,

            02:18:45.040 --> 02:18:51.520
            this service only available in the premium tier is priced at $1 per renewal. HSM protected keys,

            02:18:51.520 --> 02:18:57.040
            specifically for HSM protected keys, the pricing is further broken down based on the key types.

            02:18:57.040 --> 02:19:02.560
            For RSA 2048 bit keys, the cost is $1 per key per month, along with an additional charge of

            02:19:02.560 --> 02:19:09.920
            three cents per 10,000 transactions. For RSA 3072 bit and 4096 bit keys, as well as ECC keys,

            02:19:09.920 --> 02:19:16.320
            the first 250 keys are priced at $5 per key per month. So that's an overview of the pricing model

            02:19:16.320 --> 02:19:26.560
            for Azure Key Vault. The next topic we'll be covering is double encryption for Azure Key Vault.

            02:19:26.560 --> 02:19:30.880
            Before we dive in, let's quickly recap infrastructure encryption for storage accounts.

            02:19:30.880 --> 02:19:35.280
            By default, Azure ensures that your storage account data is encrypted when it's at rest.

            02:19:35.280 --> 02:19:39.840
            Infrastructure encryption adds a second layer of encryption to your storage accounts data.

            02:19:39.840 --> 02:19:44.960
            Now let's jump into Azure disks double encryption. Double encryption is precisely what it sounds

            02:19:44.960 --> 02:19:49.040
            like. It's where two or more independent layers of encryption are enabled to protect against

            02:19:49.040 --> 02:19:54.080
            compromises of any one layer of encryption. This strategy ensures that even if one encryption

            02:19:54.080 --> 02:19:59.760
            layer is compromised, the data remains protected by the other. Microsoft has a two layered approach,

            02:19:59.760 --> 02:20:05.440
            both for data at rest and data in transit. For data at rest disk encryption, this is achieved

            02:20:05.440 --> 02:20:10.800
            using customer managed keys and infrastructure encryption. This uses platform managed keys,

            02:20:10.800 --> 02:20:16.320
            strengthening the base layer and for data in transit, transit encryption using transport

            02:20:16.320 --> 02:20:21.360
            layer security 1.2 to safeguard data as it travels through networks, and an additional

            02:20:21.360 --> 02:20:26.320
            layer of encryption provided at the infrastructure layer. So that's a quick overview of double

            02:20:26.320 --> 02:20:36.080
            encryption for Azure key vault. In this section, we'll go into detail on the keys in Azure key vault.

            02:20:36.080 --> 02:20:41.600
            When it comes to creating a key in Azure, you have three primary choices. Generate Azure will

            02:20:41.600 --> 02:20:46.880
            generate the key for you. Import import an existing RSA key that you already possess,

            02:20:46.880 --> 02:20:52.800
            and restore backup restore a key from backup. For keys generated by Azure, you can use either RSA or

            02:20:52.800 --> 02:21:02.400
            EC, RSA or RIVEST, Shamir, Adelman, this supports key sizes of 2048 3072 and 4096 bits, EC or elliptic

            02:21:02.400 --> 02:21:12.080
            curve cryptography here you can select from P 256 P 384 P 521 or P 256 k for keys generated by

            02:21:12.080 --> 02:21:17.280
            Azure, you can set an activation and expiration date. Additionally, you're not bound to a static

            02:21:17.280 --> 02:21:23.040
            version of a key, you can create new versions of keys. You can also download backups of keys. But

            02:21:23.040 --> 02:21:27.600
            remember that backups can only be restored within the same Azure subscription and within Azure key

            02:21:27.600 --> 02:21:34.000
            vault. When you have a premium vault, you'll key options for HSM, you can generate either an RSA or

            02:21:34.000 --> 02:21:41.920
            EC specifically for HSM, or important RSA key for HSM as shown in the example. Now let's talk about

            02:21:41.920 --> 02:21:47.680
            key management types. Microsoft managed key or keys managed by Microsoft, they do not appear in

            02:21:47.680 --> 02:21:53.280
            your vault and in most cases are used by default for many Azure services. Customer managed key or

            02:21:53.280 --> 02:21:57.920
            keys you create an Azure key vault, you need to select a key from a vault for various services.

            02:21:57.920 --> 02:22:03.200
            Sometimes customer managed means that the customer has imported cryptographic material and any

            02:22:03.200 --> 02:22:08.560
            generated or imported keys are considered CMK and Azure. In order to use a key and Azure service

            02:22:08.560 --> 02:22:13.040
            needs an identity established within Azure AD for permission to access the key from the vault.

            02:22:13.040 --> 02:22:18.080
            Additionally, you have the option to implement infrastructure encryption. While Azure already

            02:22:18.080 --> 02:22:22.880
            encrypt storage account data at rest by default, opting for infrastructure encryption adds a second

            02:22:22.880 --> 02:22:32.960
            layer of security fortifying your storage accounts data even further. The next topic we'll be covering

            02:22:32.960 --> 02:22:38.480
            are secrets in Azure key vault. Azure key vault secrets provide secure storage of generic secrets

            02:22:38.480 --> 02:22:44.400
            such as passwords and database connection strings. Key vault APIs accept and return secret values as

            02:22:44.400 --> 02:22:50.000
            strings. Internally key vault stores and manages secrets as sequences of octets with each secret

            02:22:50.000 --> 02:22:56.080
            having a maximum size of 25k bytes. The key vault service doesn't provide semantics for secrets,

            02:22:56.080 --> 02:23:01.840
            it accepts the data encrypts it stores it and returns a secret identifier. For highly sensitive

            02:23:01.840 --> 02:23:06.720
            data clients should consider additional layers of protection for data. For example, encrypting

            02:23:06.720 --> 02:23:11.760
            your data using a separate protection key before storing it in the key vault. Key vault also

            02:23:11.760 --> 02:23:17.040
            supports a content type field for secrets allowing clients to specify the content type of a secret to

            02:23:17.040 --> 02:23:21.440
            assist in interpreting the secret data when it's retrieved. Note that the maximum length of this

            02:23:21.440 --> 02:23:28.400
            field is 255 characters. Every secret stored in your key vault is encrypted. Key vault encrypts

            02:23:28.400 --> 02:23:33.520
            secrets at rest with a hierarchy of encryption keys. All keys in that hierarchy are protected

            02:23:33.520 --> 02:23:38.400
            by modules that are FIPS 100 for diminished to complied. The encryption leaf key is unique to

            02:23:38.400 --> 02:23:43.360
            each key vault while the root key is unique to the entire security world. The protection level

            02:23:43.360 --> 02:23:49.360
            may vary between regions. For example, China uses FIPS 100 for diminished to level one and all other

            02:23:49.360 --> 02:23:56.240
            regions use level two or higher. Diving into secret attributes we have X this is the expiration time

            02:23:56.240 --> 02:24:01.840
            after which the secret data should not be retrieved. And BF not before default value is now

            02:24:01.840 --> 02:24:06.960
            this defines the time before which the secret data should not be retrieved. Enable this tells us

            02:24:06.960 --> 02:24:11.920
            whether the secret data can be retrieved or not with its default set to true. Additionally, there

            02:24:11.920 --> 02:24:17.440
            are read only attributes for created an update. In order to access secrets within your application

            02:24:17.440 --> 02:24:22.320
            code, you can would use the Azure SDK. For example, we have a.net example in this image here.

            02:24:23.280 --> 02:24:28.400
            Another option is to use tools like Azure CLI. So that about covers the important

            02:24:28.400 --> 02:24:39.520
            details of secrets in Azure key vault. The next topic we'll be covering our x 509 certificates.

            02:24:39.520 --> 02:24:45.600
            First, let's unravel what public key infrastructure is. PKI is a set of roles, policies, hardware,

            02:24:45.600 --> 02:24:50.880
            software and procedures needed to create manage distribute use store and revoke digital certificates

            02:24:50.880 --> 02:24:57.680
            and manage public key encryption. So what exactly is an x 509 certificate? It is a standard defined

            02:24:57.680 --> 02:25:04.000
            by the International Telecommunication Union for public key certifications. x 509 certificates are

            02:25:04.000 --> 02:25:10.640
            used in many internet protocols, including SSL TLS and HTTPS signed and encrypted email and code

            02:25:10.640 --> 02:25:15.600
            signing and document signing. A certificate contains an identity which could be a host name

            02:25:15.600 --> 02:25:21.760
            an organization or an individual along with a public key built on platforms like RSA DSA or ECDA.

            02:25:21.760 --> 02:25:27.440
            But who issues these certificates here comes the role of the certificate authority a trusted entity

            02:25:27.440 --> 02:25:32.400
            that issues digital certificates a co acts as a trusted third part trusted both by the subject

            02:25:32.400 --> 02:25:37.760
            of the certificate and by the party relying upon the certificate. A certificate authority can issue

            02:25:37.760 --> 02:25:42.880
            multiple certificates in the form of tree structure known as a chain of trust. Root certificate

            02:25:42.880 --> 02:25:47.360
            authority. This is a self signed certificate, the private key associated with it signs other

            02:25:47.360 --> 02:25:52.720
            certificates, it's important that the private key of root are protected. Intermediate certificate

            02:25:52.720 --> 02:25:57.360
            authority, these certificates are signed by the roots private key, they protect the root certificate

            02:25:57.360 --> 02:26:02.560
            because the root certificate does not have to sign every issued certificate and entity certificate

            02:26:02.560 --> 02:26:07.920
            a certificate issued by the ICA used by the end entity. The entity in the case is an SSL certificate

            02:26:07.920 --> 02:26:15.040
            for a website. A certificate contains a metadata about version number the version of the x 509

            02:26:15.040 --> 02:26:19.920
            standard serial number a unique serial number assigned to the certificate by the certificate

            02:26:19.920 --> 02:26:25.920
            authority signature algorithm ID the algorithm used to sign the certificate such as RSA or DSA

            02:26:25.920 --> 02:26:31.840
            issuer the name of the certificate authority that issued this certificate validity period the start

            02:26:31.840 --> 02:26:36.880
            and end dates during which the certificate is valid subject the identifier for the individual

            02:26:36.880 --> 02:26:41.840
            or organization to whom the certificate was issued. Subject public key the public key that

            02:26:41.840 --> 02:26:46.560
            is authenticated by this certificate. This field also names the algorithm used for public key

            02:26:46.560 --> 02:26:52.080
            generation. Issuer unique identifier allows multiple CAS to operate as a single logical

            02:26:52.080 --> 02:26:57.600
            subject unique identifier allows multiple certificate holders to act as a single logical

            02:26:57.600 --> 02:27:02.800
            entity. extensions allows a car to associate additional private information with a certificate.

            02:27:03.440 --> 02:27:10.000
            All the metadata is publicly readable anyone can view it. So that's an overview of x 509 certificates.

            02:27:10.000 --> 02:27:20.400
            Hey this is Andrew Brown from exam Pro and this fall along we're going to be learning all about

            02:27:20.400 --> 02:27:25.840
            Azure Vault. So let's get to it. So what I want you to do is go in the top here and type in

            02:27:25.840 --> 02:27:31.440
            key vault and here we'll have to go ahead and create ourselves a new vault. And so from there

            02:27:31.440 --> 02:27:37.040
            we're going to create a new resource group. I'm going to call this resource group my example vault

            02:27:37.040 --> 02:27:44.000
            and then we will make a vault key here. So I'll just say my vault example, which is kind of funny

            02:27:44.000 --> 02:27:47.280
            because this one's slightly different. So you've seen I've done this before. So I'm gonna do my

            02:27:47.280 --> 02:27:54.960
            example vault as the name here. And for the region US East is fine for pricing, we'll keep it at

            02:27:54.960 --> 02:28:02.880
            standard. Soft Delete is enabled. And then there's the option for purge protection. So we are going to

            02:28:02.880 --> 02:28:08.720
            enable purge protection. And this is going to play into other follow alongs. We'll explain that as

            02:28:08.720 --> 02:28:15.200
            it goes. But purge protection does not allow you to purge things easily once it's enabled. So what

            02:28:15.200 --> 02:28:22.240
            we'll do is go ahead and review and create. And we'll go ahead and go review create.

            02:28:22.800 --> 02:28:24.800
            And we'll give it a moment here.

            02:28:24.800 --> 02:28:33.440
            And we'll just wait till it's done deploying. Okay. Alright, so after a short little wait,

            02:28:33.440 --> 02:28:38.160
            our vault is created. And so why don't you just go to the resource, and we're going to be using

            02:28:38.160 --> 02:28:44.800
            this vault a little bit and some of the follow alongs and in some cases, not so much. Okay.

            02:28:50.400 --> 02:28:58.400
            So

            02:28:58.400 --> 02:29:13.120
            Hey, this is Andrew Brown. And this fall long, we're going to be doing some things with

            02:29:13.120 --> 02:29:17.680
            keys with an Azure key vault. So what I want you to do is make your way over to the keys blade on

            02:29:17.680 --> 02:29:22.480
            the left hand side here, we're going to generate or slash import a new key, we're going to choose

            02:29:22.480 --> 02:29:30.080
            the generate option. In terms of naming, we're going to call this my disk key. And we are going

            02:29:30.080 --> 02:29:36.320
            to choose RSA 2048. That seems totally fine to me, everything else seems okay. So go ahead and create

            02:29:36.320 --> 02:29:42.320
            that key. So give it a moment to create doesn't take too long. And then what we're going to do

            02:29:42.320 --> 02:29:48.000
            is go on the left hand side to I am access controls. And what we're going to want to do

            02:29:48.000 --> 02:29:55.040
            is add a new role assignment. So we can go ahead and start using this key. So what I want you to do

            02:29:55.040 --> 02:30:03.200
            is go and look for key vault administrator, which is here, we'll go ahead and hit next. And then for

            02:30:03.200 --> 02:30:09.600
            our user, we will choose ourself. So under user, I'm going to select the members, I'm looking for

            02:30:09.600 --> 02:30:16.000
            the account I'm using, there I am and around, go ahead and select that there. And so that is all we

            02:30:16.000 --> 02:30:23.920
            need to assign it so that we can actually work with that key. So I think a good idea is to use a key

            02:30:23.920 --> 02:30:29.760
            to encrypt a disk. So what we'll do is make our way over to disk encryption sets, because before

            02:30:29.760 --> 02:30:34.960
            you can encrypt a disk, you need to have an encryption set. So go ahead and create ourselves

            02:30:34.960 --> 02:30:41.680
            a new encryption set. We'll call we'll use the sorry, the same resource group. So it's very easy

            02:30:41.680 --> 02:30:50.320
            cleanup afterwards, we'll call this my disk, encrypt set here. And in terms of the encryption

            02:30:50.320 --> 02:30:54.400
            type, we're going to use double encryption, because that's a much better you have two keys

            02:30:54.400 --> 02:31:00.000
            that encrypted. So that's a lot better, we are going to choose our vault. So we have my example

            02:31:00.000 --> 02:31:06.000
            vault, there's only one option here. And in terms of the key, we'll select my disk key terms of the

            02:31:06.000 --> 02:31:13.360
            version, we'll select the current version, we'll go ahead and hit Review Create. And then we will

            02:31:13.360 --> 02:31:19.200
            go and create that. And we'll give it a moment to create that encryption set shouldn't take too long

            02:31:19.200 --> 02:31:23.760
            here. And after a short little wait, our resource should be deployed only took about a minute for

            02:31:23.760 --> 02:31:27.040
            me. And if we go here, it's going to have this message up here, it's very small, but it says

            02:31:27.040 --> 02:31:31.200
            dissociated disk image snapshot, this disk encryption set, you must grant permissions

            02:31:31.200 --> 02:31:36.240
            to key vault. So all we have to do is click that alert, and we'll grant permissions. And so now we

            02:31:36.240 --> 02:31:43.280
            are able to use that key, or like to, we're gonna have the permissions issues is solved. So what

            02:31:43.280 --> 02:31:48.480
            we'll do is go to type and create a new disk. And so we can apply this key to the encryption. So go

            02:31:48.480 --> 02:31:54.400
            ahead and create, we're going to choose the same resource group here, I'm going to call this my

            02:31:54.400 --> 02:32:02.480
            example vault. And we're sorry, my example, disk, because that's a little bit more clear than that.

            02:32:02.480 --> 02:32:08.960
            And for the availability zone doesn't matter for the source type. It doesn't matter as well.

            02:32:08.960 --> 02:32:14.320
            In terms of the size, we want this to be cheap, we're not really using this for real. So we'll

            02:32:14.320 --> 02:32:20.480
            use standard HDD. I will say, okay, in terms of encryption, this is where things get fun,

            02:32:20.480 --> 02:32:24.800
            we go to double encryption, we choose our key here, we'll go ahead and review and create.

            02:32:24.800 --> 02:32:32.640
            And we'll just give it a moment for that to create, and we'll have to wait a little while

            02:32:32.640 --> 02:32:38.560
            here for that create that resource. So we'll just wait until that is created. Okay. And after a very

            02:32:38.560 --> 02:32:42.560
            short while the disk is ready. So we'll go to that resource, we'll go to the encryption tab to see

            02:32:42.560 --> 02:32:49.040
            that encryption is applied. So that's all it takes to use a key to encrypt a disk. So we are going to

            02:32:49.040 --> 02:32:52.880
            still use some of these accounts, there's no cleanup yet. We'll go back here and we'll see in the next

            02:32:52.880 --> 02:33:04.240
            one. Hey, this is Andrew Brown. And this fall along, we're going to learn about backup and

            02:33:04.240 --> 02:33:10.000
            restore key. So what I want you to do is go back into the resource group that we just recently

            02:33:10.000 --> 02:33:14.960
            created. And we're going to make our way over to keys. So I'm just sorry, we got to get into the

            02:33:14.960 --> 02:33:21.200
            default first, then we'll go over to keys. And the idea is that we have this key here. And so you can

            02:33:21.200 --> 02:33:25.360
            see that we have this current version, so you can add additional versions. But what's going to happen

            02:33:25.360 --> 02:33:30.240
            if we try to back this up, when you back this up, you're going to get this file here. And if you

            02:33:30.240 --> 02:33:34.240
            open up this file, it's going to look like a bunch of gobbledygook. So I'm just going to try to open

            02:33:34.240 --> 02:33:40.000
            it here. I have it up off screen here. So I'm just trying to open it up within Visual Studio code.

            02:33:40.000 --> 02:33:44.800
            So I'm just going to open up Visual Studio code, again, doing this off screen here. Just give me a

            02:33:44.800 --> 02:33:53.200
            moment. All right. And so this is the file that we encrypted. And you take a look here. And it's,

            02:33:53.200 --> 02:33:58.480
            it doesn't look like anything. But the idea is that it is our backup of our key so that we can

            02:33:58.480 --> 02:34:04.720
            re import that. And just taking a look at the key name, this is what it looks like. So this is my

            02:34:04.720 --> 02:34:10.320
            example vault, my disk key, then there's this date, and that's key backup. So just recognize

            02:34:10.320 --> 02:34:14.560
            that's the format and the date is very useful to indicate when you backed it up. So let's go ahead

            02:34:14.560 --> 02:34:20.880
            and delete this key because the idea is we want to restore that backup. And so we have deleted that

            02:34:20.880 --> 02:34:27.760
            key there. And what we're going to do is we're going to attempt a restore. So I'm going to go

            02:34:27.760 --> 02:34:40.080
            ahead and go or occurred while restoring the key, the key you're trying to restore already exists.

            02:34:40.080 --> 02:34:45.200
            Why would it throw that error, we've clearly deleted it. And the reason why is that we have

            02:34:45.200 --> 02:34:52.240
            purge protection on we did that in the first first part, when we set up this actual vault here,

            02:34:52.240 --> 02:34:56.080
            I'm going to just see if we can find the settings, wherever that purge protection is,

            02:34:56.080 --> 02:35:00.480
            I'm trying to remember where it is, purge protection is enabled. So we can go here.

            02:35:00.480 --> 02:35:04.240
            And once you enable it, you cannot turn it off, it's going to retain it for a certain amount of

            02:35:04.240 --> 02:35:11.280
            days. And so all you can do is soft delete keys. So this key is not actually deleted yet, if you

            02:35:11.280 --> 02:35:16.320
            go to manage deleted keys, you can see the key is over here. And if you try to click on purge,

            02:35:16.320 --> 02:35:21.520
            it is disabled because we cannot remove the key because we have purge protection on but we can

            02:35:21.520 --> 02:35:29.200
            recover the keys, we'll go ahead and recover. And so that will allow us to recover the key.

            02:35:29.200 --> 02:35:37.440
            And if we refresh here, it's going to take a little bit time for that key to restore.

            02:35:37.440 --> 02:35:40.640
            So we'll just have to wait a little bit and then it will show up.

            02:35:40.640 --> 02:35:47.040
            There's one other thing I wanted to show you was under policies because you know,

            02:35:48.160 --> 02:35:54.880
            if you go under where's policies here, or access policies, if you look under our user here,

            02:35:54.880 --> 02:36:00.640
            and we look at the key permissions, there is an option to purge. And we don't actually have that

            02:36:00.640 --> 02:36:05.600
            turned on right now. But if we were to save this, and we were to still go to that purge option,

            02:36:05.600 --> 02:36:09.440
            it would still say the same thing. So even if you have purge permissions, it does not matter

            02:36:09.440 --> 02:36:13.680
            if purge protections turned on, it still will not let you purge, but you would need a combination

            02:36:13.680 --> 02:36:19.920
            of those in order to, you know, be able to do things there. So to really show you how to do

            02:36:19.920 --> 02:36:24.080
            that recovery, I think what we should do, I'm just going to delete our old key here, because we don't

            02:36:24.080 --> 02:36:28.800
            care about it. But we are going to Well, I guess we could try to import it into the other ones. I'm

            02:36:28.800 --> 02:36:33.920
            just going to undo that for a second. But we are going to go ahead and create ourselves another

            02:36:33.920 --> 02:36:40.480
            vault. So I'm going to go and type in vault at the top here, we're going to be a little more

            02:36:40.480 --> 02:36:47.760
            careful when we create this vault. So we'll go here and we will choose my example vault,

            02:36:47.760 --> 02:36:56.480
            I'm going to say my vault, no protect. And the pricing tier will be standard. One day,

            02:36:56.480 --> 02:37:01.600
            we're going to leave it or seven is the lowest and we'll say disable purge protection, because

            02:37:01.600 --> 02:37:07.200
            we don't want to have that enabled. And we'll see we can import the key into another vault. I'm not

            02:37:07.200 --> 02:37:11.520
            sure if we can do that. Worst case, we'll make a new key, download the key, re upload it. But I'm

            02:37:11.520 --> 02:37:15.520
            just curious what would happen if we tried to upload the same key as it's still in another

            02:37:15.520 --> 02:37:22.960
            vault. I'm not exactly sure. Alright, so this deployment is successful, I'm going to go to this

            02:37:22.960 --> 02:37:28.000
            resource and go ahead to go to create and we're going to restore from backup. And we're going to

            02:37:28.000 --> 02:37:32.000
            take this key and see if we can actually import it here. So it looks like we can take a key and

            02:37:32.000 --> 02:37:37.840
            it can exist in multiple vaults. I'm going to go ahead and delete this key. And we're going to say

            02:37:37.840 --> 02:37:43.280
            Are you sure you want to delete this key? I'm gonna say yes. And if we go to manage keys,

            02:37:43.280 --> 02:37:49.120
            we refresh, it takes a little bit of time here. So we'll just wait a moment for this to persist.

            02:37:49.120 --> 02:37:54.320
            And after a short little wait, like about two minutes, I refresh and the key is here. So if

            02:37:54.320 --> 02:37:58.800
            I go here, you'll notice the purges option is still not available, we can obviously recover.

            02:37:59.760 --> 02:38:05.760
            But we don't have purge protection on. So if we go to access policies over here, and we'll go ahead

            02:38:05.760 --> 02:38:10.960
            and scroll down and select purge, and save our changes, we can then go back to keys, we'll give

            02:38:10.960 --> 02:38:16.880
            it a moment to save, we go back to keys, we'll refresh it, we'll manage our keys. And we'll go

            02:38:16.880 --> 02:38:23.280
            ahead and purge it. And that will permanently purge it there. So that's all it takes to do that. So

            02:38:23.280 --> 02:38:33.920
            there you go. Hey, this is Andrew Brown from exam Pro. And in this section, we'll be going over the

            02:38:33.920 --> 02:38:39.360
            integration with on premises solutions with Azure starting with Azure AD Connect. Azure AD Connect

            02:38:39.360 --> 02:38:44.080
            is a tool provided by Microsoft that enables organizations to synchronize on premises Active

            02:38:44.080 --> 02:38:49.200
            Directory with Azure Active Directory. This synchronization enables organizations to extend

            02:38:49.200 --> 02:38:54.240
            their on premises identities and security policies to the cloud and enable seamless access to cloud

            02:38:54.240 --> 02:38:59.600
            based applications. Azure AD Connect allows for seamless single sign on from your on premises

            02:38:59.600 --> 02:39:05.600
            workstation to Microsoft Azure. Azure AD Connect has the following features password hash

            02:39:05.600 --> 02:39:10.480
            synchronization. This feature syncs user password hashes from on premises Active Directory to Azure

            02:39:10.480 --> 02:39:16.000
            AD enabling the same sign in method for both pass through authentication. This allows users to

            02:39:16.000 --> 02:39:20.400
            maintain the same password across on premises and cloud platforms without needing a separate

            02:39:20.400 --> 02:39:26.480
            federated environment setup. Federation integration, an optional feature it facilitates a hybrid setup

            02:39:26.480 --> 02:39:31.520
            using on premises a DFS infrastructure and provides management tools like certificate renewal and

            02:39:31.520 --> 02:39:36.560
            server deployment. synchronization. This is responsible for creating and aligning users,

            02:39:36.560 --> 02:39:41.760
            groups and other objects between on premises and cloud ensuring identity information matches across

            02:39:41.760 --> 02:39:47.440
            both health monitoring Azure AD Connect health offers robust activity monitoring with a dedicated

            02:39:47.440 --> 02:39:52.800
            Azure portal section to review this data. Here are the steps for installing configuring and

            02:39:52.800 --> 02:39:58.720
            synchronizing on premises Active Directory with Azure AD using Azure AD Connect. Why install

            02:39:58.720 --> 02:40:03.840
            Azure AD Connect install Azure AD Connect on a server connected to both on premises a D and Azure

            02:40:03.840 --> 02:40:10.160
            AD to configure Azure AD Connect use the wizard to set up synchronization settings source target

            02:40:10.160 --> 02:40:16.640
            directories and sync frequency. Three synchronized directories Azure AD Connect syncs on premises a D

            02:40:16.640 --> 02:40:23.040
            with Azure AD replicating changes from source to target for monitor and manage continuously monitor

            02:40:23.040 --> 02:40:28.720
            and manage the synchronization process to ensure accuracy and meet business needs. Overall, Azure

            02:40:28.720 --> 02:40:34.000
            AD Connect is your bridge between the on premises world and Azure it ensures a synchronized coherent

            02:40:34.000 --> 02:40:44.160
            and seamless experience. The next topic we'll be covering is Azure AD application proxy.

            02:40:44.160 --> 02:40:49.440
            Azure AD application proxy is a service provided by Microsoft Azure that allows organizations to

            02:40:49.440 --> 02:40:54.720
            provide remote access to their on premises web applications. It allows users to access the

            02:40:54.720 --> 02:40:59.200
            application securely from anywhere using any device without the need for complex network

            02:40:59.200 --> 02:41:04.160
            configuration or exposing the applications directly to the internet. Organizations can

            02:41:04.160 --> 02:41:09.680
            publish their on premises applications to the cloud providing secure remote access for their users.

            02:41:09.680 --> 02:41:14.880
            The service allows organizations to use their existing on premises infrastructure and application

            02:41:14.880 --> 02:41:20.000
            architecture while leveraging the benefits of the cloud. It provides advanced security features such

            02:41:20.000 --> 02:41:24.880
            as multi-factor authentication and conditional access policies ensuring that only authorized

            02:41:24.880 --> 02:41:31.040
            users can access the applications. The Azure AD application proxy service consists of two main

            02:41:31.040 --> 02:41:36.560
            components. While in Azure AD application proxy connector a lightweight agent that is installed

            02:41:36.560 --> 02:41:42.000
            on a server within the organization's on premises environment. The connector establishes a secure

            02:41:42.000 --> 02:41:46.880
            outbound connection to the Azure AD application proxy service which enables communication between

            02:41:46.880 --> 02:41:53.120
            the on premises application and the Azure AD service. To Azure AD application proxy service

            02:41:53.120 --> 02:41:57.040
            a cloud-based service that manages the authentication and authorization of users

            02:41:57.040 --> 02:42:01.600
            who access the on premises web applications through the application proxy connector. It

            02:42:01.600 --> 02:42:06.560
            also routes traffic to the appropriate backend servers and enforces policies set by the organization.

            02:42:06.560 --> 02:42:12.800
            Next let's look at the Azure AD application proxy architecture. Here's an image of the process and

            02:42:12.800 --> 02:42:18.720
            we'll go through each step. Why user access? The user accesses the application and gets redirected

            02:42:18.720 --> 02:42:24.960
            to Azure AD for sign in. Any set conditional access policies are checked. Two, token issuance.

            02:42:24.960 --> 02:42:31.200
            After successful sign in Azure AD sends a token to the user's device. Three, token interpretation.

            02:42:31.200 --> 02:42:36.160
            The client sends this token to application proxy which extracts the user principal name and security

            02:42:36.160 --> 02:42:42.160
            principal name. Four, request forwarding. Application proxy forwards the request to the connector

            02:42:42.160 --> 02:42:48.480
            installed on premises. Five, additional authentication. Optionally the connector may perform additional

            02:42:48.480 --> 02:42:54.400
            authentication and then sends the request to the on premises application. Six, server response. The

            02:42:54.400 --> 02:42:58.640
            application's response is sent back through the connector to the application proxy service.

            02:42:58.640 --> 02:43:04.880
            Seven, response delivery. Finally the application proxy service delivers the response to the user's

            02:43:04.880 --> 02:43:11.920
            device. Next we'll go over some of the use cases for Azure AD application proxy. Remote access.

            02:43:11.920 --> 02:43:16.800
            Azure AD application proxy is commonly used to provide secure remote access to on-premise

            02:43:16.800 --> 02:43:21.680
            applications. Employees working from home or other remote locations can securely access their

            02:43:21.680 --> 02:43:27.120
            internal applications just as if they were in the office. Single sign-on. Application proxy can

            02:43:27.120 --> 02:43:32.080
            integrate with Azure AD to provide single sign-on capabilities. This allows users to authenticate

            02:43:32.080 --> 02:43:37.600
            once and then access multiple applications without needing to sign in again. Conditional access. With

            02:43:37.600 --> 02:43:42.640
            application proxy you can leverage Azure AD's conditional access policies for your on-premise

            02:43:42.640 --> 02:43:48.400
            applications. This provides granular control over access based on user location, device status,

            02:43:48.400 --> 02:43:53.600
            and other factors. Legacy application modernization. Application proxy can help

            02:43:53.600 --> 02:43:58.880
            organizations expose legacy on-premise applications to the internet in a secure manner without changing

            02:43:58.880 --> 02:44:03.680
            the application code. This can be a key part of a strategy to modernize legacy applications.

            02:44:03.680 --> 02:44:09.360
            Scalability and performance. Azure AD application proxy scales automatically to meet your

            02:44:09.360 --> 02:44:13.680
            organization's usage patterns and provides a global reach without needing to open additional

            02:44:13.680 --> 02:44:18.240
            firewall ports. This can help improve the performance and availability of your applications.

            02:44:18.240 --> 02:44:23.440
            In conclusion, Azure AD application proxy is like a security guard and a bridge,

            02:44:23.440 --> 02:44:27.360
            ensuring that your on-premises applications are both accessible and protected.

            02:44:27.360 --> 02:44:30.240
            Be sure to know this as it'll definitely appear on the exam.

            02:44:35.520 --> 02:44:39.760
            Hey, this is Andrew Brown from exam Pro and in this section we'll be going over storage

            02:44:39.760 --> 02:44:44.800
            accounts in Azure. Azure storage offers several types of storage accounts, each with different

            02:44:44.800 --> 02:44:49.760
            features and their own pricing models. These storage account types include standard general

            02:44:49.760 --> 02:44:54.800
            purpose v1, which is now considered legacy, standard general purpose v2, blob storage,

            02:44:54.800 --> 02:45:00.160
            block blob storage, and file storage. Storage accounts vary with the following features.

            02:45:00.160 --> 02:45:05.200
            Supported services. Essentially, this answers the question, what can I put in this storage account?

            02:45:05.200 --> 02:45:09.680
            Your options include blob, file, queue, table, disk, and data lake gen2.

            02:45:09.680 --> 02:45:14.240
            Performance tiers. This focuses on the speed of your read and write operations.

            02:45:14.240 --> 02:45:20.000
            Azure offers two tiers, standard and premium. Access tiers. How often do I need quick access

            02:45:20.000 --> 02:45:25.680
            to files? The tiers are hot, cool, archive. Replication. How many redundant copies should

            02:45:25.680 --> 02:45:30.880
            be made and where? Azure provides various replication options including LRS, GRS,

            02:45:30.880 --> 02:45:38.560
            raw GRS, ZRS, GZRS, raw GZRS. Deployment model. Azure has two models, resource manager and classic.

            02:45:38.560 --> 02:45:44.720
            The table details different types of Azure storage accounts, their capabilities, performance tiers,

            02:45:44.720 --> 02:45:50.480
            access tiers, replication methods, and deployment models. Type. This column describes the different

            02:45:50.480 --> 02:45:55.520
            types of storage accounts. General purpose v2. This is the latest version of Azure storage

            02:45:55.520 --> 02:46:01.600
            accounts and supports various services like blob, file, queue, table, disk, and data lake gen2.

            02:46:01.600 --> 02:46:06.800
            General purpose v1. This is the older version and supports blob, file, queue, table, and disk.

            02:46:06.800 --> 02:46:13.120
            Block blob storage. Designed for storing block blobs and append blobs. File storage. Specifically

            02:46:13.120 --> 02:46:18.560
            tailored for Azure file shares. Blob storage. Meant for storing block and append blobs.

            02:46:18.560 --> 02:46:21.760
            Service. These are the storage services each account type can provide.

            02:46:22.320 --> 02:46:27.600
            Performance tiers. Azure offers two performance tiers. Standard. Backed by hard disk drives and

            02:46:27.600 --> 02:46:32.800
            suitable for general purpose storage. Premium. Uses solid state drives and is optimized for

            02:46:32.800 --> 02:46:38.800
            high performance and low latency workloads. Access tiers. These define the data access frequency.

            02:46:38.800 --> 02:46:44.400
            Hot. For frequently accessed data. Tool. Optimized for storing infrequently accessed data for a

            02:46:44.400 --> 02:46:50.240
            minimum of 30 days. Archive. For rarely accessed data with a minimum of 180 days storage duration.

            02:46:50.800 --> 02:46:55.520
            Replication. Azure provides multiple replication options for ensuring data durability and

            02:46:55.520 --> 02:47:01.200
            availability. LRS. Locally redundant storage stores multiple copies of your data in a single

            02:47:01.200 --> 02:47:06.480
            data center. GRS. Geo redundant storage replicates your data to a secondary region.

            02:47:06.480 --> 02:47:12.240
            Raw GRS. Read access geo redundant storage offers read only access to the data in the secondary

            02:47:12.240 --> 02:47:18.480
            location in addition to geo replication. ZRS. Zone redundant storage spreads data across multiple

            02:47:18.480 --> 02:47:24.960
            availability zones. GZRS. Geo zone redundant storage combines both ZRS and GRS by spreading

            02:47:24.960 --> 02:47:31.200
            data across availability zones and replicating to a secondary region. Raw GZRS. Like GZRS but

            02:47:31.200 --> 02:47:36.480
            with read access to the secondary region. Deployment models. Resource manager. This is

            02:47:36.480 --> 02:47:41.040
            Azure's modern deployment model. It allows you to group related resources together for easier

            02:47:41.040 --> 02:47:46.080
            management. Classic. The older deployment model that existed before the introduction of the Azure

            02:47:46.080 --> 02:47:52.160
            Resource Manager. Lastly, let's explore the five core services Azure provides in the storage domain.

            02:47:52.160 --> 02:47:58.400
            Azure Blob. A massively scalable object store for text and binary data. Also includes support for

            02:47:58.400 --> 02:48:04.320
            big data analytics through data lake storage gen 2. Azure Files. Managed file shares for cloud or

            02:48:04.320 --> 02:48:10.160
            on-premises deployments. Azure Queues. A messaging store for reliable messaging between application

            02:48:10.160 --> 02:48:17.120
            components. Azure Tables. A NOSQL store for schema less storage of structured data. Azure Disks.

            02:48:17.120 --> 02:48:22.720
            Block level storage volumes for Azure VNs. So that's an introduction to storage accounts in Azure.

            02:48:22.720 --> 02:48:33.280
            The next topic we'll be exploring is Azure Blob storage in more detail. Blob storage is an object

            02:48:33.280 --> 02:48:38.000
            store that is optimized for storing massive amounts of unstructured data. Unstructured data

            02:48:38.000 --> 02:48:43.360
            is data that doesn't adhere to a particular data model or definition such as text or binary data.

            02:48:43.360 --> 02:48:48.320
            Azure Blobs are composed of the following core components. Storage account. This is essentially

            02:48:48.320 --> 02:48:53.280
            your unique space or namespace in Azure and it looks something like this. HTTP colon double slash

            02:48:53.280 --> 02:48:59.840
            my storage account dot blob dot core dot windows dot net container. This component functions

            02:48:59.840 --> 02:49:04.800
            similarly to a folder in a file system. Blobs. Here is where the actual data is stored.

            02:49:06.160 --> 02:49:12.080
            Azure Storage supports three types of blobs. One, block blobs. These are ideal for storing text and

            02:49:12.080 --> 02:49:16.560
            binary data. It's made up of blocks of data that can be managed individually and they can store up

            02:49:16.560 --> 02:49:22.880
            to about 4.75 tib of data. Two, append blobs. Specially optimized for append operations.

            02:49:22.880 --> 02:49:28.480
            These are ideal for scenarios such as logging data from virtual machine. Three, page blobs.

            02:49:28.480 --> 02:49:33.200
            Capable of storing random access files up to eight terabytes in size and they are suited for store

            02:49:33.200 --> 02:49:39.280
            virtual hard drive files and service disks for Azure virtual machines. When it comes to transferring

            02:49:39.280 --> 02:49:44.640
            data into Azure Blob Storage, there are multiple methods at your disposal, including as copy and

            02:49:44.640 --> 02:49:49.600
            easy to use command line tool for Windows and Linux. Azure Storage Data Movement Library,

            02:49:49.600 --> 02:49:55.120
            a dot net library that uses as copy in the background. Azure Data Factory, an ETL service

            02:49:55.120 --> 02:50:00.240
            by Azure. Blobviews, this virtual file system driver allows for direct data access through

            02:50:00.240 --> 02:50:06.000
            the Linux file system. Azure Data Box, a robust physical device designed to transport data to

            02:50:06.000 --> 02:50:11.280
            Azure securely. Azure Import/Export Service, a service where you ship your physical disks for

            02:50:11.280 --> 02:50:15.600
            data transfer onto Azure. So that's an overview of Azure Blob Storage.

            02:50:15.600 --> 02:50:24.480
            The next topic we'll be covering are the performance tiers in Blob Storage in a bit more

            02:50:24.480 --> 02:50:29.600
            detail. There are two types of performance tiers for storage accounts, standard and premium.

            02:50:30.080 --> 02:50:34.160
            Before we delve into the details, it's essential to understand the term IOPS.

            02:50:34.160 --> 02:50:39.840
            IOPS stands for input output operations per second. The higher the IOPS, the faster a drive

            02:50:39.840 --> 02:50:45.440
            can read and write. Premium performance tier. In this tier, data is stored on solid state drives.

            02:50:45.440 --> 02:50:49.600
            These drives are optimized for low latency operations, ensuring higher throughput and

            02:50:49.600 --> 02:50:55.600
            speed data access. Some of the ideal use cases include interactive workloads, analytics, AI or

            02:50:55.600 --> 02:51:01.600
            machine learning processes, and data transformation tasks. An SSD has no moving parts and data is

            02:51:01.600 --> 02:51:06.800
            distributed randomly. This is why it can read and write so fast. On the other hand, standard

            02:51:06.800 --> 02:51:11.600
            performance. The standard tier stores data on hard disk drives. These drives offer varied

            02:51:11.600 --> 02:51:17.280
            performance based on the access tier such as hot, cool, or archive. The standard tier shines in the

            02:51:17.280 --> 02:51:22.960
            following use cases, backup and disaster recovery operations, storing media content, and bulk data

            02:51:22.960 --> 02:51:28.880
            processing. An HDD has moving parts, an arm that needs to read and write data sequential to a disk.

            02:51:28.880 --> 02:51:32.480
            It is very good at writing or reading large amounts of data that is close together.

            02:51:32.480 --> 02:51:38.000
            Overall, your choice between premium and standard largely depends on your specific requirements,

            02:51:38.000 --> 02:51:42.960
            whether you prioritize lightning fast data access or more budget friendly voluminous data storage.

            02:51:48.160 --> 02:51:52.800
            Moving on to the next topic, we'll be covering access tiers for blob storage in more detail.

            02:51:52.800 --> 02:51:59.120
            So there are three types of access tiers for standard storage cool, hot and archive. Hot tier

            02:51:59.120 --> 02:52:03.840
            ideal for data that's accessed frequently, it has the highest storage cost, but you get the lowest

            02:52:03.840 --> 02:52:09.840
            access cost. Use cases data that's in active use or expected to be accessed frequently and data

            02:52:09.840 --> 02:52:15.440
            that stage for processing and eventual migration to the cool access tier. Cool tier best for data

            02:52:15.440 --> 02:52:20.160
            that's infrequently accessed and stored for at least 30 days. It has lower storage cost,

            02:52:20.160 --> 02:52:26.000
            but higher access cost. Use case great for short term backup and disaster recovery data sets,

            02:52:26.000 --> 02:52:30.720
            older media content not viewed frequently anymore, but is expected to be available immediately when

            02:52:30.720 --> 02:52:35.280
            accessed and large data sets that need to be stored cost effectively while more data is being

            02:52:35.280 --> 02:52:40.800
            gathered for future processing. Archive tier best for data that's rarely accessed and stored for at

            02:52:40.800 --> 02:52:47.440
            least 180 days. It has the lowest storage cost but the highest access cost. Use case best suited for

            02:52:47.440 --> 02:52:52.800
            long term backup, secondary backup and archival data sets original data that must be preserved

            02:52:52.800 --> 02:52:57.760
            even after it has been processed into final usable form and compliance and archival data that needs

            02:52:57.760 --> 02:53:03.680
            to be stored for a long time and is hardly ever accessed. Before we move on, let's touch upon some

            02:53:03.680 --> 02:53:08.880
            essential technical aspects. Account level tiering any blob that doesn't have an explicitly assigned

            02:53:08.880 --> 02:53:13.760
            tier infers the tier from the storage account access tier setting. Blob level tiering you can

            02:53:13.760 --> 02:53:18.080
            upload a blob to the tier of your choice. Changing tiers happens instantly with the exception from

            02:53:18.080 --> 02:53:23.360
            moving out of archive. Rehydrating a blob when moving a blob out of archive into another tier

            02:53:23.360 --> 02:53:28.720
            it can take several hours. This is known as rehydrating. Blob lifecycle management here you

            02:53:28.720 --> 02:53:34.080
            can create rule based policies to transition data to different tiers such as after 30 days move to

            02:53:34.080 --> 02:53:40.000
            cool storage. When a blob is uploaded or moved to another tier it's charged at the new tiers rate

            02:53:40.000 --> 02:53:44.960
            immediately upon tier change. When moving from a cooler tier the operation is billed as a write

            02:53:44.960 --> 02:53:49.760
            operation to the destination tier where the write operation and data write charges of the destination

            02:53:49.760 --> 02:53:54.560
            tier apply. When moving from a hotter tier the operation is billed as a read from the source

            02:53:54.560 --> 02:53:59.520
            tier where the read operation and data retrieval charges of the source tier apply. Early deletion

            02:53:59.520 --> 02:54:04.640
            charges for any blob moved out of the cool or archive tier may apply as well. Cool and archive

            02:54:04.640 --> 02:54:09.040
            early deletion any blob that is moved into the cool tier is subject to a cool early deletion

            02:54:09.040 --> 02:54:13.760
            period of 30 days. Any blob that is moved into the archive tier is subject to an archive early

            02:54:13.760 --> 02:54:19.680
            deletion period of 180 days. This charge is prorated. So that's a more in-depth look into

            02:54:19.680 --> 02:54:29.440
            the access tiers for blob storage. The next topic we'll be covering is the replication and data

            02:54:29.440 --> 02:54:34.320
            redundancy for storage accounts. So when you create a storage account you need to choose a

            02:54:34.320 --> 02:54:39.760
            replication type. Replication stores multiple copies of your data so that it is protected from

            02:54:39.760 --> 02:54:44.800
            planned events, transient hardware failures, network or power outages, or even massive natural

            02:54:44.800 --> 02:54:50.240
            disasters. Primary region redundancy these include locally redundant storage and zone redundant

            02:54:50.240 --> 02:54:55.760
            storage. Secondary region redundancy this includes geo redundant storage and geo zone redundant

            02:54:55.760 --> 02:55:01.360
            storage. Secondary region redundancy with read access read access geo redundant storage and read

            02:55:01.360 --> 02:55:06.480
            access geo zone redundant storage. As you can expect the greater level of redundancy the more

            02:55:06.480 --> 02:55:12.480
            expensive the cost of replication. For redundancy in the primary region data is replicated three

            02:55:12.480 --> 02:55:16.480
            times in the primary region. There are two options for storing in the primary region.

            02:55:16.480 --> 02:55:23.920
            Locally redundant storage copies data synchronously in primary region 99.9999999999

            02:55:23.920 --> 02:55:30.000
            percent that's 11 nines durability. This is the cheapest option. So redundant storage copies data

            02:55:30.000 --> 02:55:35.440
            synchronously across three az's in primary region 99.9 percent 12 nines durability.

            02:55:35.440 --> 02:55:41.680
            For redundancy in the secondary region data is replicated to a secondary region in case of primary

            02:55:41.680 --> 02:55:46.160
            regional disaster. The secondary region is determined based on your primaries pair region.

            02:55:46.160 --> 02:55:51.760
            Secondary region isn't available for read or write access. Geo redundant storage copies data

            02:55:51.760 --> 02:55:57.520
            synchronously in primary region copies data as synchronously to another region 99.9 percent

            02:55:57.520 --> 02:56:03.760
            that's 16 nines of durability. Geo zone redundant storage similar to GRS but add synchronous

            02:56:03.760 --> 02:56:07.920
            replication across three availability zones in the primary region before as synchronously

            02:56:07.920 --> 02:56:14.000
            replicating to another region maintaining the same 99.9 percent that's 16 9 nines durability level.

            02:56:14.000 --> 02:56:19.920
            Redundancy in the secondary region with read access data is replicated synchronously to

            02:56:19.920 --> 02:56:23.920
            primary region. Your data will be in sync with your primary and you'll have red access.

            02:56:23.920 --> 02:56:28.960
            Read access geo redundant storage ensures synchronous data replication within the

            02:56:28.960 --> 02:56:34.720
            primary region into another region offering a high durability of 99.9 percent with 16 nines.

            02:56:34.720 --> 02:56:40.800
            Read access geo zone redundant storage. This goes a step further by replicating data synchronously

            02:56:40.800 --> 02:56:45.040
            across three availability zones in the primary region before synchronously replicating to

            02:56:45.040 --> 02:56:50.960
            another region maintaining the same high durability level. So choosing the right replication strategy

            02:56:50.960 --> 02:56:55.280
            depends on your business needs weighing costs against data durability and accessibility

            02:56:55.280 --> 02:56:59.680
            and that about covers main points for the replication and data redundancy for storage accounts.

            02:56:59.680 --> 02:57:11.040
            The next topic we'll be exploring is a z copy. So what is a z copy? A z copy is a versatile

            02:57:11.040 --> 02:57:16.160
            command line tool designed specifically for copying blobs or files to or from Azure storage

            02:57:16.160 --> 02:57:20.080
            accounts. It's a go-to utility for many when they think of data transfer with Azure.

            02:57:20.080 --> 02:57:25.360
            While download first things first to get started with a z copy you'll need to download the

            02:57:25.360 --> 02:57:31.360
            executable file compatible with your operating system be it Windows, Linux or Mac OS. Two,

            02:57:31.360 --> 02:57:35.600
            before you begin transferring data ensure you have the necessary level of authorization.

            02:57:35.600 --> 02:57:39.760
            You will need to have the level of authorization via attached roles.

            02:57:39.760 --> 02:57:44.560
            For downloading you'll require the storage blob data reader role. For uploading the roles

            02:57:44.560 --> 02:57:50.160
            necessary are storage blob data contributor and storage blob data owner. Three, you gain access

            02:57:50.160 --> 02:57:56.240
            either via a z copy login. Options for authentication include using Azure Active Directory or a shared

            02:57:56.240 --> 02:58:01.360
            access signature known commonly as SAS. This prompts you to sign in. You'll then be guided to

            02:58:01.360 --> 02:58:07.600
            use a web browser, open a specific page and enter a given code to authenticate. For copying data to

            02:58:07.600 --> 02:58:12.480
            move data use the straightforward copy command a z copy copy. Whether you're uploading or

            02:58:12.480 --> 02:58:17.600
            downloading this command is your gateway to data transfer. So that's a quick summary of how to

            02:58:17.600 --> 02:58:28.000
            utilize a z copy. The next topic we'll be covering is the lifecycle management in Azure storage.

            02:58:28.000 --> 02:58:32.640
            Azure storage lifecycle management offers a rule-based policy that you can use to transition

            02:58:32.640 --> 02:58:37.520
            blob data to the appropriate access tiers or to expire data at the end of the data lifecycle.

            02:58:37.520 --> 02:58:42.960
            With the lifecycle management policy you can transition blobs from cool to hot immediately

            02:58:42.960 --> 02:58:48.880
            when they are accessed to optimize for performance. Transition blobs, blob versions and blob snapshots

            02:58:48.880 --> 02:58:53.360
            to a cooler storage tier if the objects have not been accessed or modified for a period of time to

            02:58:53.360 --> 02:58:59.680
            optimize for cost. Delete blobs, blob versions and blob snapshots at the end of their life cycles.

            02:58:59.680 --> 02:59:05.040
            Define rules to be run once per day at the storage account level and apply rules to containers or to

            02:59:05.040 --> 02:59:11.840
            a subset of blobs using name prefixes or blob index tags as filters. So to manage the life cycle of

            02:59:11.840 --> 02:59:17.120
            our blobs inside containers a lifecycle management rule must be created. Navigate to your Azure

            02:59:17.120 --> 02:59:22.640
            storage account, go to lifecycle management, find and select blob service and click on add a rule.

            02:59:22.640 --> 02:59:27.040
            From here decide whether to may apply this rule to all blobs inside the storage account or filter

            02:59:27.040 --> 02:59:32.400
            the blobs to have this rule applied in this storage account. For example if base blobs were

            02:59:32.400 --> 02:59:37.760
            last modified for more than one day ago then delete the blob. For example if base blobs were

            02:59:37.760 --> 02:59:42.800
            last modified from than one day ago then delete the blob. If base blobs were last modified more

            02:59:42.800 --> 02:59:48.160
            than two days ago then move to cool storage. Overall Azure storage lifecycle management gives

            02:59:48.160 --> 02:59:52.240
            you automated tools to handle data efficiently as it progresses through its life cycle

            02:59:52.240 --> 02:59:55.280
            balancing between performance needs and cost considerations.

            03:00:00.320 --> 03:00:05.120
            Hey this is Andrew Brown from exam Pro and in this section we'll be covering the Azure SQL

            03:00:05.120 --> 03:00:12.160
            offerings. Let's break them down. SQL Server on Azure VMs provides SQL Server and OS level access

            03:00:12.160 --> 03:00:17.200
            supports various SQL Server and OS versions. This is an ideal choice for migrations and

            03:00:17.200 --> 03:00:23.200
            applications that need direct interaction with the operating system. Managed instances. Single

            03:00:23.200 --> 03:00:29.600
            instance gives SQL Server and OS access for robust needs supports various SQL and OS versions. Best

            03:00:29.600 --> 03:00:35.520
            for isolated SQL workloads needing dedicated resources. Instance pool enables pre-provisioning

            03:00:35.520 --> 03:00:41.120
            of resources for efficient migration. Hosts smaller cost-effective instances. This is a perfect fit if

            03:00:41.120 --> 03:00:45.840
            you're looking to migrate several smaller databases and batches. Suitable for batch migration of

            03:00:45.840 --> 03:00:53.040
            smaller databases. Databases. Single database offers hyperscale storage up to 100 terabytes.

            03:00:53.040 --> 03:00:58.160
            Features demand-based serverless compute. Best for cloud applications needing a fully managed service.

            03:00:58.960 --> 03:01:04.160
            Elastic pool enables resource sharing among databases. Simplifies performance management

            03:01:04.160 --> 03:01:09.280
            with multiple databases. Best for managing and scaling databases with variable usage patterns.

            03:01:09.280 --> 03:01:14.000
            So that's an overview of the Azure SQL offerings. Whether you're migrating,

            03:01:14.000 --> 03:01:18.080
            scaling or starting fresh Azure has a SQL solution tailored for your needs.

            03:01:23.040 --> 03:01:28.880
            Let's talk about Azure SQL databases in more detail. Azure SQL database is a fully managed

            03:01:28.880 --> 03:01:34.240
            relational database service provided by Microsoft Azure. It's a cloud-based database service that

            03:01:34.240 --> 03:01:40.240
            offers a high level of scalability, availability and security. Azure SQL database is based on the

            03:01:40.240 --> 03:01:45.280
            latest version of Microsoft SQL Server and it's designed to handle various workloads ranging from

            03:01:45.280 --> 03:01:50.800
            small web applications to large enterprise workloads. Azure SQL database supports popular

            03:01:50.800 --> 03:01:56.880
            relational database engines such as SQL Server, MySQL and PostgreSQL and offers a variety of

            03:01:56.880 --> 03:02:02.880
            deployment options including single database and elastic pool. Azure SQL database offers several

            03:02:02.880 --> 03:02:07.040
            benefits that make it a popular choice for businesses looking to migrate their on-premises

            03:02:07.040 --> 03:02:13.680
            databases to the cloud. Some of the key benefits include fully managed service. Azure handles

            03:02:13.680 --> 03:02:18.240
            administrative tasks like patching and backups, freeing businesses to focus on core tasks.

            03:02:18.800 --> 03:02:23.680
            High availability, built-in automatic failover and disaster recovery capabilities ensure data

            03:02:23.680 --> 03:02:29.680
            access even during outages. Scalability, Azure SQL database easily scales resources according

            03:02:29.680 --> 03:02:35.040
            to workload optimizing costs. Security, advanced features like threat protection and data

            03:02:35.040 --> 03:02:41.040
            encryption ensure secure data storage. Integration, Azure SQL database integrates seamlessly with

            03:02:41.040 --> 03:02:47.040
            other Azure services supporting the development of modern data-driven applications. The Azure

            03:02:47.040 --> 03:02:52.000
            SQL database service offers various tiers to cater to a range of requirements and workloads.

            03:02:52.000 --> 03:02:58.320
            Here's a breakdown. Basic tier, this is the most economical tier optimized for lighter database

            03:02:58.320 --> 03:03:03.040
            workloads. It's best for tasks like testing and development as well as for other non-critical

            03:03:03.040 --> 03:03:08.480
            workloads. You can store data up to two gigabytes and it provides five DTUs which stands for

            03:03:08.480 --> 03:03:13.440
            database transaction units that offer a combined measure of compute storage and eo resources.

            03:03:14.160 --> 03:03:19.680
            Standard tier, this tier is designed to handle the majority of database workloads. It's ideal

            03:03:19.680 --> 03:03:24.320
            for business critical production workloads. The storage capacity is up to one terabyte

            03:03:24.320 --> 03:03:31.360
            and it offers a range of 10 to 4000 DTUs. Premium tier, built for mission critical databases,

            03:03:31.360 --> 03:03:36.080
            this tier emphasizes high transactional rates. It's particularly suitable for workloads with

            03:03:36.080 --> 03:03:43.360
            high volume transactions, allows data storage up to four terabytes and it provides 125 to 20,000 DTUs.

            03:03:44.320 --> 03:03:49.600
            General purpose tier, this tier is designed for customers with demanding database workloads.

            03:03:49.600 --> 03:03:54.560
            Fits best for moderate to heavy transactional workloads, offers storage up to four terabytes,

            03:03:54.560 --> 03:04:01.680
            equipped with five to 80 vCores providing robust computational capacity. Hyperscale tier, optimized

            03:04:01.680 --> 03:04:06.960
            for extremely large data volumes, high transaction rates and great concurrency. This tier is the best

            03:04:06.960 --> 03:04:12.960
            fit for large volume of LTP workloads, provides a massive storage capacity of up to 100 terabytes,

            03:04:12.960 --> 03:04:19.920
            provides a compute range of four to 160 vCores. In summary, Azure SQL database offers a comprehensive

            03:04:19.920 --> 03:04:24.240
            set of tiers that cater to everything from lightweight development tasks to high demand,

            03:04:24.240 --> 03:04:28.880
            mission critical applications, ensuring that organizations can pick the perfect blend of cost,

            03:04:28.880 --> 03:04:38.480
            performance and capacity for their needs. The next topic we'll be covering are Azure SQL

            03:04:38.480 --> 03:04:44.080
            database elastic pools. Azure SQL database elastic pools are a simple cost effective

            03:04:44.080 --> 03:04:48.320
            solution for managing and scaling multiple databases that have varying and unpredictable

            03:04:48.320 --> 03:04:53.440
            usage demands. The databases in an elastic pool are on a single server and share a set number of

            03:04:53.440 --> 03:04:59.120
            resources at a set price. The concept of elastic pools refers to a shared pool of resources such

            03:04:59.120 --> 03:05:04.720
            as CPU, memory and storage allocated to a group of databases. This shared set of resources can

            03:05:04.720 --> 03:05:09.040
            be automatically adjusted and distributed among the databases based on their varying demand.

            03:05:09.040 --> 03:05:14.880
            Azure SQL database elastic pools is ideal for businesses with many databases experiencing

            03:05:14.880 --> 03:05:20.560
            varying workloads. Instead of allocating dedicated resources per database, an elastic pool shares

            03:05:20.560 --> 03:05:26.880
            resources across databases for efficient use and cost reduction. Benefits of Azure SQL database

            03:05:26.880 --> 03:05:32.560
            elastic pools. Cost effective, share resources across databases, pay only for what you use.

            03:05:33.200 --> 03:05:38.240
            Performance management resources are auto managed across a pool, no manual adjustment required.

            03:05:38.240 --> 03:05:43.760
            Flexibility and scalability auto scales to meet demand handling traffic spikes smoothly.

            03:05:43.760 --> 03:05:48.800
            Simplified administration, easier management with shared resources across databases.

            03:05:48.800 --> 03:05:52.640
            Use cases for Azure SQL database elastic pools.

            03:05:52.640 --> 03:05:57.600
            SAS providers manage varying customer database activity cost effectively.

            03:05:58.320 --> 03:06:03.600
            Development and test environments efficient, less expensive process for regular database setup and

            03:06:03.600 --> 03:06:09.600
            teardown. Businesses with multiple apps optimize resource usage and cost by sharing resources among

            03:06:09.600 --> 03:06:15.520
            databases with varying activity. So that's an overview of Azure SQL database elastic pools.

            03:06:15.520 --> 03:06:24.240
            Next, we'll be exploring Azure SQL managed instance in more detail.

            03:06:24.800 --> 03:06:29.920
            Azure SQL managed instance is a fully managed database service offered by Microsoft Azure

            03:06:29.920 --> 03:06:34.480
            designed to provide an easy migration path for SQL server workloads to Azure.

            03:06:34.480 --> 03:06:39.040
            It provides a managed instance of SQL server in the cloud, allowing you to run your existing

            03:06:39.040 --> 03:06:44.480
            applications with minimal changes. It's built on top of the latest SQL server engine and supports

            03:06:44.480 --> 03:06:49.600
            all its features, including complex queries and user defined functions. It offers various

            03:06:49.600 --> 03:06:55.280
            deployment options, including standalone automatic failover configurations and cross region replication

            03:06:55.280 --> 03:07:01.600
            for disaster recovery. Azure SQL managed instance is ideal for modernizing SQL server workloads,

            03:07:01.600 --> 03:07:06.480
            consolidating multiple SQL server instances and building new cloud native applications.

            03:07:06.480 --> 03:07:13.440
            Some of the main benefits of Azure SQL managed instance include easy migration provides a swift

            03:07:13.440 --> 03:07:18.240
            simple migration path for SQL server workloads to Azure with minimal application changes.

            03:07:18.800 --> 03:07:24.400
            Fully managed Microsoft handles maintenance backups and updates allowing focus on applications.

            03:07:24.400 --> 03:07:29.840
            High availability built in capabilities for automatic failover and disaster recovery ensure

            03:07:29.840 --> 03:07:35.440
            constant application availability. Security offers features like data encryption and threat detection

            03:07:35.440 --> 03:07:41.600
            for data protection. Performance supports large databases, high transaction rates and low latency

            03:07:41.600 --> 03:07:46.960
            queries. Integration seamlessly integrates with other Azure services for easy cloud native

            03:07:46.960 --> 03:07:54.080
            application deployment. Azure SQL managed instance has two service tiers. General purpose. This tier

            03:07:54.080 --> 03:07:59.440
            is for light to medium IO applications using local storage and providing an economical and scalable

            03:07:59.440 --> 03:08:04.160
            option suitable for small and medium sized businesses needing an affordable cloud option.

            03:08:04.160 --> 03:08:09.760
            Business critical. This tier is for high IO applications offering high availability,

            03:08:09.760 --> 03:08:15.680
            automatic failover and premium storage. Ideal for mission critical applications in large enterprises

            03:08:15.680 --> 03:08:19.120
            ensuring high performance, availability and durability.

            03:08:19.120 --> 03:08:22.480
            So that's a brief overview of Azure SQL managed instances.

            03:08:22.480 --> 03:08:32.960
            The next topic will be covering is database scalability. Both Azure SQL database and Azure

            03:08:32.960 --> 03:08:37.200
            SQL managed instance enable you to scale database resources with minimal downtime,

            03:08:37.200 --> 03:08:42.800
            adjusting quickly to workload or traffic changes to dynamically scale database resources. You can

            03:08:42.800 --> 03:08:47.840
            use the following options. Horizontal scaling. This involves adding or removing replicas to

            03:08:47.840 --> 03:08:53.520
            adjust the capacity of your database. Both Azure SQL database and Azure SQL managed instance support

            03:08:53.520 --> 03:08:59.280
            horizontal scaling. Vertical scaling. This involves adjusting the resources allocated to your database

            03:08:59.280 --> 03:09:05.040
            such as CPU or memory. Again, both Azure SQL database and Azure SQL managed instance support

            03:09:05.040 --> 03:09:10.720
            vertical scaling. The exact process for scaling your database resources may vary depending on

            03:09:10.720 --> 03:09:15.680
            which service you are using, but in general the steps are as follows. Determine the resource

            03:09:15.680 --> 03:09:21.200
            needs of your database such as the required CPU and memory and the expected workload or traffic.

            03:09:21.200 --> 03:09:25.520
            Decide on the scaling option that best meets your needs, whether that be horizontal or vertical

            03:09:25.520 --> 03:09:31.120
            scaling. Use the Azure portal, PowerShell or the Azure CLI to configure the scaling settings for

            03:09:31.120 --> 03:09:36.080
            your database. Monitor the performance of your database to ensure that the scaling changes are

            03:09:36.080 --> 03:09:42.480
            providing the expected improvements. The difference between Azure SQL database and Azure SQL managed

            03:09:42.480 --> 03:09:47.920
            instance when it comes to dynamically scaling database resources. Azure SQL database offers

            03:09:47.920 --> 03:09:52.720
            a wide range of service tiers, each with varying levels of performance and capabilities. These

            03:09:52.720 --> 03:09:57.040
            service tiers allow you to choose the level of resources that best meets your needs and to easily

            03:09:57.040 --> 03:10:02.880
            scale up or down as needed. Azure SQL managed instance offers two service tiers, general purpose

            03:10:02.880 --> 03:10:07.040
            and business critical. These service tiers are designed to meet different needs with general

            03:10:07.040 --> 03:10:11.760
            purpose offering a balance of price and performance and business critical offering higher performance

            03:10:11.760 --> 03:10:17.440
            and availability for mission critical workloads. So that's a quick overview of database scalability

            03:10:17.440 --> 03:10:22.480
            focusing mainly on the commonly used Azure SQL database and Azure managed SQL instance.

            03:10:27.520 --> 03:10:33.760
            The next topic we'll be covering is dynamic data masking. Dynamic data masking or DDM in Azure is a

            03:10:33.760 --> 03:10:38.720
            feature that helps prevent unauthorized access to sensitive data. It is a security feature of Azure

            03:10:38.720 --> 03:10:44.240
            SQL database, Azure Synapse Analytics and SQL Server that automatically conceal sensitive data

            03:10:44.240 --> 03:10:53.360
            in the result set of a query. For example, if you have a credit card number stored as 1234567891011121

            03:10:53.360 --> 03:10:58.080
            a dynamic data masking rule might conceal the numbers with all axes except for the ending four

            03:10:58.080 --> 03:11:02.640
            numbers in the query results ensuring most of the data stays protected and away from prying eyes.

            03:11:02.640 --> 03:11:07.920
            Dynamic data masking is useful for scenarios where you want to provide a level of data security

            03:11:07.920 --> 03:11:13.360
            without needing to modify database operations. It's often used in scenarios like reducing the

            03:11:13.360 --> 03:11:18.080
            exposure of sensitive data in your database when users are running reports or analytics,

            03:11:18.080 --> 03:11:22.800
            and preventing accidental exposure of sensitive data, especially when data is being used for

            03:11:22.800 --> 03:11:29.440
            development or testing purposes. Key features. Real-time masking data is masked in real time and

            03:11:29.440 --> 03:11:34.240
            does not affect the underlying data stored in the database. The actual data remains intact and is

            03:11:34.240 --> 03:11:39.120
            not physically changed. Customizable masking patterns. You can define different types of

            03:11:39.120 --> 03:11:43.760
            masks depending on the nature of the data from partially hiding email addresses to fully masking

            03:11:43.760 --> 03:11:48.080
            credit card numbers except the last four digits. The choices are vast and flexible.

            03:11:48.640 --> 03:11:53.440
            Role based access control and masking permissions can be granted to users who need to access the

            03:11:53.440 --> 03:11:58.640
            actual data. Ease of use. Dynamic data masking is simple to set up and doesn't require changes

            03:11:58.640 --> 03:12:04.160
            to the database or applications. Common use cases for dynamic data masking include protecting

            03:12:04.160 --> 03:12:09.040
            personally identifiable information, financial data and other sensitive data types in non

            03:12:09.040 --> 03:12:13.680
            production environments or in applications with user roles that require access to a database,

            03:12:13.680 --> 03:12:18.480
            but not all of its sensitive data. So that's an overview of dynamic data masking.

            03:12:18.480 --> 03:12:28.480
            Azure Storage provides several security and encryption features to ensure the confidentiality,

            03:12:28.480 --> 03:12:34.000
            integrity and availability of your data. Here are some of the key features. Encryption at rest.

            03:12:34.000 --> 03:12:37.920
            Azure Storage automatically encrypts all data at rest using Azure Storage Service

            03:12:37.920 --> 03:12:43.200
            encryption or customer managed keys using Azure Key Vault. Encryption in transit. All data

            03:12:43.200 --> 03:12:48.640
            transfer to and from Azure Storage is encrypted using secure SSL TLS protocols, keeping your data

            03:12:48.640 --> 03:12:54.640
            secure during transmissions. Role based access control. Azure Storage provides RBC which enables

            03:12:54.640 --> 03:12:58.560
            you to grant permissions to users, groups and applications at a fine grained level.

            03:12:58.560 --> 03:13:03.920
            Access keys and shared access signatures. Azure Storage provides two types of authentication

            03:13:03.920 --> 03:13:08.640
            mechanisms for accessing storage accounts, access keys and shared access signatures,

            03:13:08.640 --> 03:13:12.480
            access keys or account keys that allow full access to a storage account while

            03:13:12.480 --> 03:13:16.720
            SAS provides granular access control to specific resources within a storage account.

            03:13:16.720 --> 03:13:22.640
            Azure Private Link enables you to access Azure Storage resources over a private endpoint in

            03:13:22.640 --> 03:13:27.280
            your virtual network. This ensures that traffic between your virtual network and Azure Storage

            03:13:27.280 --> 03:13:33.200
            remains on the Microsoft Azure Backbone Network. Azure Virtual Network Service Endpoints. Azure

            03:13:33.200 --> 03:13:37.840
            Virtual Network Service Endpoints enable you to extend your virtual network to Azure Storage.

            03:13:37.840 --> 03:13:41.840
            Similarly to Azure Private Link, this ensures traffic remains within the confines of the

            03:13:41.840 --> 03:13:48.560
            Microsoft Azure Network. Azure Firewall. This is a managed cloud-based network security service

            03:13:48.560 --> 03:13:53.440
            that protects your Azure Virtual Network resources. You can use Azure Firewall to secure traffic

            03:13:53.440 --> 03:13:59.040
            between your virtual network and Azure Storage. Azure Monitor and Azure Security Center. Azure

            03:13:59.040 --> 03:14:03.680
            Monitor and Azure Security Center provide monitoring and security features for Azure Storage.

            03:14:03.680 --> 03:14:08.400
            Azure Monitor allows you to monitor storage account metrics and logs. Azure Security Center

            03:14:08.400 --> 03:14:13.840
            provides security recommendations and threat detection for Azure Storage. Overall, Azure

            03:14:13.840 --> 03:14:17.920
            Storage isn't just a storage solution, it's a fortress designed to protect your data at all

            03:14:17.920 --> 03:14:22.480
            levels. From encryption mechanisms and access controls to private networking and threat

            03:14:22.480 --> 03:14:32.000
            detection, it's equipped to tackle diverse security challenges. Hey, this is Andrew Brown

            03:14:32.000 --> 03:14:37.360
            from ExamPro and in this section we'll be covering Azure Synapse Analytics. So, Azure Synapse

            03:14:37.360 --> 03:14:42.400
            Analytics is a data warehouse and unified analytics platform. It offers a code-free visual

            03:14:42.400 --> 03:14:48.080
            environment that streamlines and simplifies the building of ETL/ELT processes. It allows for easy

            03:14:48.080 --> 03:14:52.880
            ingestion of data via more than 95 native connectors, ensuring comprehensive access to a

            03:14:52.880 --> 03:14:58.560
            wide variety of data sources. The integration of Apache Spark into Azure Synapse Analytics allows

            03:14:58.560 --> 03:15:04.160
            for the use of TSQL queries across both the data warehouse and Spark engines. TSQL, short for

            03:15:04.160 --> 03:15:10.160
            Transact SQL, is Microsoft's implementation of SQL. It's used to interact with relational databases

            03:15:10.160 --> 03:15:16.720
            in Microsoft SQL Server. In addition, it supports a variety of languages including TSQL, Python,

            03:15:16.720 --> 03:15:21.680
            Scala, Spark SQL, and Net, broadening its accessibility to different developers.

            03:15:21.680 --> 03:15:26.960
            Azure Synapse Analytics is not limited to data warehousing. It's also seamlessly integrated

            03:15:26.960 --> 03:15:31.600
            with both artificial intelligence and business intelligence tools. For instance, it works in

            03:15:31.600 --> 03:15:36.720
            harmony with Azure Machine Learning for AI purposes and leverages Azure Cognitive Services for identity

            03:15:36.720 --> 03:15:41.760
            and access management. Moreover, it integrates effectively with Microsoft Power BI for efficient

            03:15:41.760 --> 03:15:47.760
            data visualization and business intelligence operations. Taking a look at this image, it shows

            03:15:47.760 --> 03:15:52.880
            a simple process of Azure Synapse Analytics. You can ingest data from many data sources,

            03:15:52.880 --> 03:15:58.560
            such as on-premises data, cloud data, SaaS data, or streaming data. The data is stored in object

            03:15:58.560 --> 03:16:04.400
            storage via Data Lake Storage Gen2. You can manage Azure Synapse Analytics via the Synapse Studio

            03:16:04.400 --> 03:16:10.080
            interface. You can output the data to various Azure services, such as Azure Purview, Azure ML,

            03:16:10.080 --> 03:16:17.280
            or Power BI. Let's talk a bit about Synapse SQL, a vital component of this platform. Synapse SQL

            03:16:17.280 --> 03:16:23.120
            is a distributed version of TSQL designed for data warehouse workloads. It extends TSQL to

            03:16:23.120 --> 03:16:28.080
            address streaming and machine learning scenarios. You can use built-in streaming capabilities to

            03:16:28.080 --> 03:16:34.640
            land data from cloud data sources into SQL tables. It integrates AI with SQL by using ML models to

            03:16:34.640 --> 03:16:40.320
            score data using the TSQL predict function. It offers both serverless and dedicated resource

            03:16:40.320 --> 03:16:45.040
            models. For unpredictable workloads that are unplanned or bursty, you can use the always

            03:16:45.040 --> 03:16:50.720
            available serverless SQL endpoint. For predictable workloads, create dedicated SQL

            03:16:50.720 --> 03:16:56.000
            pools to reserve processing power for data stored in SQL tables. And there you have it,

            03:16:56.000 --> 03:17:05.920
            a concise introduction to Azure Synapse Analytics. The next topic we'll be covering is the dedicated

            03:17:05.920 --> 03:17:11.680
            SQL pool and serverless SQL pool. Both are crucial components in the Azure Synapse Analytics suite,

            03:17:11.680 --> 03:17:17.840
            but they serve distinct purposes. Let's break them down. Dedicated SQL pool is essentially a query

            03:17:17.840 --> 03:17:22.880
            service over the data in your data warehouse. The unit of scale is an abstraction of compute power

            03:17:22.880 --> 03:17:27.840
            that is known as a data warehouse unit. Think of DWU as a measure of computational power,

            03:17:27.840 --> 03:17:33.360
            ensuring your database operations run efficiently. Once your dedicated SQL pool is created,

            03:17:33.360 --> 03:17:38.000
            you can import big data with simple poly-based TSQL queries and then use the power of the

            03:17:38.000 --> 03:17:42.720
            distributed query engine to run high performance analytics, ensuring you derive meaningful insights

            03:17:42.720 --> 03:17:48.960
            from your data. On the other hand, serverless SQL pool is a query service over the data in your data

            03:17:48.960 --> 03:17:53.840
            lake. One of the beauties of the serverless paradigm is its adaptability. Scaling is done

            03:17:53.840 --> 03:17:59.040
            automatically to accommodate each query resource requirements. In the world of data, change is the

            03:17:59.040 --> 03:18:03.440
            only constant. Whether you're adding nodes, removing them, or managing failovers, the

            03:18:03.440 --> 03:18:08.880
            serverless SQL pool is resilient. It constantly adapts to ensure every query receives the resources

            03:18:08.880 --> 03:18:15.040
            it needs, guaranteeing successful execution. In essence, if you want power, go with dedicated SQL

            03:18:15.040 --> 03:18:20.960
            pool. If you value adaptability, choose serverless SQL pool. Either way, Azure simplifies your data

            03:18:20.960 --> 03:18:30.800
            operations, making it easy to manage complex tasks. All right, let's dive into Apache Spark

            03:18:30.800 --> 03:18:35.920
            integration within Azure Synapse. Azure Synapse can deeply and seamlessly integrate with Apache

            03:18:35.920 --> 03:18:41.040
            Spark, which is one of the most popular open source big data engine used for data preparation,

            03:18:41.040 --> 03:18:46.560
            data engineering, ETL, and even machine learning tasks. It offers machine learning models with

            03:18:46.560 --> 03:18:52.320
            Spark ML algorithms and Azure ML integration for Apache Spark 3.1 with built-in support for Linux

            03:18:52.320 --> 03:18:57.040
            Foundation Delta Lake. Provides a simplified resource model that frees you from having to

            03:18:57.040 --> 03:19:02.320
            worry about managing clusters. It has a rapid startup process along with aggressive auto scaling

            03:19:02.320 --> 03:19:07.840
            capabilities, ensuring your system adapts swiftly to workload demands. Offers built-in support for

            03:19:07.840 --> 03:19:12.720
            .NET, allowing you to easily incorporate your expertise and existing .NET code within a Spark

            03:19:12.720 --> 03:19:18.800
            application, maximizing efficiency and resource utilization. Now let's talk about Spark in

            03:19:18.800 --> 03:19:23.760
            conjunction with Data Lake and Azure Synapse. Azure Synapse removes the traditional technology

            03:19:23.760 --> 03:19:28.800
            barriers between using SQL and Spark together. You can seamlessly mix and match based on your

            03:19:28.800 --> 03:19:33.840
            needs and expertise. Tables defined on files in the Data Lake are seamlessly consumed by either

            03:19:33.840 --> 03:19:40.960
            Spark or Hive. SQL and Spark can directly explore and analyze Parquet, CSV, TSV, and JSON files

            03:19:40.960 --> 03:19:46.960
            stored in the Data Lake. And you benefit from fast and scalable data loading capabilities between SQL

            03:19:46.960 --> 03:19:53.360
            and Spark databases. Overall, Azure Synapse coupled with Apache Spark offers a powerhouse of tools and

            03:19:53.360 --> 03:19:56.720
            capabilities, making your data operations smoother and more efficient.

            03:19:56.720 --> 03:20:06.160
            Azure Synapse Link is a feature in Azure Synapse Analytics that provides seamless integration and

            03:20:06.160 --> 03:20:10.960
            real-time analytics capabilities between Azure Synapse Analytics and operational data stored in

            03:20:10.960 --> 03:20:16.560
            Azure Cosmos DB. It creates a tight integration between Azure Cosmos DB and Azure Synapse

            03:20:16.560 --> 03:20:21.440
            Analytics, allowing users to explore and analyze their data with no extraction. Transformation

            03:20:21.440 --> 03:20:26.640
            and loading process required no data duplication and no impact on the performance of transactional

            03:20:26.640 --> 03:20:32.400
            workloads. Azure Synapse Link forms a connection between Azure Cosmos DB's transactional database

            03:20:32.400 --> 03:20:37.520
            and Azure Synapse Analytics analytical capabilities. It accomplishes this by creating a real-time

            03:20:37.520 --> 03:20:43.840
            updated columnar-based analytical store within Cosmos DB. Benefits of Azure Synapse Link for

            03:20:43.840 --> 03:20:49.280
            Azure Cosmos DB. Real-time analytics. Azure Synapse Link enables real-time analytics by

            03:20:49.280 --> 03:20:54.160
            allowing direct querying of live operational data in Azure Cosmos DB without impacting its

            03:20:54.160 --> 03:20:59.840
            performance. Operational and analytical data cohesion. It eliminates the need for complex ETL

            03:20:59.840 --> 03:21:04.720
            processes. This simplifies the data architecture as it provides immediate and seamless access to

            03:21:04.720 --> 03:21:10.480
            analyze operational data. Cost efficiency. Azure Synapse Link reduces costs by avoiding the need

            03:21:10.480 --> 03:21:15.120
            for additional storage and compute resources that are typically required for ETL processes.

            03:21:15.920 --> 03:21:20.400
            Increased productivity by removing the need for manual data extraction or synchronization

            03:21:20.400 --> 03:21:24.960
            processes. Azure Synapse Link saves time and increases productivity for data scientists

            03:21:24.960 --> 03:21:30.320
            and developers. Improved data freshness. With Azure Synapse Link, the most up-to-date data

            03:21:30.320 --> 03:21:34.720
            from Azure Cosmos DB can be accessed for analytics and reporting in real-time. This

            03:21:34.720 --> 03:21:41.280
            ensures data freshness and accuracy. So when should you use Azure Synapse Link for Azure Cosmos DB?

            03:21:41.920 --> 03:21:47.440
            You should consider using Azure Synapse Link for Azure Cosmos DB when you are an Azure Cosmos DB

            03:21:47.440 --> 03:21:51.360
            user wanting to conduct analytics, business intelligence, and machine learning on your

            03:21:51.360 --> 03:21:56.720
            operational data. You are currently running analytics or BI on your Azure Cosmos DB operational

            03:21:56.720 --> 03:22:02.720
            data using separate connectors or you are executing ETL processes to transfer operational data into a

            03:22:02.720 --> 03:22:08.400
            distinct analytics system. In such cases, Azure Synapse Link offers a seamless analytics experience

            03:22:08.400 --> 03:22:13.120
            without impacting the performance of your transactional store. However, it's not ideal

            03:22:13.120 --> 03:22:17.360
            if you require traditional data warehouse capabilities like high concurrency, workload

            03:22:17.360 --> 03:22:20.720
            management, and persisting aggregates across multiple data sources.

            03:22:20.720 --> 03:22:31.120
            Hey, this is Andrew Brown from exam Pro and in this section, we'll be covering Azure Data Factory.

            03:22:31.120 --> 03:22:36.480
            Azure Data Factory is essentially a cloud-based managed service that plays a pivotal role in ETL,

            03:22:36.480 --> 03:22:41.840
            ELT, and data integration processes. It acts like a powerhouse, orchestrating data movement and

            03:22:41.840 --> 03:22:47.280
            transforming data seamlessly on a large scale. Here's a breakdown. You can create pipelines to

            03:22:47.280 --> 03:22:51.680
            schedule data-driven workflows, making data transformation and integration hassle-free.

            03:22:51.680 --> 03:22:57.280
            Build complex ETL processes that transform data visually with data flows. This means you can

            03:22:57.280 --> 03:23:02.640
            transform data in a more intuitive and visually appealing way. Use compute services such as Azure

            03:23:02.640 --> 03:23:08.720
            HD Insight Hadoop, Azure Databricks, and Azure SQL Database, thus offering flexibility and power in

            03:23:08.720 --> 03:23:13.600
            how you handle your data. Once your data has undergone transformation, you can publish your

            03:23:13.600 --> 03:23:18.000
            transformed data to data stores such as Azure Synapse Analytics, which can store and derive

            03:23:18.000 --> 03:23:23.120
            meaningful insights. Azure Data Factory has the ability to turn raw data into organized,

            03:23:23.120 --> 03:23:27.200
            meaningful data stores and data lakes ready for further analysis and reporting.

            03:23:27.200 --> 03:23:30.640
            So that's a quick introduction to Azure Data Factory.

            03:23:31.040 --> 03:23:35.040
            [MUSIC]

            03:23:35.040 --> 03:23:39.760
            The next topic we'll be covering are the core components. Let's dive into each one and understand

            03:23:39.760 --> 03:23:45.280
            their significance. Pipelines. Think of these as the assembly lines of your data factory. A pipeline

            03:23:45.280 --> 03:23:50.000
            is a logical grouping of activities that performs a unit of work. It orchestrates and automates the

            03:23:50.000 --> 03:23:56.000
            flow of data. Activities. These are the specific tasks within a pipeline. An activity is essentially

            03:23:56.000 --> 03:24:00.320
            a processing step in a pipeline. The action items are the workstages in your pipeline.

            03:24:00.320 --> 03:24:04.880
            Data sets. These represent the data structures or the blueprints within the data store.

            03:24:04.880 --> 03:24:09.920
            Link services. They define the connection information necessary for data factory to

            03:24:09.920 --> 03:24:15.840
            access external resources like your data sources. Data flows. Data flows define how data moves

            03:24:15.840 --> 03:24:20.560
            through a pipeline or undergoes transformation, offering a visual representation of data's journey

            03:24:20.560 --> 03:24:25.840
            and manipulations. Integration runtimes. This is the engine under the hood. The integration

            03:24:25.840 --> 03:24:30.480
            runtimes are the compute infrastructure used by Azure Data Factory to facilitate the data movements

            03:24:30.480 --> 03:24:36.000
            and compute processes. Control flow. The control flow orchestrates the sequence of activities in

            03:24:36.000 --> 03:24:40.400
            a pipeline. It determines how activities are chained, ordered, or branched, ensuring the

            03:24:40.400 --> 03:24:45.680
            systematic flow and processing of data. In a nutshell, these seven components are the backbone

            03:24:45.680 --> 03:24:50.400
            of Azure Data Factory. They work harmoniously, ensuring your data is efficiently moved,

            03:24:50.400 --> 03:24:59.840
            transformed, and processed. The next topic we'll cover in Azure Data Factory is the data

            03:24:59.840 --> 03:25:05.520
            orchestration process. Data ingestion. Data is ingested from a variety of data sources.

            03:25:05.520 --> 03:25:10.640
            This could be on-premises SQL server databases, external data, or any other supported data

            03:25:10.640 --> 03:25:15.920
            sources. ADF supports a wide range of connectors that can be used to pull data from these sources.

            03:25:15.920 --> 03:25:19.760
            Data can be ingested in batch or real-time modes depending on the requirements.

            03:25:19.760 --> 03:25:25.200
            Data storage and transformation. After data ingestion, it's often stored in an intermediate

            03:25:25.200 --> 03:25:30.160
            storage for processing. This could be Azure Blob Storage, which is a scalable object storage for

            03:25:30.160 --> 03:25:34.640
            unstructured data. For more structured analytics-ready data, Azure Synapse Analytics,

            03:25:34.640 --> 03:25:39.920
            which is an analytics service, can be used. At this stage, ADF pipelines can transform data by

            03:25:39.920 --> 03:25:45.600
            cleaning, shaping, and enriching it using mapping data flows. Analysis. Once the data is ready,

            03:25:45.600 --> 03:25:50.640
            it's then loaded into a data model for analysis. This is where Azure Analysis services come in.

            03:25:50.640 --> 03:25:54.960
            It allows you to build semantic models on your data, which provide a consolidated view of your

            03:25:54.960 --> 03:25:59.760
            business data and support high-performance reporting and analytics. Visualization. The

            03:25:59.760 --> 03:26:04.880
            data model can then be used by reporting tools like Power BI to create visualizations, dashboards,

            03:26:04.880 --> 03:26:10.080
            and reports that provide actionable business insights. Security and authentication. Throughout

            03:26:10.080 --> 03:26:15.360
            this process, Azure Active Directory is used for authenticating and authorizing users. It provides

            03:26:15.360 --> 03:26:20.160
            identity and access management services, ensuring that only authorized users have access to your

            03:26:20.160 --> 03:26:25.120
            resources and data. And there you have it. That's an overview of the data orchestration process in

            03:26:25.120 --> 03:26:30.480
            Azure Data Factory. From raw data to insightful visualizations, all while being securely guarded.

            03:26:31.280 --> 03:26:35.280
            [MUSIC]

            03:26:35.280 --> 03:26:41.440
            The next topic we'll be covering is Microsoft SQL Server Integration Services, commonly known as SSIS.

            03:26:41.440 --> 03:26:47.120
            Microsoft SQL Server Integration Services is a platform for building enterprise-level data

            03:26:47.120 --> 03:26:53.840
            integration and data transformation solutions. SSIS can be used to automate SQL Server databases.

            03:26:53.840 --> 03:26:57.840
            Additionally, it can be used as an integration runtime within Azure Data Factory.

            03:26:58.480 --> 03:27:03.680
            You can perform the following tasks with SSIS. Copy or download files, load data into data

            03:27:03.680 --> 03:27:08.960
            warehouses, cleansing data for better accuracy, dive into data mining, and managing SQL Server

            03:27:08.960 --> 03:27:15.520
            objects and data. SSIS can perform ELT with a variety of sources, such as XML, flat files,

            03:27:15.520 --> 03:27:21.520
            and relational data sources. SSIS has built-in tasks and transformations, graphical tools for

            03:27:21.520 --> 03:27:27.200
            building packages, an integration services catalog database where you store, run, and manage packages.

            03:27:28.000 --> 03:27:32.320
            You can use the graphical integration services tools to integrate and transform data without

            03:27:32.320 --> 03:27:37.920
            having to write code. SSIS Designer is a graphical tool that you can use to create and maintain

            03:27:37.920 --> 03:27:42.880
            integration services packages. Picture a canvas where you lay out your data operations, all with

            03:27:42.880 --> 03:27:49.280
            simple drag and drop functionalities. Here is an image that outlines the SSIS Designer in action

            03:27:49.280 --> 03:27:55.200
            with a data task flow example. SSIS allows you to drag out data transformations with a variety of

            03:27:55.200 --> 03:28:00.960
            common tasks, such as aggregate, merge, lookup, and many more. And here you can design different

            03:28:00.960 --> 03:28:07.040
            kinds of control or data flows. So that sums up our overview on Microsoft SQL Server integration

            03:28:07.040 --> 03:28:16.320
            services. Next, we'll quickly go through the pricing tiers of Azure Databricks so you can

            03:28:16.320 --> 03:28:21.200
            get a better understanding of which one is best for your workload. Azure Databricks offers two

            03:28:21.200 --> 03:28:27.040
            pricing tiers, premium and standard. Here's what each tier brings to the table. Premium SKU, the

            03:28:27.040 --> 03:28:31.200
            premium tier offers a full set of advanced Databricks features such as role-based access

            03:28:31.200 --> 03:28:36.080
            control, integration with Azure Active Directory for identity management, and Databricks Delta

            03:28:36.080 --> 03:28:40.640
            Engine, which is a high performance engine for large scale data lakes. It is the most appropriate

            03:28:40.640 --> 03:28:45.360
            for big data analytics workloads and organizations requiring advanced security and team-based

            03:28:45.360 --> 03:28:51.360
            workflows. Standard SKU, the standard tier offers a subset of the Databricks platform features and

            03:28:51.360 --> 03:28:56.240
            is more cost effective for smaller workloads or development and test environments. It includes

            03:28:56.240 --> 03:29:00.800
            the basic Databricks runtime in the collaborative workspace but does not include role-based access

            03:29:00.800 --> 03:29:06.400
            control or Azure AD integration. So that's an overview of the pricing tiers of Azure Databricks.

            03:29:06.400 --> 03:29:12.320
            Hey, this is Andrew Brown from exam Pro. And in this section, we're delving into Azure Databricks,

            03:29:12.320 --> 03:29:16.000
            a game changer in the world of big data and artificial intelligence solutions.

            03:29:16.000 --> 03:29:21.280
            Azure Databricks is an Apache Spark based analytics platform optimized for the Microsoft

            03:29:21.280 --> 03:29:26.400
            Azure Cloud Services platform. It's designed to simplify the process of building big data

            03:29:26.400 --> 03:29:31.280
            and artificial intelligence solutions by providing a unified analytics platform that accelerates the

            03:29:31.280 --> 03:29:37.520
            preparation of data for analytics and machine learning. Key features, collaborative environment,

            03:29:37.520 --> 03:29:41.920
            Azure Databricks provides a shared workspace for collaboration among data professionals.

            03:29:41.920 --> 03:29:46.160
            It facilitates dashboard creation and project sharing across various languages.

            03:29:46.160 --> 03:29:51.200
            Azure integration as a native service, it integrates smoothly with Azure services like

            03:29:51.200 --> 03:29:56.320
            data factory, synapse analytics, machine learning and power bi simplifying analytics pipeline

            03:29:56.320 --> 03:30:02.480
            creation. Apache Spark integration, it incorporates an optimized runtime for superior performance,

            03:30:02.480 --> 03:30:07.120
            offering a serverless Apache Spark experience with auto configurability and integrated Azure

            03:30:07.120 --> 03:30:12.960
            security, auto scaling and performance. It offers auto scaling and speed optimization for faster

            03:30:12.960 --> 03:30:17.760
            processing of big data workloads scaling to 1000s of nodes and handling diverse workloads.

            03:30:17.760 --> 03:30:23.520
            robust security, it delivers enterprise grade security with data encryption, active directory

            03:30:23.520 --> 03:30:28.320
            integration, role based access control, private network connectivity and industry standard

            03:30:28.320 --> 03:30:35.600
            compliance. Use cases, big data analytics, Azure Databricks can process large volumes of data in

            03:30:35.600 --> 03:30:40.640
            parallel making it suitable for big data processing and analytics. Machine learning,

            03:30:40.640 --> 03:30:45.280
            it provides a platform for preparing data and developing training and deploying machine learning

            03:30:45.280 --> 03:30:50.720
            models. Real time analytics, Azure Databricks support streaming analytics, allowing for real

            03:30:50.720 --> 03:30:56.560
            time insights from data. ETL processes, Azure Databricks can be used for building robust ETL

            03:30:56.560 --> 03:31:02.160
            pipelines, data exploration and visualization. The collaborative workspace in Azure Databricks

            03:31:02.160 --> 03:31:07.120
            allows for data exploration and visualization, enabling data scientists and analysts to derive

            03:31:07.120 --> 03:31:11.920
            insights from data. Just to recap the key differences, Azure Databricks focuses on

            03:31:11.920 --> 03:31:16.320
            analytics, big data and machine learning while Azure Data Factory primarily handles

            03:31:16.320 --> 03:31:18.960
            data integration and pipeline orchestration in the cloud.

            03:31:28.000 --> 03:31:32.400
            Hey, this is Andrew Brown from exam Pro. And in this, but before we delve into the specifics of

            03:31:32.400 --> 03:31:37.840
            Azure Data Lake, let's clarify what a data lake actually is. In simple terms, a data lake is a

            03:31:37.840 --> 03:31:42.640
            centralized and scalable repository capable of storing a vast range of data, including raw,

            03:31:42.640 --> 03:31:47.840
            unstructured and semi structured data. It's designed to accommodate a massive volume of data

            03:31:47.840 --> 03:31:53.600
            commonly utilizing objects referred to as blobs or files as its primary mediums for storage.

            03:31:53.600 --> 03:31:58.000
            Here is a visual of a lake with ones and zeros representing the vast amount of data that it can

            03:31:58.000 --> 03:32:02.640
            accommodate. The processing of this data can be simplified and broken down into a few pivotal

            03:32:02.640 --> 03:32:09.280
            steps. Collect this step involves gathering data from various sources. Transform here data undergoes

            03:32:09.280 --> 03:32:15.360
            transformations or modifications through the usage of ELT or ETL. This process converts the raw data

            03:32:15.360 --> 03:32:21.520
            into a more organized semi structured format ready for further analysis. Distribution this phase makes

            03:32:21.520 --> 03:32:27.600
            the transform data accessible to various programs or API's publish finally data sets are published

            03:32:27.600 --> 03:32:32.880
            to metadata catalogs making it easier for analysts to locate and tap into valuable data resources.

            03:32:32.880 --> 03:32:37.920
            So that sums up a quick introduction to data lakes and the foundational process involved.

            03:32:37.920 --> 03:32:47.120
            Now that we have a solid grasp on what a data lake is, let's delve into the specifics of Azure

            03:32:47.120 --> 03:32:52.160
            data lake. Azure data lake is a highly scalable and secure data lake that allows you to store and

            03:32:52.160 --> 03:32:57.280
            analyze large amounts of data. It is composed of two main components Azure data lake storage and

            03:32:57.280 --> 03:33:02.880
            Azure data lake analytics. Azure data lake storage. This is a massively scalable and secure data lake

            03:33:02.880 --> 03:33:08.000
            that allows you to store all types of data. There are two generations of Azure data lake storage.

            03:33:08.000 --> 03:33:12.640
            Azure data lake storage Gen one it provides a single repository where you can capture data of

            03:33:12.640 --> 03:33:18.480
            any size type and speed without forcing changes to your application as the data scales. Azure data

            03:33:18.480 --> 03:33:23.600
            lake storage Gen two this is a set of capabilities dedicated to big data analytics built on Azure

            03:33:23.600 --> 03:33:28.720
            blob storage. It combines the scalability and cost benefits of object storage with the reliability

            03:33:28.720 --> 03:33:34.080
            and performance of the big data file system capabilities to Azure data lake analytics.

            03:33:34.080 --> 03:33:38.720
            This is an on demand analytics job service that simplifies big data instead of deploying

            03:33:38.720 --> 03:33:43.520
            configuring and tuning hardware you write queries to transform your data and extract valuable

            03:33:43.520 --> 03:33:49.520
            insights. It includes usql a language that unifies the benefits of SQL with the expressive power of

            03:33:49.520 --> 03:33:54.480
            your own code. It also allows you to dynamically scale the resources you need for your jobs making

            03:33:54.480 --> 03:34:00.080
            it cost effective. Azure data lake storage Gen one the first version of data lake storage and

            03:34:00.080 --> 03:34:06.480
            will be retired in 2024. New users should use Gen two Azure data lake storage Gen two data lake

            03:34:06.480 --> 03:34:11.600
            storage is Azure blog storage which has been extended to support big data analytics workloads

            03:34:11.600 --> 03:34:15.440
            designed to handle petabytes of data and hundreds of gigabits of throughput.

            03:34:15.440 --> 03:34:20.240
            In order to efficiently access data data lake storage adds a hierarchical namespace to Azure

            03:34:20.240 --> 03:34:24.560
            blob storage. And there you have it a comprehensive overview of Azure data lake.

            03:34:24.560 --> 03:34:34.400
            Next we'll be exploring Azure data lake storage Gen two in more detail given that the exam will

            03:34:34.400 --> 03:34:39.360
            feature questions asking you to identify the most suitable type of storage for specific scenarios.

            03:34:39.360 --> 03:34:43.360
            It's essential to have a firm grasp on which option is best suited for different tasks.

            03:34:43.360 --> 03:34:48.800
            Azure data lake storage Gen two plays a vital role in Azure data lake by providing a secure

            03:34:48.800 --> 03:34:53.840
            scalable platform to store large data volumes. It is tailored to support high performance analytics

            03:34:53.840 --> 03:34:59.360
            and machine learning operations. Here are some of its core features. Hierarchical namespace

            03:34:59.360 --> 03:35:03.680
            enables organizing and managing data in a hierarchical file and folder structure similar

            03:35:03.680 --> 03:35:08.320
            to traditional file systems, simplifying data organization and transformations.

            03:35:08.320 --> 03:35:13.920
            Scalability designed to handle enormous amounts of data from petabytes to exabytes with high

            03:35:13.920 --> 03:35:18.640
            throughput and low latency. It could also manage high volumes of small writes common in big data

            03:35:18.640 --> 03:35:24.400
            scenarios. Security incorporates Azure Active Directory for identity and access management

            03:35:24.400 --> 03:35:29.280
            role based access control firewall rules and virtual network service endpoints along with

            03:35:29.280 --> 03:35:33.760
            encryption at rest and in transit. It also supports Azure private link, ensuring data

            03:35:33.760 --> 03:35:39.760
            travels over a private network. Cost effectiveness offers low cost storage with lifecycle management

            03:35:39.760 --> 03:35:44.880
            policies that automatically move data to cheaper storage tiers or deleted after a specified period,

            03:35:44.880 --> 03:35:49.920
            lowering costs. Performance provides the high performance computing needed for big data

            03:35:49.920 --> 03:35:54.320
            analytics and allows choosing the best performance characteristics for specific workloads through

            03:35:54.320 --> 03:35:59.840
            its performance tiers. Overall, Azure Data Lake Storage Gen 2 is an extended version of Azure

            03:35:59.840 --> 03:36:04.640
            Blob Storage designed for big data analytics, providing additional capabilities like hierarchical

            03:36:04.640 --> 03:36:14.240
            file systems and fine grained access control. The next topic we'll be covering is the second

            03:36:14.240 --> 03:36:19.680
            core component to Azure Data Lake, which is Azure Data Lake Analytics. Azure Data Lake Analytics

            03:36:19.680 --> 03:36:24.400
            is an on demand analytics job service streamlining the complexities of big data operations.

            03:36:24.400 --> 03:36:29.600
            Instead of going through the cumbersome processes deploying, configuring and tuning hardware,

            03:36:29.600 --> 03:36:35.440
            all you write queries using USQL to transform your data and extract valuable insights effortlessly.

            03:36:35.440 --> 03:36:41.360
            To illustrate its efficiency exporting approximately 2.8 billion rows of TP CDS store sales data,

            03:36:41.360 --> 03:36:46.000
            which is around 500 gigabytes into a CSV format file took less than seven minutes,

            03:36:46.560 --> 03:36:51.440
            and importing a full one terabyte set of source data into Azure Analysis Services by using the

            03:36:51.440 --> 03:36:58.240
            Azure Data Lake connector took less than six hours. Now let's talk a bit about USQL. USQL is a

            03:36:58.240 --> 03:37:02.880
            structured query language included within Data Lake Analytics to perform queries on your data lake.

            03:37:02.880 --> 03:37:07.920
            It's versatile, allowing you to query and combine data from a variety of data sources,

            03:37:07.920 --> 03:37:13.760
            including Azure Data Lake Storage, Azure Blob Storage, Azure SQL DB, Azure SQL Data Warehouse,

            03:37:13.760 --> 03:37:19.280
            and even SQL Server instances running in Azure VMs. For those who like hands on experiences,

            03:37:19.280 --> 03:37:24.400
            you can install Azure Data Lake tools for Visual Studio to perform USQL jobs on your Azure Data

            03:37:24.400 --> 03:37:34.800
            Lake. So that's an overview of Azure Data Lake Analytics. Hey, this is Andrew Brown from exam

            03:37:34.800 --> 03:37:40.080
            pro and in this section we'll be covering is Cosmos DB. But before we talk about Cosmos DB,

            03:37:40.080 --> 03:37:45.760
            it's important to understand the key types of no SQL databases. First up, let's talk about key

            03:37:45.760 --> 03:37:51.280
            value stores. Key value stores are simple and fast, but they generally lack features like

            03:37:51.280 --> 03:37:57.280
            relationships, indexes and aggregation. And a key value store data is stored in pairs where a unique

            03:37:57.280 --> 03:38:02.640
            key is stored alongside a corresponding value. A simple key value store will interpret this data

            03:38:02.640 --> 03:38:08.480
            resembling a dictionary also known as associative arrays or hash. Although this kind of data storage

            03:38:08.480 --> 03:38:13.360
            can resemble tabular data, it doesn't require consistent columns per row making it schema less.

            03:38:13.360 --> 03:38:19.600
            Due to their simple design, they can scale well beyond a relational database. Next, let's explore

            03:38:19.600 --> 03:38:25.520
            what a document store is. A document store is a no SQL database that stores documents as its primary

            03:38:25.520 --> 03:38:31.120
            data structure. These documents can be structured as XML but are more commonly found in JSON or

            03:38:31.120 --> 03:38:36.640
            similar formats. Essentially document stores are a subclass of key value stores but have a more

            03:38:36.640 --> 03:38:41.920
            intricate structure allowing for complex queries and operations. Here's a visual that displays the

            03:38:41.920 --> 03:38:47.760
            components of a document store compared to a relational database. Now let's move on to

            03:38:47.760 --> 03:38:53.120
            understanding graph databases. A graph database is a database composed of a data structure that

            03:38:53.120 --> 03:38:58.560
            uses vertices also known as nodes or dots which form relationship to other vertices through edges,

            03:38:58.560 --> 03:39:03.200
            arcs or lines. This type of database is particularly powerful for mapping relationships

            03:39:03.200 --> 03:39:09.200
            and identifying patterns. Use cases for graph database fraud detection, real time recommendation

            03:39:09.200 --> 03:39:14.000
            engines, master data management, network and operations, identity and access management,

            03:39:14.000 --> 03:39:21.280
            traceability and manufacturing, contact tracing, data lineage for GDPR, customer 360 degree analysis,

            03:39:21.280 --> 03:39:26.800
            product recommendations, social media graphing and feature engineering. The nodes can contain

            03:39:26.800 --> 03:39:32.240
            data properties while the edges can hold relational data including directional information and other

            03:39:32.240 --> 03:39:37.600
            data properties. So that's an overview of three key types of no SQL databases.

            03:39:37.600 --> 03:39:47.040
            Now that we have a better understanding of the key types of no SQL databases, it's time to

            03:39:47.040 --> 03:39:53.680
            delve into the main topic Cosmos DB. Azure Cosmos DB is a service for fully managed no SQL databases

            03:39:53.680 --> 03:39:59.200
            that are designed to scale and have high performance attributes. Cosmos DB facilitates interaction with

            03:39:59.200 --> 03:40:05.520
            different types of no SQL database engines through distinct API's namely core SQL, a document data

            03:40:05.520 --> 03:40:12.560
            store, Azure Cosmos DB API for MongoDB, another document data store, Azure Table, a key value data

            03:40:12.560 --> 03:40:19.440
            store, Gremlin, a graph data store based on Apache Tinker Pop. These no SQL engines offer two specific

            03:40:19.440 --> 03:40:24.240
            capacities provision throughput where you pay for a guaranteed capacity and serverless where you pay

            03:40:24.240 --> 03:40:30.160
            only for what you use. Cosmos DB shines with its incredibly quick response times and solid support

            03:40:30.160 --> 03:40:34.720
            for scalability. It's a fully managed service meaning Azure takes charge of all automatic

            03:40:34.720 --> 03:40:41.280
            management updates and patches. Main advantages of Azure Cosmos DB integrates with many Azure

            03:40:41.280 --> 03:40:46.320
            services including Azure Functions, Azure Kubernetes services and Azure App Services

            03:40:46.320 --> 03:40:52.560
            integrates with many databases API's like the native core SQL, MongoDB, Cassandra and Gremlin.

            03:40:53.120 --> 03:41:00.080
            Support for multiple development SDK's spanning .NET, Java, Python and Node.js offers a schema

            03:41:00.080 --> 03:41:05.520
            less service with automatic indexing of data ensuring rapid queries, guaranteed uptime SLA

            03:41:05.520 --> 03:41:13.120
            of 99.999% availability, data replication between Azure regions is automatic, data protected with

            03:41:13.120 --> 03:41:18.240
            encryption at rest and role based access and autoscale is provided to handle a variety of

            03:41:18.240 --> 03:41:25.200
            workload sizes. Next, let's talk about Cosmos DB API's. Different types of API's are available

            03:41:25.200 --> 03:41:30.160
            in Azure Cosmos DB to support a wider range of applications. These API's allow data to be

            03:41:30.160 --> 03:41:37.280
            delivered via documents, key value pairs, Y columns or graph data. For new projects, the core SQL API's

            03:41:37.280 --> 03:41:42.800
            are strongly recommended whereas for existing databases, the specific database API is recommended.

            03:41:42.800 --> 03:41:49.680
            The API's are as follows. Core SQL API, the default API for utilizing Azure Cosmos DB and enables data

            03:41:49.680 --> 03:41:56.560
            querying with a language akin to SQL. MongoDB API facilitates communication with MongoDB databases

            03:41:56.560 --> 03:42:01.840
            and document storage. Cassandra API allows interaction with Cassandra using the Cassandra

            03:42:01.840 --> 03:42:07.840
            query language and supports data storage as a partition row store. Azure Table API, a communication

            03:42:07.840 --> 03:42:13.760
            tool for Azure Table storage, it supports indexing in the partition and row keys. Gremlin API helps

            03:42:13.760 --> 03:42:17.680
            in creating a graph based data view that can be queried using graph traversal language.

            03:42:17.680 --> 03:42:20.640
            So that's an introduction to Cosmos DB.

            03:42:20.640 --> 03:42:31.600
            Next up on our agenda is the Cosmos DB Explorer. Cosmos DB Explorer provides a user-friendly web

            03:42:31.600 --> 03:42:36.080
            interface that allows users to delve into and engage with their Cosmos DB accounts. You can

            03:42:36.080 --> 03:42:42.160
            readily access this interface by heading to cosmos.azure.com. Here is a Cosmos DB Core SQL

            03:42:42.160 --> 03:42:46.800
            within Cosmos DB Explorer adding a document to the database which is very straightforward.

            03:42:46.800 --> 03:42:51.520
            It's worth noting that when you journey through Azure to access a Cosmos DB account under the

            03:42:51.520 --> 03:42:55.680
            Data Explorer section, you're essentially interacting with the same interface as Cosmos

            03:42:55.680 --> 03:43:01.040
            DB Explorer. Furthermore, the versatility of Cosmos DB Explorer shines through with its

            03:43:01.040 --> 03:43:05.760
            compatibility with other database types. For example, its seamless integration with a graph

            03:43:05.760 --> 03:43:10.400
            database using Gremlin. So that's a quick overview of Cosmos DB Explorer.

            03:43:10.400 --> 03:43:21.040
            The next topic we'll be covering is partitioning schemas in Cosmos DB. Partitioning in Azure Cosmos

            03:43:21.040 --> 03:43:26.880
            DB plays a pivotal role in optimizing performance. Data in Cosmos DB indexes is strategically grouped

            03:43:26.880 --> 03:43:32.080
            by partition keys, ensuring quick and efficient data access. Main concepts of partitioning

            03:43:32.080 --> 03:43:37.680
            schemas in Azure Cosmos DB partition keys, think of these as the backbone of partitioning. They are

            03:43:37.680 --> 03:43:42.480
            the keys used to group items together and can be likened to primary keys in relational databases.

            03:43:42.480 --> 03:43:46.240
            Essentially, they dictate how data is divided and organized within the system.

            03:43:46.240 --> 03:43:51.120
            A logical partition is a group of items that all have the same partition key value.

            03:43:51.120 --> 03:43:57.040
            Physical partitions consists of a set of logical partitions. Azure Cosmos DB manages logical

            03:43:57.040 --> 03:44:02.160
            partitions, which can have one too many. replica sets are made up of a group of physical partitions

            03:44:02.160 --> 03:44:06.560
            that are materialized as a self managed, dynamically load balanced group of replicas

            03:44:06.560 --> 03:44:12.400
            that span across multiple fault domains. Each physical partition is not alone, it has a set

            03:44:12.400 --> 03:44:17.840
            of clones or replicas. This set of replicas is what we refer to as a replica set. replicas ensure

            03:44:17.840 --> 03:44:23.360
            data durability, availability and consistency. Logical partitions are mapped to physical

            03:44:23.360 --> 03:44:27.920
            partitions and these physical entities are then spread globally ensuring data availability and

            03:44:27.920 --> 03:44:33.600
            low latency access across regions. To clarify the term in the image, a partition set refers

            03:44:33.600 --> 03:44:38.240
            to a collection of physical partitions. These partitions collectively manage the same logical

            03:44:38.240 --> 03:44:43.760
            partition keys and they ensure this consistent management across multiple regions. In essence,

            03:44:43.760 --> 03:44:48.000
            Cosmos DB's partitioning architecture is meticulously designed for scalability,

            03:44:48.000 --> 03:44:53.040
            fault tolerance and optimal performance. Whether you're considering logical or physical partitions,

            03:44:53.040 --> 03:44:58.160
            replica sets or partition keys, each plays a crucial role in ensuring that Cosmos DB remains

            03:44:58.160 --> 03:45:07.840
            one of the most efficient NoSQL databases on the market. The next topic we'll be covering is

            03:45:07.840 --> 03:45:13.200
            choosing a partition key. A partition key has two components partition key path and the partition

            03:45:13.200 --> 03:45:19.360
            key value. For example, you can consider an item user ID Andrew works for Microsoft. If you choose

            03:45:19.360 --> 03:45:24.800
            user ID as the partition key, the following are the two partition key components. One partition

            03:45:24.800 --> 03:45:29.280
            key path, this would be user ID. This path essentially points to the property in your

            03:45:29.280 --> 03:45:33.840
            data item that holds the partition key value. Alphanumeric characters and underscores are

            03:45:33.840 --> 03:45:37.920
            accepted and you can navigate through nested objects using the standard path notation.

            03:45:37.920 --> 03:45:43.920
            Two partition key value for our example, this is Andrew, it's the specific value found at the

            03:45:43.920 --> 03:45:49.120
            partition key path. This value can be either a string or a number. Your partition key for all

            03:45:49.120 --> 03:45:53.760
            containers should be a property that has a value which does not change. You can't change the value

            03:45:53.760 --> 03:45:58.160
            of a property if it's your partition key, the partition key should have a wide range of possible

            03:45:58.160 --> 03:46:03.920
            values to distribute data and workload uniformly across various logical partitions. Spread requests

            03:46:03.920 --> 03:46:08.800
            you to consumption and data storage evenly across all logical partitions. This ensures even root

            03:46:08.800 --> 03:46:15.120
            consumption and storage distribution across your physical partitions. Let's talk about unique keys.

            03:46:15.120 --> 03:46:20.160
            So unique keys provide developers with the ability to add a layer of data integrity to their database

            03:46:20.160 --> 03:46:24.720
            by creating a unique key policy when a container is created, you ensure the uniqueness of one or

            03:46:24.720 --> 03:46:30.240
            more values per partition key. A unique key is scoped to a logical partition. If you partition

            03:46:30.240 --> 03:46:34.880
            the container based on the zip code, you end up with duplicated items in each logical partition.

            03:46:34.880 --> 03:46:39.520
            It's important to know that you can't update an existing container to use a different unique key.

            03:46:40.160 --> 03:46:45.920
            A unique key policy can have a maximum of 16 path values. Each unique key policy can have a maximum

            03:46:45.920 --> 03:46:51.120
            of 10 unique key constraints or combination. When a container has a unique key policy, request unit

            03:46:51.120 --> 03:46:56.080
            charges to create, update, and delete an item are slightly higher. In addition, unique key names are

            03:46:56.080 --> 03:47:06.960
            case sensitive. The next topic we'll be covering are containers in Cosmos DB. Azure Cosmos containers

            03:47:06.960 --> 03:47:11.920
            are useful for scalability and Azure Cosmos DB, both in terms of storage and throughput.

            03:47:11.920 --> 03:47:16.000
            They are beneficial when you need a different set of configurations for each of your Azure Cosmos

            03:47:16.000 --> 03:47:20.880
            DBs because they allow you to customize each container individually. Some applications may

            03:47:20.880 --> 03:47:26.320
            require robust write capabilities for logging while others prioritize reading due to data access needs

            03:47:26.320 --> 03:47:31.440
            with Cosmos DB containers. Each application could have a customized container that meets its demands

            03:47:31.440 --> 03:47:36.640
            balancing performance and cost. Azure Cosmos container has some container specific properties

            03:47:36.640 --> 03:47:41.440
            and those properties which can be system generated or user configurable vary according on the use

            03:47:41.440 --> 03:47:48.720
            API. And Azure Cosmos container has a set of system defined properties. Depending on which API you use

            03:47:48.720 --> 03:47:53.840
            some properties might not be directly exposed. The table lists various system defined properties

            03:47:53.840 --> 03:47:59.120
            in Cosmos DB and indicates which ones are system generated versus user configurable. Additionally,

            03:47:59.120 --> 03:48:04.240
            it also denotes which properties are used by different APIs for no SQL Cassandra, Manga,

            03:48:04.240 --> 03:48:10.160
            B, Gremlin and table. RID type system generated purpose acts as a unique identifier for a

            03:48:10.160 --> 03:48:17.440
            container supported by only the API for no SQL. E tag type system generated purpose utilized for

            03:48:17.440 --> 03:48:22.320
            optimistic concurrency control. It ensures that only one client can change an item in the database

            03:48:22.320 --> 03:48:29.600
            at a time supported by only the API for no SQL. TS type system generated purpose represents the

            03:48:29.600 --> 03:48:36.240
            timestamp when the container was last updated supported by only the API for no SQL. Self type

            03:48:36.240 --> 03:48:41.280
            system generated purpose provides an addressable URI of the container. It's essentially a unique

            03:48:41.280 --> 03:48:48.320
            reference or link to the container supported by only the API for no SQL. ID type user configurable

            03:48:48.320 --> 03:48:54.000
            purpose denotes the name of the container supported by all the API is listed. There are many more

            03:48:54.000 --> 03:49:03.120
            properties, but we won't be able to list them all here. The next topic we'll be covering are the

            03:49:03.120 --> 03:49:09.280
            capacity of Cosmos DB containers. So what is capacity capacity defines the amount of underlying

            03:49:09.280 --> 03:49:14.720
            resources are available to support consumption of resources such as compute and storage. As we've

            03:49:14.720 --> 03:49:20.720
            briefly touched upon before Cosmos DB has two capacity modes provision throughput and serverless

            03:49:20.720 --> 03:49:25.680
            provision throughput. In this mode, you allocate a specific amount of throughput for your containers.

            03:49:25.680 --> 03:49:30.640
            This throughput is quantified in terms of request units per second. This mode is suitable for

            03:49:30.640 --> 03:49:35.440
            workloads where traffic can be predicted. It offers a high degree of flexibility letting you match

            03:49:35.440 --> 03:49:40.640
            your provision capacity to the expected demand. Serverless this mode is the opposite in its

            03:49:40.640 --> 03:49:45.600
            approach. Instead of provisioning in advance, you simply run database operations without setting any

            03:49:45.600 --> 03:49:50.800
            predetermined capacity. This mode is beneficial for smaller workloads or those that might experience

            03:49:50.800 --> 03:49:55.440
            unpredictable traffic spikes. While it offers the advantage of simplicity and configuration,

            03:49:55.440 --> 03:50:00.640
            there are some inherent limitations to be aware of. When it comes to geo distribution,

            03:50:00.640 --> 03:50:05.120
            the provision throughput option in Cosmos DB offers unlimited multi region support.

            03:50:05.120 --> 03:50:10.960
            In contrast, the serverless option is restricted to a single region. In terms of storage capacity,

            03:50:10.960 --> 03:50:15.440
            while provision throughput allows for unlimited storage per container serverless is capped at 50

            03:50:15.440 --> 03:50:21.600
            gigabytes. Performance wise, both options deliver less than 10 ms latency for point reads. However,

            03:50:21.600 --> 03:50:26.560
            while provision throughput guarantees less than 10 ms latency for rights under its SLA serverless

            03:50:26.560 --> 03:50:32.400
            offers less than 30 ms for rights as covered by its SLO. Regarding billing provision throughput

            03:50:32.400 --> 03:50:37.760
            charges per hour based on the set r us irrespective of actual route consumption. On the other hand,

            03:50:37.760 --> 03:50:42.800
            serverless charges are based on the actual r u s consumed by your operations build on an hourly

            03:50:42.800 --> 03:50:53.200
            basis. Next, we'll delve into the consistency levels in Cosmos DB. These levels play a pivotal

            03:50:53.200 --> 03:50:59.040
            role shaping the availability, latency and accuracy of database operations. Azure Cosmos

            03:50:59.040 --> 03:51:04.080
            DB provides five different consistency levels to maintain data availability and querying performance

            03:51:04.080 --> 03:51:09.360
            depending on your requirements. The consistency levels in Cosmos DB can be visualized as a

            03:51:09.360 --> 03:51:14.400
            spectrum. This ranges from strong to eventual on the strong side, it has higher latency,

            03:51:14.400 --> 03:51:19.440
            lower availability but has worse read scalability. But as you move towards eventual you gain lower

            03:51:19.440 --> 03:51:25.120
            latency, higher availability and better read scalability. Strong linearizability reads are

            03:51:25.120 --> 03:51:30.320
            guaranteed to return the most recent version of an item. bounded staleness consistent prefix

            03:51:30.320 --> 03:51:36.400
            reads lag behind rights by at most k prefixes or t interval session consistent prefix monotonic

            03:51:36.400 --> 03:51:42.000
            reads monotonic rights read your rights right follows reads consistent prefix updates returned

            03:51:42.000 --> 03:51:47.920
            or some prefix of all the updates with no gaps. Eventual out of order reads you set default

            03:51:47.920 --> 03:51:53.680
            consistently at the Cosmo be account level under default consistency blade. Strong consistency

            03:51:53.680 --> 03:51:58.480
            this level guarantees that read operations return the most recent data while it's read costs align

            03:51:58.480 --> 03:52:02.560
            with bounded staleness they are higher than those of session and eventual consistencies.

            03:52:02.560 --> 03:52:06.720
            Furthermore, data written can only be read once the majority of replicas have successfully

            03:52:06.720 --> 03:52:12.080
            replicated it. bounded staleness causes read operations to lag behind rights due to time or

            03:52:12.080 --> 03:52:17.040
            version disparities. Despite having the same read cost as strong consistency, it's pricier than

            03:52:17.040 --> 03:52:22.000
            session and eventual consistencies. It stands out as the most consistent when compared to session

            03:52:22.000 --> 03:52:27.280
            consistent prefix and eventual this level is ideal for globally distributed applications that

            03:52:27.280 --> 03:52:33.760
            prioritize high availability and minimal latency. Session session consistency ensures that data read

            03:52:33.760 --> 03:52:38.320
            within a session matches the most recent right in that session. However, other sessions might see

            03:52:38.320 --> 03:52:42.880
            outdated or dirty data from recent rights and different sessions. It's the default consistency

            03:52:42.880 --> 03:52:47.680
            for new databases. It's recosts fall between those of bounded staleness strong and eventual

            03:52:47.680 --> 03:52:53.280
            consistencies. With consistent prefix read operations fetch the latest data replicated

            03:52:53.280 --> 03:52:58.080
            among replicas, although it may not be the absolute latest situations can arise where dirty

            03:52:58.080 --> 03:53:03.120
            data appears due to changes in one replica that haven't propagated to others. Its consistency is

            03:53:03.120 --> 03:53:08.320
            superior to eventual but trails behind other levels. Eventual consistency offers the least

            03:53:08.320 --> 03:53:13.520
            assurance with no guarantees on immediate data accuracy. However, it boasts the lowest latency,

            03:53:13.520 --> 03:53:17.520
            optimal performance and the most cost effective read operations among all levels.

            03:53:18.320 --> 03:53:21.600
            So that's an overview of the consistency levels in Cosmos DB.

            03:53:21.600 --> 03:53:31.840
            Hey, this is Andrew Brown from exam Pro. And in this section, we'll be covering Azure Redis cache.

            03:53:31.840 --> 03:53:35.920
            But before we talk about Azure Redis cache, we'll need to know what Redis is.

            03:53:35.920 --> 03:53:41.280
            So Redis is an open source and memory database store Redis access caching layer or a very fast

            03:53:41.280 --> 03:53:46.320
            database. Since all data is stored in memory, it's highly volatile, meaning data loss is possible

            03:53:46.320 --> 03:53:51.200
            under certain conditions. Redis is very fast that it can deliver content from its store with single

            03:53:51.200 --> 03:53:56.560
            to double digit milliseconds such as 10 ms. Despite its in memory nature, Redis provides

            03:53:56.560 --> 03:54:00.640
            options for data persistence, allowing you to balance performance with durability,

            03:54:00.640 --> 03:54:04.720
            it can periodically save data snapshots to disk or append each command to a log.

            03:54:04.720 --> 03:54:11.280
            Redis is a key value store and it supports the following data structures, sets and sorted sets

            03:54:11.280 --> 03:54:15.920
            collections of strings in which every item is unique lists a collection of string sorted

            03:54:15.920 --> 03:54:21.280
            according to the order they were inserted. hashes perfect for story objects. These are maps between

            03:54:21.280 --> 03:54:26.640
            string fields and string values. bitmaps and bitfields allow for operations at the bit level

            03:54:26.640 --> 03:54:32.640
            providing extremely efficient storage. Hyper log log a sophisticated algorithm to count unique values.

            03:54:32.640 --> 03:54:37.840
            geospatial indexes grant the ability to manage spatial items and query by position.

            03:54:37.840 --> 03:54:42.640
            streams new and Redis it offers a way to log in real time stream data.

            03:54:42.640 --> 03:54:52.480
            So that's an introduction of Redis. The next topic we'll be covering is Azure cache for Redis.

            03:54:52.480 --> 03:54:57.200
            Azure Redis cache is based on the popular open source Redis cache. It gives you access to a

            03:54:57.200 --> 03:55:01.760
            secure dedicated Redis cache that Microsoft manages and that you can access from any Azure

            03:55:01.760 --> 03:55:07.200
            application. Azure Redis caches and in memory database that caches data in key value pairs.

            03:55:07.200 --> 03:55:11.120
            It helps your application become more responsive even as the customer load increases.

            03:55:11.760 --> 03:55:15.840
            It takes advantage of the Redis engines low latency high throughput capabilities.

            03:55:15.840 --> 03:55:20.240
            This distributed cache layer allows your data tier to scale independently allowing for more

            03:55:20.240 --> 03:55:26.080
            efficient use of your application layers compute resources. Azure Redis cache perfectly complements

            03:55:26.080 --> 03:55:32.000
            Azure database services such as Cosmos DB and Azure SQL. It provides a cost effective solution

            03:55:32.000 --> 03:55:36.880
            to scale read and write throughput of your data tier. Using the cache aside pattern you can store

            03:55:36.880 --> 03:55:42.880
            and share database query results session states static content and more. Azure cache for Redis

            03:55:42.880 --> 03:55:48.720
            stores session state and other data that needs low latency access. Diagram of cache aside pattern on

            03:55:48.720 --> 03:55:53.360
            Azure storage. First we'll need to check the Redis cache to see if your item is available.

            03:55:53.360 --> 03:55:58.880
            If the item is found we'll retrieve it. If the item is not found we'll pull the item from the

            03:55:58.880 --> 03:56:04.240
            table storage, recache it in Redis and then return the results. On the right we have an image that

            03:56:04.240 --> 03:56:09.840
            should clearly explain the workflow overview. Check if cache exists. If true go to step two and

            03:56:09.840 --> 03:56:14.480
            obtain the data. If cache could not be found go to step three and recache the item and return the

            03:56:14.480 --> 03:56:25.200
            results. So that's a summary of Azure cache Redis and how it works. The next topic we'll be covering

            03:56:25.200 --> 03:56:30.880
            are caching expiration policies for Azure Redis cache. Azure Redis caches expiration policies are

            03:56:30.880 --> 03:56:35.760
            configured per each request so we could have an expiration policy different for each cache key.

            03:56:35.760 --> 03:56:41.120
            For Redis distributed cache those expiration policies are as follows. Absolute expiration

            03:56:41.120 --> 03:56:45.600
            relative to now this policy sets the duration for the cache to live counting from the moment the

            03:56:45.600 --> 03:56:50.880
            item is added to the cache. For example if you set this to 10 minutes the cache item will expire 10

            03:56:50.880 --> 03:56:56.320
            minutes after it has been added. Absolute expiration this policy sets a specific date and

            03:56:56.320 --> 03:57:01.280
            time when the cache item will expire. Once that date and time are reached the cache item is evicted

            03:57:01.280 --> 03:57:07.200
            regardless of when it was added. Sliding expiration this policy defines an expiration time relative to

            03:57:07.200 --> 03:57:12.480
            the last access time of the particular cache item. If an item has a sliding expiration of 10 minutes

            03:57:12.480 --> 03:57:17.440
            it will expire if it hasn't been accessed in those 10 minutes. Every time the item is accessed its

            03:57:17.440 --> 03:57:26.240
            expiration timer is reset. So that's a brief summary of the Azure Redis caches expiration policies.

            03:57:26.240 --> 03:57:33.040
            Hey this is Andrew Brown from exam Pro and in this section we'll be covering non-relational

            03:57:33.040 --> 03:57:38.160
            data storage solutions in Azure starting with Azure Table Storage. Azure Table Storage isn't

            03:57:38.160 --> 03:57:43.840
            your regular relational database instead it's a no sql data store for semi-structured data neatly

            03:57:43.840 --> 03:57:48.800
            housed within Azure storage accounts. What makes it particularly appealing especially in today's

            03:57:48.800 --> 03:57:53.520
            fast-paced tech world is its ability to handle vast amounts of unstructured or semi-structured

            03:57:53.520 --> 03:57:59.200
            data without being tied down by a fixed schema. There are two ways to interact with Azure Tables.

            03:57:59.200 --> 03:58:04.240
            The first is Azure Table Storage API a robust tool for developers to seamlessly integrate

            03:58:04.240 --> 03:58:08.880
            query and manage their data. It provides you the flexibility to interact programmatically and

            03:58:08.880 --> 03:58:14.400
            customize according to your application's needs. On the other hand we have Microsoft Azure Storage

            03:58:14.400 --> 03:58:19.440
            Explorer. It offers a user-friendly interface to browse manipulate and manage your data without

            03:58:19.440 --> 03:58:24.080
            writing a single line of code. Think of it as your visual window into the world of Azure Tables.

            03:58:24.080 --> 03:58:29.520
            Here is a visual of Azure Storage Explorer a standalone app that makes it easy to work with

            03:58:29.520 --> 03:58:35.120
            Azure storage data on Windows, Mac OS and Linux. You can create block containers, upload files,

            03:58:35.120 --> 03:58:40.080
            create snapshots of disk and more. So when should you use Azure Table Storage?

            03:58:40.080 --> 03:58:44.880
            Large amounts of semi-structured data if you have massive volumes of semi-structured or

            03:58:44.880 --> 03:58:48.320
            unstructured data but don't need the complexities of a relational database.

            03:58:48.320 --> 03:58:53.840
            Cost-effective storage. Azure Table Storage is a budget-friendly solution especially when compared

            03:58:53.840 --> 03:58:58.480
            to full-fledged databases. It's suitable for projects where low-cost storage is a priority.

            03:58:58.480 --> 03:59:03.360
            Schema flexibility if your application has evolving data structures where the schema can

            03:59:03.360 --> 03:59:07.840
            change over time. The schema-less design of Azure Table Storage offers flexibility.

            03:59:07.840 --> 03:59:13.120
            Scalability requirements for applications that need to scale out by adding more data entities

            03:59:13.120 --> 03:59:19.120
            but don't require complex joins, stored procedures or secondary indexes. And fast access and high

            03:59:19.120 --> 03:59:23.600
            throughput if you need a storage solution with low latency and high availability characteristics

            03:59:23.600 --> 03:59:28.000
            for quick access to data. So that's an overview of Azure Table Storage.

            03:59:32.880 --> 03:59:36.320
            The next topic we'll be covering is adding entries in Azure Table Storage.

            03:59:36.320 --> 03:59:41.840
            When you enter data you must provide a Partition Key. This is a unique identifier for each

            03:59:41.840 --> 03:59:46.640
            partition within a table. This key enables Azure to distribute table data across multiple nodes

            03:59:46.640 --> 03:59:51.280
            for improved data access and load balancing. For instance, you might use the date and time

            03:59:51.280 --> 03:59:56.240
            as a partition key for log data ensuring entries are evenly distributed and easily sorted.

            03:59:56.240 --> 04:00:01.680
            Row Key. This key is a unique identifier within a partition allowing you to pinpoint a specific

            04:00:01.680 --> 04:00:06.800
            entity. It's like the address of your data within the partition. For instance, in a list of customers,

            04:00:06.800 --> 04:00:12.320
            a customer ID could serve as a row key. Azure Table supports a diverse set of data types.

            04:00:12.320 --> 04:00:18.800
            String textual data such as names or addresses. Boolean true or false values. Binary data such

            04:00:18.800 --> 04:00:24.720
            as file or image. Date/time, specific date and time information. Double floating point numbers.

            04:00:25.280 --> 04:00:31.280
            Get global unique identifiers. Int32 and int64 whole numbers both small and large.

            04:00:31.280 --> 04:00:36.560
            When you need to retrieve data you can perform queries using both partition and row keys.

            04:00:36.560 --> 04:00:40.880
            This dual key system allows for robust and flexible data retrieval operations.

            04:00:40.880 --> 04:00:44.960
            For example, if you're looking for a specific transaction in a financial database,

            04:00:44.960 --> 04:00:49.520
            you can use the partition key to narrow down the date and the row key to find the exact transaction.

            04:00:49.520 --> 04:00:54.160
            Azure Table Storage allows you to apply additional filters to your queries.

            04:00:54.160 --> 04:00:58.880
            If you need to find all entries from a specific location or all entries falling under a particular

            04:00:58.880 --> 04:01:01.920
            category, you can easily set up filters to refine your search.

            04:01:01.920 --> 04:01:06.000
            So that's a quick overview of adding entries in Azure Table Storage.

            04:01:06.000 --> 04:01:16.400
            The next topic we'll be covering is Azure QStorage. Azure QStorage is a robust and straightforward

            04:01:16.400 --> 04:01:21.280
            messaging broker that facilitates smooth and secure message exchange between various applications and

            04:01:21.280 --> 04:01:27.360
            services within the Azure environment. Key features. Simple message broker. Azure QStorage

            04:01:27.360 --> 04:01:31.600
            allows services running on cloud infrastructure to communicate with each other asynchronously.

            04:01:31.600 --> 04:01:35.600
            It can handle large numbers of messages simultaneously, ensuring your services

            04:01:35.600 --> 04:01:42.080
            remain highly responsive. Security. Azure QStorage uses authenticated HTTP protocols,

            04:01:42.080 --> 04:01:47.280
            ensuring that data transmission is secure and reliable. Message size. It can hold messages up

            04:01:47.280 --> 04:01:53.760
            to 64 kilobytes in size, accommodating a wide range of data types and sizes. For storage and

            04:01:53.760 --> 04:01:59.200
            access. Storage account. QStorage is stored within an Azure storage account, ensuring a secure

            04:01:59.200 --> 04:02:04.960
            and unified setting for all storage needs. Access keys and connection strings. Utilize the same access

            04:02:04.960 --> 04:02:09.680
            keys and connection strings for QStorage as with other resources in the storage account, ensuring

            04:02:09.680 --> 04:02:14.960
            streamlined and consistent access management. Azure QStorage offers three ways of handling

            04:02:14.960 --> 04:02:19.440
            messages on the queue. Peek. This option allows you to preview a message in the queue without

            04:02:19.440 --> 04:02:24.960
            deleting or locking it. It's useful for determining the next message to process. Delete. After

            04:02:24.960 --> 04:02:29.600
            successfully processing a message, an application will typically delete the message to ensure it

            04:02:29.600 --> 04:02:34.800
            isn't processed again. Receive and lock. By locking a message, it ensures that other parts of the

            04:02:34.800 --> 04:02:39.840
            system can't process the message simultaneously. After processing, the lock is either renewed or

            04:02:39.840 --> 04:02:45.040
            the message is deleted. Azure Portal. Easily create a queue and send messages through the

            04:02:45.040 --> 04:02:51.120
            user-friendly interface of the Azure Portal. Azure SDK or CLI. For more programmatic control,

            04:02:51.120 --> 04:02:55.360
            most interactions with the queue, including sending, peeking, and deleting messages,

            04:02:55.360 --> 04:03:00.640
            can be performed using the Azure SDK or command line interface. Here is a Python example to help

            04:03:00.640 --> 04:03:05.680
            you understand what this looks like. Developers can create queues, add messages, and process them

            04:03:05.680 --> 04:03:10.000
            with just a few lines of code. So that's an overview of Azure QStorage.

            04:03:10.000 --> 04:03:18.640
            The next topic we'll be covering are the key concepts in Azure QStorage.

            04:03:18.640 --> 04:03:22.720
            Queues can be accessed by using the following URL format.

            04:03:22.720 --> 04:03:30.400
            https://storageaccount.q.core.windows.net/queue. The following URL addresses a queue in the diagram.

            04:03:30.400 --> 04:03:37.920
            https://storageaccount.q.core.windows.net/ images to download. Here's a breakdown of the components.

            04:03:37.920 --> 04:03:42.800
            Storage account. A storage account is required for all Azure Storage access. Think of it as your

            04:03:42.800 --> 04:03:48.720
            gateway to Azure Storage services. Queue. A queue contains a set of messages. Keep in mind, the queue

            04:03:48.720 --> 04:03:54.080
            name must be all lowercase. Message. You can store any format of data in a message, but it must not

            04:03:54.080 --> 04:04:01.600
            exceed 64 kilobytes. If for version 20170729, the maximum time to live allowed is seven days. For

            04:04:01.600 --> 04:04:07.760
            version 20170729 or later, the maximum time to live can be any positive number or minus one,

            04:04:07.760 --> 04:04:12.240
            indicating that the message doesn't expire. In addition, the default time to live is seven days

            04:04:12.240 --> 04:04:17.360
            if this parameter is not specified. You can interact with the queue via the Azure CLI

            04:04:17.360 --> 04:04:23.120
            subcommand, a zStorage message action. Clear. Deletes all messages from the specified queue.

            04:04:23.120 --> 04:04:28.000
            Delete. Deletes the specified message. Get. Retrieves one or more messages from the front

            04:04:28.000 --> 04:04:32.800
            of the queue. Keek. Retrieves one or more messages from the front of the queue, but does not alter

            04:04:32.800 --> 04:04:37.360
            the visibility of the message. Put. Adds a new message to the back of the message queue.

            04:04:37.360 --> 04:04:40.800
            Update. Updates the visibility timeout of a message.

            04:04:40.800 --> 04:04:44.560
            So, that's an overview of the key concepts in Azure QStorage.

            04:04:49.520 --> 04:04:54.480
            Hey, this is Andrew Brown from exam Pro. And in this segment, we'll be covering Azure Files.

            04:04:54.480 --> 04:04:59.440
            Azure Files is a fully managed file share in the cloud. A file share is a centralized server

            04:04:59.440 --> 04:05:04.320
            for storage that allows multiple connections. It's like having one big share drive that everyone or

            04:05:04.320 --> 04:05:09.280
            in this example, multiple virtual machines can work on at the same time. To connect to the file

            04:05:09.280 --> 04:05:14.320
            share, you can use network protocols like the server message block or network file system.

            04:05:14.320 --> 04:05:18.800
            When a connection is established, the file shares file system will be accessible in the specific

            04:05:18.800 --> 04:05:22.720
            directory within your own directory tree. This process is known as mounting.

            04:05:22.720 --> 04:05:28.560
            Backups. Use shared snapshots to back up your file share. These snapshots are read only and

            04:05:28.560 --> 04:05:32.800
            incremental, meaning they only contain data that has changed since the last snapshot. You could

            04:05:32.800 --> 04:05:38.000
            have a maximum of 200 snapshots per file share, and these can be retained for a whopping 10 years.

            04:05:38.000 --> 04:05:42.400
            Remember, backups are stored within your file share. If you delete the share, you say goodbye

            04:05:42.400 --> 04:05:47.600
            to the backups as well. Soft delete. You can prevent accidental deletion by turning on soft

            04:05:47.600 --> 04:05:52.240
            delete. With soft delete, your data isn't immediately removed. Instead, it's marked for

            04:05:52.240 --> 04:05:57.440
            deletion and held for a certain period before it's permanently erased. Advanced threat protection,

            04:05:57.440 --> 04:06:01.760
            an additional layer of security intelligence that provides alerts when it detects suspicious

            04:06:01.760 --> 04:06:07.120
            activity on your storage account. Store tiers, premium, store on the SSD with single digit

            04:06:07.120 --> 04:06:12.720
            milliseconds for most EO operations. Transaction optimized, store on HDD with transaction heavy

            04:06:12.720 --> 04:06:17.360
            workloads that don't need the latency offered by premium file shares. Hot, optimized for

            04:06:17.360 --> 04:06:22.640
            general purpose file sharing scenarios such as team shares and Azure file sync. Cool, stored on

            04:06:22.640 --> 04:06:29.120
            HDD for cost efficient storage optimized for online archive storage scenarios. Types of storage,

            04:06:29.120 --> 04:06:35.680
            general purpose version two deployed onto HDD. File storage deployed on the SSD. Identity,

            04:06:35.680 --> 04:06:40.640
            on premises, Azure storage can integrate with an on premises Active Directory domain service.

            04:06:40.640 --> 04:06:45.600
            Managed, Azure storage can be joined to Microsoft managed Active Directory domain service. Store

            04:06:45.600 --> 04:06:50.240
            account key, use a combination of storage account name as the username and the account key as the

            04:06:50.240 --> 04:06:55.760
            password for mounting. Networking, Azure files can be accessed from anywhere both inside and

            04:06:55.760 --> 04:07:00.480
            outside your Azure account through the storage accounts public endpoint. Remember, SMB uses

            04:07:00.480 --> 04:07:06.240
            port 445. If you face connection issues, check if this port is open in your organization to mount

            04:07:06.240 --> 04:07:11.520
            your file share. Encryption, Azure files is encrypted at rest using Azure Storage Service

            04:07:11.520 --> 04:07:17.760
            encryption. Azure files is encrypted in transit with SMB 3.0 plus with encryption or HTTPS.

            04:07:17.760 --> 04:07:22.560
            And there we have it, a comprehensive look into Azure files and its noteworthy features.

            04:07:22.560 --> 04:07:31.920
            Continuing from our discussion on Azure files, let's now explore its main use cases.

            04:07:31.920 --> 04:07:37.920
            Use cases for Azure files. Completely replace or supplement on premises file servers network

            04:07:37.920 --> 04:07:43.040
            attached storage devices, lift and shift your on premises storage to the cloud via classic lift or

            04:07:43.040 --> 04:07:47.840
            hybrid lift. Lift and shift means when you move workloads without reach editing. For example,

            04:07:47.840 --> 04:07:52.880
            you can directly import your local VMs to the cloud classic lift, both the application and its

            04:07:52.880 --> 04:07:58.160
            data are moved to Azure hybrid lift. Here only the application data gets moved to Azure files

            04:07:58.160 --> 04:08:03.360
            while the application remains operational on premises. Simplify cloud development,

            04:08:03.360 --> 04:08:08.160
            shared application settings, multiple VMs and developer workstations need to access the same

            04:08:08.160 --> 04:08:13.920
            configuration files. Diagnostic share all VMs log to the file share developers can mount and debug

            04:08:13.920 --> 04:08:19.120
            all logs in a centralized place. Dev test debug developers can quickly share essential tools

            04:08:19.120 --> 04:08:24.640
            needed for local environments. Containerization, you can use Azure files to persist volumes for

            04:08:24.640 --> 04:08:30.160
            stateful containers. Why use Azure files instead of setting up your own file share server.

            04:08:30.160 --> 04:08:34.720
            Shared access Azure files is pre configured to function with standard networking protocols like

            04:08:34.720 --> 04:08:39.600
            SMB and NFS. Fully managed Azure manages maintenance and security patches to ensure

            04:08:39.600 --> 04:08:44.400
            your file storage is secure and updated scripting and tooling. You can automate the management and

            04:08:44.400 --> 04:08:49.280
            creation of file shared with Azure API and PowerShell resiliency. Azure files is built

            04:08:49.280 --> 04:08:54.160
            for durability, ensuring that your data is always safe and accessible. So these are the

            04:08:54.160 --> 04:09:00.640
            main reasons and scenarios for incorporating Azure files into your infrastructure.

            04:09:00.640 --> 04:09:07.920
            The next topic will be covering is Azure file sync. Azure file sync is a service that allows

            04:09:07.920 --> 04:09:12.960
            you to cache Azure file shares on an on premises Windows Server or cloud VM. How does it work?

            04:09:12.960 --> 04:09:18.080
            Caching Azure file sync transforms your Windows Server into a quick cache of your Azure file

            04:09:18.080 --> 04:09:22.400
            share. This means that you can access the data you need faster than ever without having to rely

            04:09:22.400 --> 04:09:28.000
            on the cloud. Multiple protocols regardless of the protocol you're comfortable with be at SMB

            04:09:28.000 --> 04:09:33.520
            NFS or FTPS. Azure file sync lets you access your data locally granting greater flexibility.

            04:09:33.520 --> 04:09:38.960
            Global caches for businesses operating globally. Azure file sync allows setting up caches in

            04:09:38.960 --> 04:09:46.000
            multiple locations for faster data access. Key benefits centralized storage with Azure file sync.

            04:09:46.000 --> 04:09:51.040
            You get centralized file services in Azure allowing multiple locations to use cloud tiering and direct

            04:09:51.040 --> 04:09:56.640
            cloud access to store and access data. Integrated with Azure backup. Azure file sync integrates

            04:09:56.640 --> 04:10:02.560
            seamlessly with Azure backup offering unified and streamlined backup services. Cloud tiering as your

            04:10:02.560 --> 04:10:07.920
            storage needs change older or rarely use files can be moved to Azure saving space on your local servers.

            04:10:07.920 --> 04:10:12.800
            Easy integration. It's designed to integrate smoothly with your existing infrastructure

            04:10:12.800 --> 04:10:17.680
            meaning less learning curve and disruption. So that's a brief overview of Azure file sync.

            04:10:18.400 --> 04:10:26.640
            Hey, this is Andrew Brown from exam Pro. And in this follow along, I'm going to show you how to

            04:10:26.640 --> 04:10:32.000
            set up a file share and mount it to a virtual machine. So let's get to it. So the first thing

            04:10:32.000 --> 04:10:36.160
            we're going to do is go all the way to the top. And we're going to type in storage accounts because

            04:10:36.160 --> 04:10:41.840
            if you type in files, or Azure files, you're just not going to get anything because it is a subservice

            04:10:41.840 --> 04:10:48.240
            within a storage account. So go ahead and hit add. And I think I will name, I'll make a new resource

            04:10:48.240 --> 04:10:53.600
            group as I always do, I'm going to name this one as key boss. Okay, and then we'll name the account

            04:10:53.600 --> 04:10:58.800
            as such. Now I want to show you something here. So under the account kind, if you remember from

            04:10:58.800 --> 04:11:05.520
            our lecture content, you can create a file share under general purpose two. But if you go to premium

            04:11:05.520 --> 04:11:10.640
            two, you'll have just a file storage type that means only your the storage count is only for

            04:11:10.640 --> 04:11:17.760
            creating a file storage. And that's if you want to use the premium tier four access and we don't

            04:11:17.760 --> 04:11:24.000
            today. But I will show you when we get to that in a moment here, just to point that out to you. So

            04:11:24.000 --> 04:11:28.160
            what we'll do is go ahead and hit review create. Actually, before we do that, let's just double

            04:11:28.160 --> 04:11:32.000
            check if there's anything interesting here. Sometimes there is. So under Azure files for

            04:11:32.000 --> 04:11:37.840
            large file shares, provides file share support up to 100 terabytes. So right now it's it's disabled.

            04:11:37.840 --> 04:11:41.680
            But if you wanted larger files, you could go ahead and enable that. But we're just going to leave it

            04:11:41.680 --> 04:11:46.240
            off. I'm going to go ahead and hit review and create. Now, as this is creating, and this goes

            04:11:46.240 --> 04:11:51.520
            pretty darn quick, what I'm going to do is launch a new virtual machine because we need something

            04:11:51.520 --> 04:11:57.200
            to mount the file share to. So make your way over to virtual machines. And what we're going to do

            04:11:57.200 --> 04:12:02.240
            is launch a Linux one just because that's a lot easier for me to do here. And they're generally

            04:12:02.240 --> 04:12:08.080
            more inexpensive. So we'll choose kivas. I'm also going to name the virtual machine kivas and we'll

            04:12:08.080 --> 04:12:15.920
            choose Ubuntu as our image. So just go down here, make sure you choose 18 LTS generation two. And

            04:12:15.920 --> 04:12:21.440
            under the sizes, we'll expand it, make sure you choose B one Ls because that costs around $6 a

            04:12:21.440 --> 04:12:27.440
            month. Under your password, we will choose Azure user as the name. And then for the password

            04:12:27.440 --> 04:12:35.120
            itself testing 123 capital on that T. So capital T testing 123456. Sorry, it's always 123456. We

            04:12:35.120 --> 04:12:42.800
            should probably open up port 445. But we'll get to that when we get to the actually we have to

            04:12:42.800 --> 04:12:48.480
            recreate it here. So I hit review and create. And we will go ahead and just give it a moment.

            04:12:48.480 --> 04:12:54.800
            Just takes a little bit of time, and we'll just go and create that there.

            04:12:56.720 --> 04:13:02.720
            So as that is creating, we'll go back to our storage account, we'll go into it. And as you

            04:13:02.720 --> 04:13:06.480
            notice, these are the services, the things that we can launch in our storage account,

            04:13:06.480 --> 04:13:11.360
            what we want is a file share that's Azure files. And notice here that the capacity set to five

            04:13:11.360 --> 04:13:16.400
            terabytes, and it has a soft delete for seven days, it's not configured with Azure, Azure Active

            04:13:16.400 --> 04:13:21.120
            Directory as of yet, if we wanted to use that to authenticate. But what we'll do is click on file

            04:13:21.120 --> 04:13:26.160
            share on the right hand side, I'm going to name our file share as kivas, I'm going to set the total

            04:13:26.160 --> 04:13:30.480
            to three gigabytes, because we don't need a lot of data. And remember that tier I talked about,

            04:13:30.480 --> 04:13:36.400
            well, here it is, it's disabled. But if we had created it, a premium storage account and a file

            04:13:36.400 --> 04:13:40.320
            file storage, we could have chosen that. All right. So we'll go ahead and hit Create. And this

            04:13:40.320 --> 04:13:44.720
            doesn't take too long. As that's going, let's make our way back to our virtual machine, it looks like

            04:13:44.720 --> 04:13:49.120
            it's deployed. So we'll go to that resource. And then on the left hand side, we'll go to networking

            04:13:49.120 --> 04:13:55.600
            because I want to open up that port, port port 445. That's what SSMB SMB communicates on.

            04:13:56.560 --> 04:14:02.240
            And so down below, all this is fine. But if we were to go here, there isn't one for SMB. So what

            04:14:02.240 --> 04:14:08.640
            we'll do is just put in 445. And we'll say TCP, and I'll just write down here SMB. And we'll go

            04:14:08.640 --> 04:14:13.360
            ahead and hit add. And that only takes a moment there, we'll make our way back to our storage

            04:14:13.360 --> 04:14:17.520
            account, we'll click in or sorry, into our files, yeah, storage account in our files, notice we have

            04:14:17.520 --> 04:14:23.280
            connect and upload. And so what we're going to do is click Connect. And it's going to give us some

            04:14:23.280 --> 04:14:27.440
            instructions here that we can run. And this is going to be the mount point. So I'm going to go

            04:14:27.440 --> 04:14:32.560
            make my way back to here. And I see that that record has been created. And I'm going to open up

            04:14:32.560 --> 04:14:38.720
            our cloud shell. And so if you've never opened up cloud shell before, it'll ask you to make it a

            04:14:38.720 --> 04:14:43.200
            storage account that is specific just for it to say yes, make sure you're in bash mode, we cannot

            04:14:43.200 --> 04:14:47.520
            do this in PowerShell. And within your virtual machine, if you're on the right tab here, you'll

            04:14:47.520 --> 04:14:54.400
            go to overview. And we're going to grab that public IP address, type SSH, Azure user at sign,

            04:14:54.400 --> 04:14:59.200
            paste in the IP address, we'll hit enter, type in yes to accept the fingerprint and then type

            04:14:59.200 --> 04:15:06.640
            your password capital T testing 123456. Okay, it'll let us in. And what we're going to need to

            04:15:06.640 --> 04:15:12.400
            do is do a pseudo apt update. And I'm going to do ampersand ampersand just so we can run this in one

            04:15:12.400 --> 04:15:18.320
            line, we're gonna type in pseudo apt, install CI FS utils. This is the utility that we're going to

            04:15:18.320 --> 04:15:23.040
            use to do this part of the mounting. So we need to make sure that is installed. And so we'll let

            04:15:23.040 --> 04:15:28.960
            that go up apt update can take a lot of time or a very little amount of time, it just depends on how

            04:15:28.960 --> 04:15:34.400
            many updates there are, but it shouldn't take too long. And so what we're going to do is prepare

            04:15:34.400 --> 04:15:40.640
            this because this is not the easiest to work with. And so what we'll do, I already have it open here,

            04:15:40.640 --> 04:15:44.640
            because I was given this ago earlier, this is the exact same thing, but I'm going to delete it out.

            04:15:44.640 --> 04:15:49.600
            So it's one to one, because I think it might have changed a little bit here, whoops.

            04:15:49.600 --> 04:15:57.360
            And so I will copy this here. And paste it in, and we'll just give it a quick read. So what it's

            04:15:57.360 --> 04:16:04.400
            going to do, I don't know if it would color. So if I went to bash here, shell script, there we go,

            04:16:04.400 --> 04:16:10.480
            it's a bit easier. So it's going to create a directory called mount kivas. And then it's going

            04:16:10.480 --> 04:16:15.360
            to create another directory for the SMB credentials, it's going to store the username and then the

            04:16:15.360 --> 04:16:18.800
            password in these credentials, we're going to cha mod it. So we have our permissions.

            04:16:18.800 --> 04:16:23.840
            And then we have this bash script here, which is a little bit hard to read, but

            04:16:23.840 --> 04:16:30.640
            it is using ci fs. So it's doing some something there, and setting that stuff up. And then it's

            04:16:30.640 --> 04:16:37.360
            using cfs. It's actually mounting this case. So that's what we're going to do. So just going back

            04:16:37.360 --> 04:16:45.840
            over here and back to this other tab. What I'm going to do here is, oh, sorry, now this is ready,

            04:16:45.840 --> 04:16:51.520
            we're just typing clear. And I'm going to run each of these commands. So I'm going to grab the make

            04:16:51.520 --> 04:16:56.400
            directory here. And I'm going to paste that in. If you paste all this in half the time, it messes up

            04:16:56.400 --> 04:17:00.800
            when you have multi line like that. So it's not even worth trying. So we'll do copy, we'll make

            04:17:00.800 --> 04:17:06.480
            that other directory here. And then we have this pseudo bash line here. So we'll copy that.

            04:17:06.480 --> 04:17:14.400
            Okay, hit enter. And then we'll grab this next line here. We'll copy that paste that in,

            04:17:14.400 --> 04:17:20.880
            hit enter. Did not like the space in front of it, I think. It's just a really long line. So what I'll

            04:17:20.880 --> 04:17:26.480
            do is I'll just grab that line, and move to the wall, make my life a little bit easier. And we'll

            04:17:26.480 --> 04:17:34.720
            paste that in like that. It's saying the credentials does not exist. Hold on here.

            04:17:34.720 --> 04:17:43.840
            So we'll just write clear. It's okay if it happens. So this directory should exist, right? So if I do

            04:17:46.080 --> 04:17:54.080
            pwd, etc, or we should just be able to auto complete it says a CD, etc. I'm hitting tab

            04:17:54.080 --> 04:18:01.200
            to auto complete and then we want SMB. And this is credential. So it's missing the s.

            04:18:01.200 --> 04:18:07.280
            There's my mistake. Okay, so I'm going to go ahead and remove that. Because if we don't have it named

            04:18:07.280 --> 04:18:11.360
            right, it's just not going to work, right. So we'll go ahead here and make sure we copy the entire line

            04:18:11.360 --> 04:18:17.600
            that was my mistake. And we'll paste that in there, we'll go to the next line, copy that paste that in,

            04:18:17.600 --> 04:18:30.800
            copy the next line here, paste that in. And we will, we will we'll do is we'll chmod the file.

            04:18:30.800 --> 04:18:36.880
            Okay, so if we want to check to make sure it's the correct permissions, what we can do is

            04:18:38.480 --> 04:18:45.040
            do an LS paste in the or just write in the path, which is SMB credentials here. And here we can see

            04:18:45.040 --> 04:18:50.800
            the file if we do a hyphen la, it will show us that it has the correct permission. So it's really

            04:18:50.800 --> 04:18:54.400
            locked down there. That's what the chmod did. If we want to see the contents of that file to make

            04:18:54.400 --> 04:19:02.080
            sure that those things are in there, what we can do is type in cat and just grab that whole link

            04:19:02.080 --> 04:19:06.240
            here, we might have to give it sudo, I might complain for that. It does. So we'll put sudo in

            04:19:06.240 --> 04:19:10.400
            front of that. And so we just wanna make sure there's one username and one password. And

            04:19:10.400 --> 04:19:15.920
            everything looks okay, there will type clear, we'll make our way back here. And so now we'll

            04:19:15.920 --> 04:19:23.600
            run these commands. So that's the first one. And then this is the second one.

            04:19:23.600 --> 04:19:32.640
            We'll make sure that that n matches up I n o Yep, I know hit enter. And so now it should work. So if

            04:19:32.640 --> 04:19:36.960
            we were to upload a file, that should be in good shape. But if we want to get to that directory,

            04:19:36.960 --> 04:19:42.480
            we'll just type in mount. If we keep on hitting tab, it'll show us there's key boss. Okay, and so

            04:19:42.480 --> 04:19:45.520
            you know, this is where we're going to create some files. So I actually don't have a file

            04:19:45.520 --> 04:19:49.520
            prepared. So give me a moment, I'll be back in a moment with a file. Alright, I'm back. And I've

            04:19:49.520 --> 04:19:54.560
            prepared an image for us to upload. So going back to our file share in here, we have the upload

            04:19:54.560 --> 04:19:59.280
            button, just go ahead and click that. And on the right hand side, it's going to give you a pop up.

            04:19:59.280 --> 04:20:04.640
            And within that pop up there, just go find your image, I'm just off screen grabbing it. So this

            04:20:04.640 --> 04:20:11.360
            is my image, what I'm uploading, which is kivas. kivas. Fajo, it's who we named it after. He's the

            04:20:11.360 --> 04:20:17.760
            collector in Star Trek next generation. And so what I'll do is go ahead and hit upload. Right.

            04:20:17.760 --> 04:20:25.520
            And so that file is supposedly there. If we go back here and do LS, there's the file, right.

            04:20:25.520 --> 04:20:30.800
            And so probably it should be reflective. So if we were to go and delete this file,

            04:20:30.800 --> 04:20:35.200
            so we'd say remove, or maybe if we made a new director, let's see what happens if we say,

            04:20:35.200 --> 04:20:40.560
            you know, the episodes called the most toys and Star Trek,

            04:20:40.560 --> 04:20:46.960
            just see if it actually reflects back and forth. So we do a refresh, there it is,

            04:20:46.960 --> 04:20:50.880
            can I drag? No, I can't drag. But I could probably move this file over there. So we'll say move

            04:20:51.680 --> 04:20:57.920
            kivas Fajo into the most toys episode. And if we go back here and refresh,

            04:20:57.920 --> 04:21:05.520
            you get the idea, right? So yeah, I mean, that's as simple as it is with the file share there. Okay.

            04:21:05.520 --> 04:21:10.800
            So now that we're all done here with Azure file share, we can't or we can't use this to make a

            04:21:10.800 --> 04:21:14.880
            file sync, because we would have to use Windows for that. So this is all pretty much done. So

            04:21:14.880 --> 04:21:18.960
            what I want you to do is go to your resource groups, we'll find kivas. And we'll go ahead

            04:21:18.960 --> 04:21:24.960
            and delete this. And we'll call this part of our follow along 100% done here. Okay,

            04:21:24.960 --> 04:21:34.080
            so see you in the next one. Hey, this is Andrew Brown from exam Pro. And we are going to take a

            04:21:34.080 --> 04:21:40.800
            look at using Azure file sync. So previously, we set up file share with just Linux, but we're going

            04:21:40.800 --> 04:21:45.280
            to take it a bit further and set up a sync. So what we're going to do is we're going to do two

            04:21:45.280 --> 04:21:50.320
            things, we need to set up a new storage account. And we'll also have to launch a virtual machine.

            04:21:50.320 --> 04:21:54.320
            Since virtual machines take longer to launch than a storage account, what I want you to do,

            04:21:54.320 --> 04:21:58.560
            I saw the old tab here from the last follow along. But what I want you to do is make your way over

            04:21:58.560 --> 04:22:03.280
            to virtual machines, open that a new tab, and we'll go ahead and launch yourself a Windows server.

            04:22:03.280 --> 04:22:09.520
            So up in the top left corner, hit add virtual machine, we'll give it a moment, I'm going to

            04:22:09.520 --> 04:22:14.640
            call this new one. Well, we can use kivas again. So I'm going to go ahead and do that. We'll say

            04:22:14.640 --> 04:22:20.160
            this is kivas. And I'm going to choose this time Windows 2019 server. So we have a Windows server,

            04:22:20.160 --> 04:22:28.880
            and I want 2019 doesn't necessarily have to be just double check here. Yeah, we'll just do 2019

            04:22:28.880 --> 04:22:34.960
            generation two here. And we'll scroll on down here, and I'm going to put an Azure user. And then

            04:22:34.960 --> 04:22:42.880
            we'll do capital T testing 123456 capital T testing 123456. Scroll on down, we are definitely going

            04:22:42.880 --> 04:22:51.200
            to want port 3389. Open. We'll open up these two ports as well. I think that's okay. And we'll go

            04:22:51.200 --> 04:22:56.160
            ahead and hit review and create. Well, actually, before we do that, I don't think I choose the

            04:22:56.160 --> 04:23:01.200
            right size. So we'll just wait a moment here as it's complaining. And we'll change this because

            04:23:01.200 --> 04:23:12.240
            you can't have a B one LS, we're going to have to go with dsv. s v, ds v three, okay, because it has

            04:23:12.240 --> 04:23:16.480
            two v CPUs at the minimum, actually, we can go with this one here, because it just has to be two

            04:23:16.480 --> 04:23:21.040
            and four. So I think we get away with a B two, which is 5050 bucks a month, which we're not going

            04:23:21.040 --> 04:23:29.360
            to keep that around for very long. We'll go ahead and hit create. We might need before that I'm just

            04:23:29.360 --> 04:23:32.400
            going to add another disk just in case because I really don't want to have to do this if I have to

            04:23:32.400 --> 04:23:39.120
            make another one. And so we're just going to say an empty disk here, I suppose. That seems fine to

            04:23:39.120 --> 04:23:45.680
            me. And I'm going to go ahead and hit Yeah, we should enable this. Now we'll do nothing there.

            04:23:45.680 --> 04:23:54.000
            And we'll say okay, and go ahead and hit review, create. And we'll just give it a moment takes a

            04:23:54.000 --> 04:23:57.600
            little bit of time and go ahead and hit create there. And while that's creating, now we'll go

            04:23:57.600 --> 04:24:02.880
            over and make ourselves a storage account. So I'll make a new one here. And we'll call it we'll put

            04:24:02.880 --> 04:24:08.000
            it in our key boss and we'll call it key boss. We'll stick with standard general to that's totally

            04:24:08.000 --> 04:24:14.080
            fine for our use case. We'll go ahead and hit create and this will not take long. It's very

            04:24:14.080 --> 04:24:21.440
            fast and making storage accounts, virtual windows virtual machines not as fast. So we'll just give

            04:24:21.440 --> 04:24:44.800
            it a moment here. And it looks like it's created. So we'll go to the resource. And then under file

            04:24:44.800 --> 04:24:49.040
            shares, we'll click on that we'll create a new file share. And this will be called key boss.

            04:24:49.680 --> 04:24:54.000
            And we'll set five gigabytes because we really don't need a large one, we'll create it. And so

            04:24:54.000 --> 04:25:00.560
            this can be used for Windows or Linux. And in this case, we're going to be using it for Windows. So

            04:25:00.560 --> 04:25:05.120
            what we can do, we'll just have to wait for that to finish deploy. But we're gonna have to set up

            04:25:05.120 --> 04:25:10.720
            Azure file. So if we go files, I think we type it in here, will it show up? No. So if the thing is,

            04:25:10.720 --> 04:25:16.960
            we need to get file sync, and it's in a kind of a weird spot. So if we go to all services,

            04:25:16.960 --> 04:25:26.000
            and then we type in files, whoops, was a little bit too quick there. I'm just looking for it here.

            04:25:26.000 --> 04:25:33.280
            What if we type in sync? There we go. So what I'm looking for is storage sync services.

            04:25:33.280 --> 04:25:40.080
            Can we type it up here sync? Yeah, so that would have been the way I would have gone,

            04:25:40.080 --> 04:25:46.080
            gone, gone and found it there. But we need to find Azure files. I'm just trying to remember

            04:25:47.040 --> 04:25:52.880
            how to get to there. So could have swore we could type in file sync.

            04:25:52.880 --> 04:26:00.960
            Yeah, here it is Azure file sync. And so this is how we get to it. I know it's quite a let me just

            04:26:00.960 --> 04:26:04.080
            double check to make sure if that's somewhat if we actually type that up here, file sync.

            04:26:04.080 --> 04:26:10.320
            No. Okay. So what we want to do is go ahead and create this. If we want to take a look,

            04:26:10.320 --> 04:26:15.840
            we check the plans, this seems okay. So go ahead and hit create. And under here, we're going to

            04:26:15.840 --> 04:26:21.440
            put it into kivas. And then for the provider name, it will be the storage sync service name will just

            04:26:21.440 --> 04:26:27.440
            be kivas as well. And I guess we'll stick with central us, I guess it's just really depends on

            04:26:27.440 --> 04:26:31.200
            where our virtual machine storage account is, I hope everything's launching in the same place.

            04:26:31.200 --> 04:26:36.080
            I don't think it matters. But I'm just going to double check here. So this one is in Canada, East,

            04:26:36.080 --> 04:26:43.920
            and then our storage account, Cisco, take a look where it is. It is in Canada, so maybe we can

            04:26:43.920 --> 04:26:48.400
            watch this in Canada, East, it doesn't give us any grief, it doesn't. So that's great. We'll go ahead

            04:26:48.400 --> 04:26:57.840
            and hit create. And we'll give that a little bit of time there. And if our instances ready, we should

            04:26:57.840 --> 04:27:01.840
            go ahead and connect to it because there's going to be a couple things we need to install. Okay,

            04:27:01.840 --> 04:27:07.920
            so I'm going to go over to RDP here. And we're going to download the RTP file. And that's going

            04:27:07.920 --> 04:27:12.560
            to open up that. So we'll just double click it will say connect. If you're on a Mac, you got

            04:27:12.560 --> 04:27:16.800
            to download the client. If you're on Windows, it's already it should be pre installed. If you're on a

            04:27:16.800 --> 04:27:23.600
            Chromebook, you'll have to use a bastion by going to type in Azure user. And that password capital

            04:27:23.600 --> 04:27:36.400
            T testing 123456. We'll hit OK. I'll say yes, I'll connect. And we'll just give it a moment there to

            04:27:36.400 --> 04:27:42.400
            load. We are going to need two things we need to install. But just give me a moment here. I'll go

            04:27:42.400 --> 04:27:50.000
            fetch them. Alright, so now that we have our Windows machine, we're inside of it here, what I

            04:27:50.000 --> 04:27:55.920
            want you to do is open up PowerShell. So if you type in PowerShell, we do need to run this in

            04:27:55.920 --> 04:28:00.480
            administrator mode. So just type it in. It's a little bit slow when you're already paying,

            04:28:00.480 --> 04:28:04.160
            which is totally fine. And what I want you to do is right click and run as an administrator.

            04:28:04.880 --> 04:28:10.560
            And what we're going to do is install Azure RM because we need it in order to use the Azure

            04:28:10.560 --> 04:28:19.440
            file sync agent. Okay, so type in install hyphen module, and then type in name, Azure RM. And then

            04:28:19.440 --> 04:28:24.480
            we'll say allow clobber. Don't ask me what clobber does. I have no idea. But that's what Microsoft

            04:28:24.480 --> 04:28:28.640
            or Azure tells us that we should. Whoops, display right? No, it's all correct. Okay,

            04:28:28.640 --> 04:28:34.160
            that we should do this thing is pretty darn slow. So we'll just have to wait here a little while.

            04:28:34.880 --> 04:28:37.360
            And once that's done, we'll continue on to the next part. Okay.

            04:28:37.360 --> 04:28:43.760
            Okay, so after a little bit, it asks us a question. So we're just gonna hit why to everything.

            04:28:43.760 --> 04:28:49.680
            All right. And as that's going here, it can take a little bit of time. So what I'm going to do,

            04:28:49.680 --> 04:28:56.480
            if I can even minimize this here, I did not mean to minimize Azure, or this here. Oh,

            04:28:56.480 --> 04:29:01.040
            the other one already prompted. That was pretty fast. Actually, it's going really fast as of today.

            04:29:02.640 --> 04:29:11.840
            But as that's going, what we'll do is we'll make our way back over to sync storage here,

            04:29:11.840 --> 04:29:16.240
            because our storage sync, we were waiting for this to get set up. Because we're going to have to go

            04:29:16.240 --> 04:29:21.840
            set up a sync group. So I'm gonna just call this kivas make everything easy, we'll stick with that

            04:29:21.840 --> 04:29:27.440
            Azure subscription, we'll drop this down. And we'll choose kivas in here. And then for the Azure file

            04:29:27.440 --> 04:29:34.320
            share, we'll choose kivas. And once that's created, we'll click into that. And what we are trying to

            04:29:34.320 --> 04:29:40.960
            do is we're adding a cloud endpoint here. So we would choose our storage account. And we would

            04:29:40.960 --> 04:29:50.400
            choose this here and hit Create. Okay, and so now we have a cloud endpoint, but we still have to

            04:29:50.400 --> 04:29:56.720
            continue on with our, our virtual machine here. So just wait until this is done. This will take

            04:29:56.720 --> 04:30:06.320
            a little bit of time. Okay. Alright, so now that we we have that installed the the PowerShell for

            04:30:06.320 --> 04:30:10.640
            Resource Manager, what we're going to need installed is the Azure file sync agent. In order

            04:30:10.640 --> 04:30:14.720
            to do that, we're gonna have to go to the internet. But before we do that, we really want to

            04:30:14.720 --> 04:30:20.880
            turn off a particular feature. So turn back on protected mode, I was fiddling with it earlier.

            04:30:20.880 --> 04:30:26.160
            But if we were to go and it doesn't matter where we go, we say Azure file, sync agent.

            04:30:27.040 --> 04:30:32.480
            Okay. And if we were to go see, we started getting this pop up and drives us crazy. So

            04:30:32.480 --> 04:30:36.320
            what we can do, because this isn't a big deal, it's just for testing here, we're going to turn

            04:30:36.320 --> 04:30:42.320
            that off. So go to your local server and where it says I I eat enhanced security configuration,

            04:30:42.320 --> 04:30:47.120
            click on that and just turn it off, you know, because it'll drive you crazy. And then we'll

            04:30:47.120 --> 04:30:52.720
            go back to inter Explorer completely close it, reopen it. And now what we can do is look for

            04:30:52.720 --> 04:31:01.840
            that Azure file sync. So we'll type in Azure file sync, agent download. This is Azure Microsoft.com,

            04:31:01.840 --> 04:31:07.120
            maybe later for the experience, it's easy if you go to the Microsoft site. And if you go here,

            04:31:07.120 --> 04:31:12.080
            just give it a moment, scroll on down, click on the download button. And we want 2019 because

            04:31:12.080 --> 04:31:16.720
            that's the server we launched, right? And that's we're trying to sync with storage sync. So we'll

            04:31:16.720 --> 04:31:23.600
            go ahead and hit next. This is 50 megabytes, so it shouldn't take too long. And we're going to

            04:31:23.600 --> 04:31:29.200
            wait for it to download if it doesn't. Well, we'll say allow once for the site here. So maybe it was

            04:31:29.200 --> 04:31:39.280
            trying to download. Yeah, there it goes. And we will save it. And we will always allow for

            04:31:39.280 --> 04:31:43.360
            Microsoft here, it's totally fine. And it's already finished downloading. So we'll go ahead and run

            04:31:43.360 --> 04:31:52.240
            that. And just give it a moment here, we'll hit next. We'll accept the terms. We'll install there,

            04:31:52.240 --> 04:31:58.800
            that's totally fine. We'll use the existing proxy configuration, custom configure proxy. Well,

            04:31:58.800 --> 04:32:03.760
            we don't have any custom. So leave it alone, we'll leave Microsoft updates on. It'd probably

            04:32:03.760 --> 04:32:09.760
            be good to checkbox that on, but I'm just going to go install next here. All right, and so we'll

            04:32:09.760 --> 04:32:23.520
            let the agent install. Usually doesn't take too long. Anyway, I'll see you back here in a moment.

            04:32:23.520 --> 04:32:29.360
            Alright, so now that we have our storage agent set up, we'll just hit finish here.

            04:32:29.360 --> 04:32:33.200
            And I don't know why it opened a bunch of windows, but that's just what it does.

            04:32:33.200 --> 04:32:38.400
            And so we're just going to wait for it to pop back up here. And then we'll say okay.

            04:32:38.960 --> 04:32:45.520
            And then what I want to do is connect. So it says Azure environment. So it is Azure Cloud,

            04:32:45.520 --> 04:32:52.080
            right. And I'm just going to sign into my account. And I'm going to try and log in here. So let me

            04:32:52.080 --> 04:32:57.440
            just go grab my credentials. Alright, so I entered my credentials in here. So we'll go ahead and hit

            04:32:57.440 --> 04:33:01.520
            sign in. And we'll give it a moment there. We're going to choose our subscription, we'll choose

            04:33:01.520 --> 04:33:09.360
            our resource group, which is key boss and our storage sync there, hit register. And I'll see

            04:33:09.360 --> 04:33:16.320
            you back here in a moment. Alright, so it looks like our registration was successful. So that

            04:33:16.320 --> 04:33:20.960
            means that we should be able to create a server endpoint and go from there. Okay, so I'm going

            04:33:20.960 --> 04:33:27.600
            to just go ahead and hit close. And I'll come back here to you in a moment. Alright, so now

            04:33:27.600 --> 04:33:33.120
            what we're going to do is set up a folder for that we're going to want to be synced, okay, because

            04:33:33.120 --> 04:33:39.200
            the idea is to backup or sync that directory there. So what's going to happen here is we're going to

            04:33:39.200 --> 04:33:43.680
            make our way down to file explorer. And from this PC, I'm just going to go to the C drive, I made

            04:33:43.680 --> 04:33:46.720
            that other drive, because I assume we were just going to throw it on there. But honestly, I'm just

            04:33:46.720 --> 04:33:51.120
            going to put it in the window or the C drive here, we'll make a new folder called key boss, we'll

            04:33:51.120 --> 04:33:56.080
            make it all lowercase. And inside of here, I'm just going to make a new file here called hello

            04:33:56.080 --> 04:34:04.560
            dot txt. Nothing super exciting. And so probably we need to turn on sharing. So that's just a habit

            04:34:04.560 --> 04:34:10.080
            of mine. So we'll go to properties here, sharing, share, and we'll just make sure that Azure,

            04:34:10.080 --> 04:34:16.560
            Azure user has both that. And it'll ask us to turn network discovery on, we'll say, okay,

            04:34:16.560 --> 04:34:22.080
            key boss, key boss, okay. I can't remember if we have to turn that on or not. But you know,

            04:34:22.080 --> 04:34:25.680
            as long as we have this work, and that's the most important part here. So now that we have that

            04:34:25.680 --> 04:34:32.320
            going, what we want to do is make our way back to Azure here. And so we had our, what was the sync

            04:34:32.320 --> 04:34:40.320
            sync storages. And what we'll need to do is go into our sync storage, once it ever lets us get

            04:34:40.320 --> 04:34:47.120
            there, we'll click on key boss. And we'll go into sync groups, we'll click into our key boss sync

            04:34:47.120 --> 04:34:52.000
            group, we have a cloud endpoint, we'll need to create an ad server endpoint, drop down here,

            04:34:52.000 --> 04:34:57.200
            we have a registered server. So you know how we typed in our, we typed, we typed in our we're

            04:34:57.200 --> 04:35:02.000
            logged into the Azure file sync agent. That's how this registered server showing up, we're gonna

            04:35:02.000 --> 04:35:12.560
            give it a path. So this is going to be C, backslash, key boss, right. So this all looks okay.

            04:35:13.920 --> 04:35:18.880
            And what we'll do is we will say, let's just check this here, this is all okay. And we'll go

            04:35:18.880 --> 04:35:23.840
            ahead and hit connect. All right. And so this takes a little bit of time to provision, it's

            04:35:23.840 --> 04:35:27.840
            going to show up here in a moment, if I hit refresh, it's provisioning. So I'll see you back

            04:35:27.840 --> 04:35:33.840
            here in a bit. You know, I just remembered is that we do actually have to turn on cloud tiering,

            04:35:33.840 --> 04:35:39.360
            or it's gonna stay in pending forever. So I'm gonna go to enable here, and always preserve

            04:35:39.360 --> 04:35:45.200
            specific percentage of free space on the volume. Sure, we can do 20%. Here, we don't need a date

            04:35:45.200 --> 04:35:51.600
            policy here. And this all looks okay. So we'll go ahead and hit save. Because if we don't do that,

            04:35:51.600 --> 04:35:56.320
            it's not gonna actually, it's not gonna move into the cloud, right. So we'll give that a go,

            04:35:56.320 --> 04:36:00.400
            oh, the health is good. And but we'll just give it a moment here. Okay.

            04:36:00.400 --> 04:36:06.640
            So we gave it a little bit of time here, it says the endpoint failed, which I really don't believe

            04:36:06.640 --> 04:36:10.240
            it because I just checked in, it was working totally fine. But what I want to do is show you

            04:36:10.240 --> 04:36:17.200
            if I go over to Microsoft Azure here, and we go over to storage accounts, and we go to kivas,

            04:36:17.200 --> 04:36:22.400
            and we go into file shares, and we click into this one, we can actually see the files here. So it

            04:36:22.400 --> 04:36:26.800
            clearly is syncing. I'm not sure why we got that error. I've never seen that error before.

            04:36:26.800 --> 04:36:33.360
            Clutter is not supported for this specified path. Well, that's fine. Okay, so if the server path

            04:36:33.360 --> 04:36:38.080
            didn't work, maybe it's the cloud cloud endpoint. But generally, that is the workflow to get syncing

            04:36:38.080 --> 04:36:43.520
            working. So you pretty much have all the working knowledge you need. But what we'll do is go ahead

            04:36:43.520 --> 04:36:48.640
            and tear all this stuff down because we are 100% done. So I'm going to go to our resource groups

            04:36:48.640 --> 04:36:57.360
            here. And what we'll do is go into kivas. And we'll just make sure that everything is there,

            04:36:57.360 --> 04:37:01.600
            even the storage sync service, I just wanted to make sure it was all there. And what we'll do is

            04:37:01.600 --> 04:37:07.360
            go ahead and write in kivas and go ahead and delete. And that should take everything down,

            04:37:07.360 --> 04:37:14.080
            no problem. Alright, so there you go. Alright, so just one more thing, I was doing that cleanup. And

            04:37:14.080 --> 04:37:18.320
            then today, I woke up the next morning. And when I checked my resource groups, the kivas was still

            04:37:18.320 --> 04:37:23.520
            here. So I went in here and we still had the storage sync service. So what you're gonna want

            04:37:23.520 --> 04:37:27.360
            to do is go in here. And I think what it wants you to do, actually tell us the message here,

            04:37:27.360 --> 04:37:35.760
            if we go delete resource group, we type in kivas. And it will complain that it's still neat,

            04:37:35.760 --> 04:37:41.360
            you have to get rid of the other resources within it. So I already know that's going to fail. But

            04:37:41.360 --> 04:37:46.160
            what it wants you to do is delete the sync group. So if you select the sync group here,

            04:37:46.160 --> 04:37:51.520
            and go ahead and delete that. We might also have to delete the endpoints first.

            04:37:51.520 --> 04:37:56.480
            Usually, usually, Azure is really great about tearing everything down. But in this case,

            04:37:57.360 --> 04:38:03.840
            it's not giving us a lot of help here. So we'll just say, yeah, we want to delete this endpoint

            04:38:03.840 --> 04:38:16.880
            to delete all the server. So you got to first delete the server endpoints to delete the cloud

            04:38:16.880 --> 04:38:23.920
            endpoint to delete the group, then to delete the actual service. So it's a little bit convoluted.

            04:38:23.920 --> 04:38:28.320
            But you know, I guess for whatever reason, this one is not automated like the other one. So just

            04:38:28.320 --> 04:38:34.480
            go through this process, make sure that you get everything deleted out, okay. And then you should

            04:38:34.480 --> 04:38:43.120
            be in good shape. Okay. Hey, this is Andrew Brown from exam Pro. And in this section, we'll be

            04:38:43.120 --> 04:38:47.440
            covering the core backup and disaster recovery solutions in Azure starting with Azure Site

            04:38:47.440 --> 04:38:52.960
            Recovery. Azure Site Recovery is a hybrid backup solution that facilitates site to site recovery

            04:38:52.960 --> 04:38:58.560
            from on premises to the cloud. ASR is a critical component for your business continuity and disaster

            04:38:58.560 --> 04:39:04.240
            recovery strategy. Site Recovery replicates workloads from a primary site to a secondary site

            04:39:04.240 --> 04:39:09.040
            in the event the primary site encounters a failure site recovery will fail over to the secondary site

            04:39:09.040 --> 04:39:14.720
            to ensure continuity of services. Azure Site Recovery can replicate Azure VMs between different

            04:39:14.720 --> 04:39:20.800
            regions also known as cross region replication various OS such as Windows and Linux on premises

            04:39:20.800 --> 04:39:25.600
            to Azure seamlessly transition from your local servers to the cloud between other cloud service

            04:39:25.600 --> 04:39:31.120
            providers such as OS to Azure different machines including VMware, Hyper-V or physical machines.

            04:39:31.120 --> 04:39:36.320
            Recovery time objectives. This is the amount of time your business can afford to have its systems

            04:39:36.320 --> 04:39:42.000
            unavailable or offline before it significantly impacts your business. Recovery point objectives.

            04:39:42.000 --> 04:39:46.240
            This is the maximum amount of data loss your business can tolerate measured in time before

            04:39:46.240 --> 04:39:51.520
            a disaster occurs. This overview highlights Azure Site Recovery a key tool for protecting

            04:39:51.520 --> 04:40:01.600
            business operations against unexpected disruptions. The next topic we'll be covering is recovery

            04:40:01.600 --> 04:40:06.880
            solution for Azure Site Recovery. A recovery solution for Azure hybrid and on premises

            04:40:06.880 --> 04:40:11.200
            workloads should be designed to meet specific recovery objectives including recovery time

            04:40:11.200 --> 04:40:17.360
            objective recovery point objective and recovery level objective. Recovery time objective RTO is

            04:40:17.360 --> 04:40:21.760
            the maximum amount of time that an application can be down before it starts causing significant

            04:40:21.760 --> 04:40:26.320
            business disruption. A recovery solution should be able to restore the system and data within the

            04:40:26.320 --> 04:40:32.000
            specified RTO time frame. For example, if the RTO is one hour, then the recovery solution should be

            04:40:32.000 --> 04:40:37.680
            able to restore the system and data within one hour of an outage. Recovery point objective RPO

            04:40:37.680 --> 04:40:42.000
            is the amount of data loss that is acceptable after an outage. The recovery solution should

            04:40:42.000 --> 04:40:47.120
            be able to restore the system and data to the required RPO level. For example, if the RPO is

            04:40:47.120 --> 04:40:51.280
            one hour, then the recovery solution should be able to restore the data to the most recent point

            04:40:51.280 --> 04:40:56.960
            in time within one hour of the outage. Recovery level objective RLO is the level of recovery that

            04:40:56.960 --> 04:41:01.600
            is required after an outage. The RLO can vary depending on the type of data or application

            04:41:01.600 --> 04:41:06.000
            being recovered. A recovery solution should be able to restore the data or application to the

            04:41:06.000 --> 04:41:11.440
            required RLO level. For example, if the RLO requires a point in time restore, the recovery

            04:41:11.440 --> 04:41:16.720
            solution should be able to restore the data to the specific point in time. When recommending a

            04:41:16.720 --> 04:41:21.440
            recovery solution for Azure hybrid and on premises workloads, the following factors should be

            04:41:21.440 --> 04:41:26.720
            considered. Business requirements, the recovery solution should align with the business requirements,

            04:41:26.720 --> 04:41:32.080
            including the RTO, RLO and RPO objectives. These objectives should be identified during the

            04:41:32.080 --> 04:41:38.160
            planning phase. Workload types, different types of workloads may have different RTO, RLO and RPO

            04:41:38.160 --> 04:41:42.800
            requirements. The recovery solution should be able to accommodate the requirements of each workload

            04:41:42.800 --> 04:41:48.240
            type. Hybrid or on premises, the recovery solution should be able to handle hybrid or on premises

            04:41:48.240 --> 04:41:54.000
            workloads depending on the specific requirements of the organization. Data protection, the recovery

            04:41:54.000 --> 04:41:58.880
            solution should provide data protection, including backups and replication to ensure that the data

            04:41:58.880 --> 04:42:04.160
            can be recovered in case of an outage. Testing, the recovery solution should be tested regularly

            04:42:04.160 --> 04:42:09.520
            to ensure that it meets the RTO, RLO and RPO objectives. Testing should be conducted in a

            04:42:09.520 --> 04:42:14.640
            controlled environment to avoid any negative impact on production systems. By considering

            04:42:14.640 --> 04:42:19.200
            these factors, you can enhance your Azure site recovery solutions, ensuring swift and efficient

            04:42:19.200 --> 04:42:28.560
            data recovery to maintain business continuity. In this section, we're going to explore an

            04:42:28.560 --> 04:42:34.000
            example of Azure site recovery architecture. This disaster recovery solution utilizes Azure

            04:42:34.000 --> 04:42:38.720
            site recovery alongside other managed services like Traffic Manager and Virtual Network.

            04:42:38.720 --> 04:42:43.360
            This combination provides a cost effective and high availability environment suitable for small

            04:42:43.360 --> 04:42:48.240
            to medium businesses. This allows companies to focus more on their core solutions, benefiting

            04:42:48.240 --> 04:42:54.000
            various industries, including healthcare, travel and hospitality and manufacturing. For example,

            04:42:54.000 --> 04:42:58.640
            it can be used in portable healthcare clinics, restaurant chains and local logistics and supply

            04:42:58.640 --> 04:43:04.560
            chains. Here is a breakdown of the architecture. Traffic Manager, this Azure service routes DNS

            04:43:04.560 --> 04:43:09.040
            traffic, enabling easy redirection from one site to another based on policies set by your

            04:43:09.040 --> 04:43:14.480
            organization. Azure site recovery, this service handles the orchestration of machine replication

            04:43:14.480 --> 04:43:19.520
            and manages the setup of failback procedures. Virtual Network, this is the location where the

            04:43:19.520 --> 04:43:24.640
            failover site is established when a disaster happens. Blob storage, this is where the replica

            04:43:24.640 --> 04:43:30.000
            images of all machines protected by site recovery are stored. So that's an overview of the example

            04:43:30.000 --> 04:43:39.440
            Azure site recovery architecture shown. The next topic we'll be covering is the Azure backup

            04:43:39.440 --> 04:43:44.960
            service, another crucial tool for backup and disaster recovery solutions. Azure backup service

            04:43:44.960 --> 04:43:49.680
            is a cloud solution from Microsoft that offers secure, scalable and simple data backup and

            04:43:49.680 --> 04:43:55.520
            recovery across various Azure services. You won't find it by searching based on the service name.

            04:43:55.520 --> 04:44:00.160
            However, Azure backup is seamlessly integrated within numerous Azure services, making its

            04:44:00.160 --> 04:44:06.320
            operation quite intuitive. The five core components of Azure backup, Mars agent helps in backing up

            04:44:06.320 --> 04:44:11.120
            files, folders and system state data from on premises machines and Azure VMs to a backup

            04:44:11.120 --> 04:44:16.880
            recovery services vault in Azure recovery services vault manages and organizes your backups in a

            04:44:16.880 --> 04:44:22.720
            cost effective, secure and scalable manner. Azure backup server and would be s used to backup on

            04:44:22.720 --> 04:44:28.560
            premises data to Azure for hybrid protection. VM extension allows the backup of Azure VMs without

            04:44:28.560 --> 04:44:34.080
            the need to deploy any additional agents. Backup policy defines when and how your data is backed up.

            04:44:34.880 --> 04:44:41.680
            What can be backed up on premises Azure VMs, Azure managed disks, Azure file shares SQL server SAP

            04:44:41.680 --> 04:44:48.400
            HANA databases, Azure database for Postgres, QL servers and Azure blobs. Why use Azure backup

            04:44:48.400 --> 04:44:54.720
            offload on premises backups safeguard your data by moving backups to Azure backup Azure iOS VMs

            04:44:54.720 --> 04:45:00.160
            ensure your Azure VM data is protected. Scale easily adjust your backup storage size based on

            04:45:00.160 --> 04:45:06.400
            your needs. Get unlimited data transfer no limits or charges for data transfer. Keep data secure

            04:45:06.400 --> 04:45:11.520
            ensure your data is secure both at rest and in transit. Centralized monitoring and management

            04:45:11.520 --> 04:45:17.200
            have a unified view and manage your backups easily. App consistent backups restore applications back

            04:45:17.200 --> 04:45:23.120
            to a precise state. Automatic storage management no need to manage backup storage explicitly.

            04:45:23.120 --> 04:45:27.120
            Multiple storage options choose between different storage options based on your needs.

            04:45:27.760 --> 04:45:30.080
            So that's an overview of Azure backup service.

            04:45:30.080 --> 04:45:38.800
            The next topic will be covering is Azure Recovery Services Vault.

            04:45:38.800 --> 04:45:43.680
            Azure Recovery Services Vault is a storage entity in Azure that stores backup copies of data and

            04:45:43.680 --> 04:45:48.640
            configuration information over time. This data can be related to various Azure resources like

            04:45:48.640 --> 04:45:53.920
            virtual machines, workloads, servers or workstations. Backup for Azure services.

            04:45:53.920 --> 04:45:59.840
            Our vault protects data from various Azure services including iOS VMs, Azure SQL databases,

            04:45:59.840 --> 04:46:05.440
            Azure blob storage, Azure file shares and Azure functions. Recovery Services Vault supports

            04:46:05.440 --> 04:46:11.040
            various platforms including system center data protection manager, Windows Server,

            04:46:11.040 --> 04:46:15.520
            integrates with Azure backup server for application protection and other platforms.

            04:46:15.520 --> 04:46:21.280
            Recovery Services Vault has the following features. Enhanced security Azure Recovery

            04:46:21.280 --> 04:46:26.560
            Services Vault encrypts data in transit and at rest for secure backup and restore processes.

            04:46:26.560 --> 04:46:30.560
            Central monitoring the Azure portal allows centralized monitoring of all backup and

            04:46:30.560 --> 04:46:36.160
            restore tasks across hybrid environments. Azure role based access control Azure RBC

            04:46:36.160 --> 04:46:41.840
            enables granular access control and management of Recovery Services Vaults. Soft delete this feature

            04:46:41.840 --> 04:46:46.800
            retains backup data for an additional 14 days after deletion protecting against accidental or

            04:46:46.800 --> 04:46:52.560
            malicious data loss. Cross region restore CRR enables data restoration in a secondary region

            04:46:52.560 --> 04:46:57.920
            during a disaster in the primary region ensuring business continuity. So that's an overview of

            04:46:57.920 --> 04:47:08.560
            Azure Recovery Services Vault. Next, let's explore the Microsoft Azure Recovery Services agent.

            04:47:08.560 --> 04:47:13.280
            The Mars agent plays an important role in backing up files, folders and the system state from

            04:47:13.280 --> 04:47:18.880
            Windows based on premises machines and Azure VMs. All backups facilitated by the Mars agent are

            04:47:18.880 --> 04:47:24.000
            securely stored in a Recovery Services Vault in Azure. Mars agent is also known as the Azure

            04:47:24.000 --> 04:47:29.680
            backup agent. Note that the Mars agent does not support Linux operating systems. To get started

            04:47:29.680 --> 04:47:35.120
            with utilizing the Mars agent for backup purposes, follow these steps. Create an Azure Recovery

            04:47:35.120 --> 04:47:40.720
            Services Vault. This vault will store all the backups. Create a backup policy within the vault.

            04:47:40.720 --> 04:47:45.840
            Set the terms and conditions for backups, ensuring they align with your requirements. Configure

            04:47:45.840 --> 04:47:50.800
            secure route for backup. Depending on your security and performance needs, you might opt for pathways

            04:47:50.800 --> 04:47:56.560
            like express routes or private endpoints. Download the Mars agent. Download the agent from Azure.

            04:47:56.560 --> 04:48:01.600
            Install and register the agent to your Windows machine. Once installed, register it for activation

            04:48:01.600 --> 04:48:06.480
            and functionality. Overall, the Mars agent streamlines the backup process for Windows

            04:48:06.480 --> 04:48:11.440
            based systems, ensuring that data is both safely stored in Azure and swiftly recoverable when needed.

            04:48:11.440 --> 04:48:21.840
            Next, let's explore the Azure backup policy. Azure backup policy allows users to define and

            04:48:21.840 --> 04:48:26.480
            configure how data backups are managed on the Azure platform. It lets you set the frequency,

            04:48:26.480 --> 04:48:32.080
            retention duration and type of backups to ensure data protection and meet organizational requirements.

            04:48:32.080 --> 04:48:37.440
            Creating a backup policy in Azure involves a few essential steps. Select a data source type.

            04:48:37.440 --> 04:48:42.400
            Choose the type of data you want to backup, such as Azure Virtual Machines or PostgresQL database.

            04:48:42.400 --> 04:48:46.640
            Determine the frequency. Decide how often you want the backups to occur.

            04:48:46.640 --> 04:48:50.160
            This could be daily, weekly or any other frequency that suits your needs.

            04:48:50.160 --> 04:48:55.280
            Set the retention details. Determine how many snapshots or backup copies you wish to retain

            04:48:55.280 --> 04:49:00.080
            and for how long. Choose the time range for retention. Specify the time range during which

            04:49:00.080 --> 04:49:04.240
            you want to retain the backups. This setting helps in managing the life cycle of the backup

            04:49:04.240 --> 04:49:09.440
            data efficiently. In summary, Azure backup policy allows you to set customized backup

            04:49:09.440 --> 04:49:12.640
            and retention settings for reliable and consistent data protection.

            04:49:12.640 --> 04:49:23.040
            The next topic we'll be covering is Azure VM backup. Azure VM backup is a solution for backing

            04:49:23.040 --> 04:49:27.440
            up and restoring virtual machines running on Azure. It allows organizations to protect their

            04:49:27.440 --> 04:49:32.320
            virtual machines and their data against various issues such as accidental deletion, hardware

            04:49:32.320 --> 04:49:38.640
            failure, ransomware and other forms of data loss. How it works. Azure VM backup utilizes Azure backup

            04:49:38.640 --> 04:49:44.720
            to offer a centralized backup solution manageable through the Azure portal, PowerShell or REST APIs.

            04:49:44.720 --> 04:49:49.040
            It supports both Windows and Linux virtual machines, allowing for backup and restore

            04:49:49.040 --> 04:49:53.840
            operations at both the disk and VM levels. Multiple backup options are available,

            04:49:53.840 --> 04:49:59.520
            including full backups, incremental backups and differential backups. Backup retention policies

            04:49:59.520 --> 04:50:04.320
            enable organizations to retain backups for specified durations, enhancing data management

            04:50:04.320 --> 04:50:10.400
            and compliance. Key features. The solution employs the robust infrastructure of Azure backup,

            04:50:10.400 --> 04:50:14.560
            ensuring encryption at rest and support for backing up VMs across different regions and

            04:50:14.560 --> 04:50:20.000
            availability zones. The integration with recovery services vaults further strengthens the protection

            04:50:20.000 --> 04:50:26.320
            and management of backup data. Disaster recovery. Beyond backup, Azure VM backup bolsters disaster

            04:50:26.320 --> 04:50:30.880
            recovery strategies by enabling the replication of virtual machines to a secondary region.

            04:50:30.880 --> 04:50:36.400
            This redundancy is vital in mitigating the impact of outages or disasters. Organizations can

            04:50:36.400 --> 04:50:41.200
            seamlessly failover and failback virtual machines, ensuring minimal downtime and enhanced business

            04:50:41.200 --> 04:50:46.640
            continuity. In conclusion, Azure VM backup stands out as a resilient and dependable backup and

            04:50:46.640 --> 04:50:56.400
            recovery solution for Azure hosted virtual machines. Hey, this is Andrew Brown from exam Pro.

            04:50:56.400 --> 04:51:00.240
            And in this follow along, we're going to be looking at backup solutions for Azure. So let's

            04:51:00.240 --> 04:51:05.440
            make our way all the way to the top here and launch ourselves a virtual machine that we are going to

            04:51:05.440 --> 04:51:12.480
            be using as a means to backup. So what I'll do is create a new group here. And we will call it

            04:51:12.480 --> 04:51:18.960
            Picard. And we'll call this virtual machine Picard. And scrolling on down here. Yeah, I want to stick

            04:51:18.960 --> 04:51:25.680
            with a Windows Server 2019 Gen two. So go over here, select it as generation two there. And for

            04:51:25.680 --> 04:51:30.240
            the machine, you want to make sure it's a b2s because you need at least two VPC use and four

            04:51:30.240 --> 04:51:35.440
            gigabytes RAM to launch a Windows Server there. But the user is going to be Azure user for the

            04:51:35.440 --> 04:51:43.040
            password capital T testing 123456 capital T testing 123456. We'll have RDP. I'm not sure if

            04:51:43.040 --> 04:51:48.320
            we'll end up using it. But if we do, we have that open. We'll go ahead and go to the review page.

            04:51:48.320 --> 04:51:55.840
            Wait for it to allow us to hit Create, give it a moment. Great, we'll hit Create.

            04:51:55.840 --> 04:52:01.360
            And then we'll give it a moment to see that it is deploying. And if it's deploying,

            04:52:01.360 --> 04:52:06.080
            I'll see you back here in a moment. Great. So it looks like our virtual machine is ready to go here.

            04:52:06.080 --> 04:52:10.480
            So what we'll do is go all the way to the top here and type in backups, we go to vaults directly. But

            04:52:10.480 --> 04:52:15.520
            let's take a look here at the backup center, where we can kind of have a bit of an overview of stuff.

            04:52:15.520 --> 04:52:19.600
            So the idea is we have vaults where we're going to store our backups, we can create backup jobs,

            04:52:19.600 --> 04:52:24.640
            backup policies. So let's get to it and first create ourselves a vault. So we'll go ahead here

            04:52:24.640 --> 04:52:28.320
            and create ourselves a new vault. And we have two options, we have recovery services vault,

            04:52:28.320 --> 04:52:34.400
            or a backup vault. So the difference here is that one is just for backing up things like databases,

            04:52:34.400 --> 04:52:40.560
            disks, and etc. Where recovery services is more like a, like a site wide recovery. So you're

            04:52:40.560 --> 04:52:44.240
            going to notice that includes virtual machines and all these other stuff. Generally, you'll

            04:52:44.240 --> 04:52:49.280
            probably want to go with recovery services vaults, because it is just basically a new version of the

            04:52:49.280 --> 04:52:57.360
            backup vault. So let's go ahead and do that. And we'll place this in our Picard resource group

            04:52:57.360 --> 04:53:04.240
            there. And we'll just say Picard backup, or vault, vault, there we go. And we'll go ahead and hit

            04:53:04.240 --> 04:53:10.400
            review and create and we'll go and hit Create there. And we'll just give it a moment there to

            04:53:10.400 --> 04:53:15.920
            deploy. Alright, so our recovery services vault is ready. And we'll go ahead and click backup.

            04:53:15.920 --> 04:53:20.480
            And down below, ask us what kind we are running. So we have Azure Stack and on premise, it's just

            04:53:20.480 --> 04:53:25.360
            Azure, and we have a virtual machine. So we'll go ahead and hit backup. And notice that we'll have

            04:53:25.360 --> 04:53:29.600
            to set up a backup policy. And here we have a default one, but let's actually go make a new one.

            04:53:29.600 --> 04:53:33.360
            So we can kind of learn some of the settings that we can set. So we can say the frequency,

            04:53:33.360 --> 04:53:39.680
            the time, etc. Probably want to set this to my time zone. So I'm in Toronto, if I can find it here,

            04:53:39.680 --> 04:53:45.200
            which I believe is negative five. I was trying to type to see if I could do that. But I wasn't

            04:53:45.200 --> 04:53:50.880
            getting getting there too well. We'll just say Central Canada there, that's okay. It's off by

            04:53:50.880 --> 04:53:57.120
            an hour, but that's close enough. And you can have weekly, monthly and yearly backups, but we're going

            04:53:57.120 --> 04:54:03.280
            to stick with the daily backup for 30 days. And this is okay, we don't have to enter that in,

            04:54:03.280 --> 04:54:08.800
            we'll hit Oh, right. Okay. And now we can add our virtual machine. So we'll go here and select the

            04:54:08.800 --> 04:54:15.680
            card hit OK, enable backups. Please select at least one that has backups enabled. So what we'll do is

            04:54:15.680 --> 04:54:19.920
            open up our Azure tab here, make our way over to our virtual machine, just make sure that that stuff

            04:54:19.920 --> 04:54:33.680
            is enabled. So we'll go over here. And we'll go to backups. And here, we can actually even set it

            04:54:33.680 --> 04:54:43.200
            from here. So I guess we'll select our existing vault here. It'll say enable backups. That set

            04:54:43.200 --> 04:54:48.880
            it up with a default one, right? So I'm a bit surprised we couldn't do it that way. But we'll

            04:54:48.880 --> 04:54:54.320
            make our way back here. As long as it works. That's the thing with Azure. It's just you know,

            04:54:54.320 --> 04:54:58.800
            you'll do something and then you'll find that you have to do it slightly different. But we'll just

            04:54:58.800 --> 04:55:04.080
            wait until that's done there. So after waiting a very short while, it looks like our backups are

            04:55:04.080 --> 04:55:08.400
            turned on. So if we were to go to our overview and go to backups, you can see we have one backed up

            04:55:08.400 --> 04:55:12.400
            item. If we go over to our backup items, we'll see under virtual machines, we have the card,

            04:55:12.400 --> 04:55:18.240
            we did set the default policy. So I guess if we wanted to switch that out, we probably could if

            04:55:18.240 --> 04:55:23.840
            we just go back. And let's just go create a policy of our own just so that we are familiar with that

            04:55:23.840 --> 04:55:35.840
            there. And we'll say an Azure virtual machine one. So my special policy. Okay. And this is for 180

            04:55:35.840 --> 04:55:42.240
            days, we go ahead and hit Create. And once that policy is deployed, we'll be able to associate I

            04:55:42.240 --> 04:55:46.960
            can't remember if this will be super fast, but we'll give it a moment here. Yep, it is super fast.

            04:55:46.960 --> 04:55:51.360
            And then once we have that policy, we can go into it and then start assigning things to it.

            04:55:51.360 --> 04:55:56.080
            Actually, I think when I made the lecture content, I don't even remember there being a backup center.

            04:55:56.080 --> 04:56:00.880
            So to me, this is all a little bit new. So maybe I'll go back and up to the slides, because I

            04:56:00.880 --> 04:56:06.240
            usually say there is no centralized service, but they have one now. So that's pretty darn good.

            04:56:06.240 --> 04:56:13.040
            So for associated items, we don't fetching data for services completed. So I'm just trying to

            04:56:13.040 --> 04:56:18.480
            figure out how we can change that policy there. If we go to backup, so we just change it over here.

            04:56:18.480 --> 04:56:27.520
            I'm not sure how to switch out the policy. But I know at least if we want to do backup. Now we just

            04:56:27.520 --> 04:56:33.600
            press that there. It's really not that important to know how to swap out a policy. It's just more

            04:56:33.600 --> 04:56:37.200
            so the fact that you know what a backup policy is that you can apply to machines and things like

            04:56:37.200 --> 04:56:47.120
            that. Yeah, so there we go. We just had our own backup there. And, yeah, there's not much else

            04:56:47.120 --> 04:56:50.960
            here to look at. But yeah, there you go. So that's backup policies. So I guess what we'll do is go

            04:56:50.960 --> 04:57:01.760
            ahead and tear all this down. And so that was our book card there, we'll go ahead and delete this

            04:57:01.760 --> 04:57:14.080
            resource group. And there you go. Hey, this is Andrew Brown from exam Pro. In this section,

            04:57:14.080 --> 04:57:19.440
            we're diving into an introduction to Azure Kubernetes service or a chaos. Azure Kubernetes

            04:57:19.440 --> 04:57:24.640
            service simplifies the process of deploying a managed Kubernetes cluster in Azure. One of the

            04:57:24.640 --> 04:57:29.200
            main benefits of using a chaos is that Azure will take over the management of the Kubernetes master

            04:57:29.200 --> 04:57:34.160
            nodes for you, including health monitoring and routine maintenance. Your responsibility lies

            04:57:34.160 --> 04:57:39.600
            only in maintaining the agent nodes. An additional benefit is the cost effectiveness of a chaos. The

            04:57:39.600 --> 04:57:44.080
            service itself is free, you only incur charges for the agent nodes within the cluster, not the

            04:57:44.080 --> 04:57:49.120
            masters. When you deploy in a chaos cluster, both the Kubernetes master and all nodes are deployed

            04:57:49.120 --> 04:57:53.360
            and configured for you during the deployment process. You can also configure additional

            04:57:53.360 --> 04:57:59.600
            features such as advanced networking, Azure Active Directory integration to use Kubernetes role based

            04:57:59.600 --> 04:58:05.600
            access control, monitoring capabilities, and Windows Server containers are supported in a chaos.

            04:58:05.600 --> 04:58:11.440
            So when should one opt for a chaos? Well, a chaos is ideal in scenarios where you need full container

            04:58:11.440 --> 04:58:16.320
            orchestration. This includes situations demanding seamless service discovery across multiple

            04:58:16.320 --> 04:58:21.440
            containers, automatic scalability to handle varying loads and coordinated and smooth application

            04:58:21.440 --> 04:58:27.120
            upgrades. In summary, a chaos offers a streamlined managed solution for container orchestration in

            04:58:27.120 --> 04:58:36.400
            Azure simplifying the setup and maintenance of a Kubernetes cluster. The next topic we'll be

            04:58:36.400 --> 04:58:41.600
            covering is called bridge to Kubernetes. Bridge to Kubernetes is an extension available for both

            04:58:41.600 --> 04:58:47.040
            Visual Studio and Visual Studio code that allows developers to write test and debug microservice

            04:58:47.040 --> 04:58:51.680
            code directly on their local development workstations. With bridge to Kubernetes, you

            04:58:51.680 --> 04:58:56.240
            can integrate a service running locally with your chaos cluster. This bypasses the need to create

            04:58:56.240 --> 04:59:01.360
            Docker and Kubernetes configurations. For the lifetime of this connection, a proxy is added

            04:59:01.360 --> 04:59:05.200
            to your cluster in place of your Kubernetes deployment that redirects requests to the

            04:59:05.200 --> 04:59:09.680
            service to your development computer. When you disconnect, the application deployment will revert

            04:59:09.680 --> 04:59:14.080
            to using the original version of the deployment running on the cluster. It's important to note

            04:59:14.080 --> 04:59:20.320
            that Azure Dev spaces will be retired on October 31 2023. Existing users are encouraged to transition

            04:59:20.320 --> 04:59:24.640
            to using bridge to Kubernetes as their client development tool ensuring a streamlined and

            04:59:24.640 --> 04:59:29.120
            integrated development experience on their local machines while interacting with the chaos clusters.

            04:59:29.120 --> 04:59:32.560
            So that's a brief overview bridge to Kubernetes,

            04:59:32.560 --> 04:59:36.160
            a very useful tool to streamline development and debugging for developers.

            04:59:41.200 --> 04:59:45.360
            The next topic we'll be covering are the recovery solutions for Azure Kubernetes service.

            04:59:45.360 --> 04:59:50.640
            Best practices for business continuity and disaster recovery in Azure Kubernetes service.

            04:59:50.640 --> 04:59:55.680
            Use multiple availability zones. Azure AKS supports multiple availability zones,

            04:59:55.680 --> 04:59:59.840
            which distribute your application across different data centers. This ensures high

            04:59:59.840 --> 05:00:04.000
            availability and resiliency in the event of a data center failure. When you create a new

            05:00:04.000 --> 05:00:07.840
            AKS cluster, you can choose to create it across multiple availability zones.

            05:00:08.560 --> 05:00:12.960
            Implement backup and restore backing up your AKS cluster ensures that you have a copy of your

            05:00:12.960 --> 05:00:17.920
            application and data in case of data loss or corruption. Azure AKS supports backing up your

            05:00:17.920 --> 05:00:23.360
            application data and Kubernetes resources such as deployments and services using the Valero backup

            05:00:23.360 --> 05:00:29.120
            and restore tool. Use Azure site recovery. Azure site recovery is a disaster recovery solution that

            05:00:29.120 --> 05:00:33.840
            replicates your AKS cluster to a secondary location. This can be useful in the event of a

            05:00:33.840 --> 05:00:38.320
            disaster or outage as you can fail over to the secondary location and resume operations.

            05:00:38.320 --> 05:00:44.560
            For monitor your AKS cluster, it is important to monitor your AKS cluster for any potential

            05:00:44.560 --> 05:00:49.280
            issues or failures. Azure provides a range of monitoring and alerting solutions such as Azure

            05:00:49.280 --> 05:00:53.600
            monitor and Azure service health, which can help you proactively detect and respond to issues.

            05:00:53.600 --> 05:00:59.680
            Five, test your disaster recovery plan to ensure that your disaster recovery plan is effective.

            05:00:59.680 --> 05:01:04.160
            It is important to test it regularly. You can use tools like Azure site recovery to perform

            05:01:04.160 --> 05:01:08.400
            failover tests and ensure that your AKS cluster can be recovered in the event of a disaster.

            05:01:08.400 --> 05:01:14.480
            Six, use Azure Kubernetes service with Azure Arc. Azure Arc enables you to manage your AKS cluster

            05:01:14.480 --> 05:01:19.040
            and other Kubernetes clusters across multiple clouds and on-premises environments from a single

            05:01:19.040 --> 05:01:24.160
            control plane. This provides greater flexibility and resilience in the event of a disaster or outage.

            05:01:24.160 --> 05:01:28.800
            By following these best practices, you can ensure that your Azure Kubernetes service

            05:01:28.800 --> 05:01:33.440
            cluster is resilient, highly available and recoverable in the event of a disaster or outage.

            05:01:33.440 --> 05:01:42.880
            Hey, this is Andrew Brown from exam Pro. And in this section, we'll be covering Azure regions and

            05:01:42.880 --> 05:01:48.000
            availability zones starting with Azure regions. Azure regions are physical locations around the

            05:01:48.000 --> 05:01:53.200
            world where Microsoft has data centers to provide cloud services. Each region is composed of multiple

            05:01:53.200 --> 05:01:57.600
            data centers that are geographically dispersed to provide redundancy, resilience and high

            05:01:57.600 --> 05:02:03.600
            availability to customers. Key facts about Azure regions, multiple data centers, each region is

            05:02:03.600 --> 05:02:07.920
            made up of at least one data center, but many regions have multiple data centers for added

            05:02:07.920 --> 05:02:13.040
            redundancy and availability. Global presence, Azure regions are distributed around the world

            05:02:13.040 --> 05:02:19.120
            covering almost every major continent and country. Unique identifiers, each Azure region is designated

            05:02:19.120 --> 05:02:23.920
            by a distinct name such as East US or West Europe, which indicates its geographical location.

            05:02:24.560 --> 05:02:28.960
            Resource deployment, when creating resources in Azure, you can choose which region to deploy them

            05:02:28.960 --> 05:02:33.760
            to based on factors such as proximity to users, data sovereignty requirements and service

            05:02:33.760 --> 05:02:39.440
            availability. Data residency data in a region stays within that region unless explicitly copied

            05:02:39.440 --> 05:02:45.760
            or replicated to another region for redundancy or disaster recovery purposes. Continuous expansion,

            05:02:45.760 --> 05:02:50.640
            Microsoft continually expands its Azure footprint, adding new regions to cater to emerging markets

            05:02:50.640 --> 05:02:56.080
            and customer needs. In essence, Azure regions are the cornerstone of Azure's global infrastructure,

            05:02:56.080 --> 05:03:00.240
            guaranteeing high availability, redundancy and adherence to regional data norms.

            05:03:00.240 --> 05:03:10.160
            The next topic we'll be covering are Azure availability zones. Azure availability zones

            05:03:10.160 --> 05:03:14.560
            are physical data center locations within an Azure region that are typically located in separate

            05:03:14.560 --> 05:03:19.200
            buildings or regions, but still close enough to provide low latency network connectivity.

            05:03:19.200 --> 05:03:23.520
            These zones help protect applications and data from data center level failures by providing

            05:03:23.520 --> 05:03:29.120
            redundant power, cooling and networking. An Azure region is a geographic location that contains one

            05:03:29.120 --> 05:03:34.400
            or more data centers. An availability zone is a unique physical location within an Azure region.

            05:03:34.400 --> 05:03:39.920
            Key points of Azure availability zones. Each availability zone is composed of one or more

            05:03:39.920 --> 05:03:44.880
            data centers with independent power, cooling and networking. Each data center within an

            05:03:44.880 --> 05:03:50.320
            availability zone is connected through a high speed low latency network. Availability zones

            05:03:50.320 --> 05:03:54.720
            are designed to provide high availability for critical applications by distributing them across

            05:03:54.720 --> 05:04:00.240
            different zones. By deploying applications across multiple zones, it is possible to achieve a higher

            05:04:00.240 --> 05:04:06.000
            level of redundancy and fault tolerance. Virtual machines, storage accounts and other Azure resources

            05:04:06.000 --> 05:04:10.240
            can be deployed to specific availability zones within a region to ensure high availability.

            05:04:10.880 --> 05:04:15.760
            Azure Traffic Manager can be used to route traffic between different zones based on various criteria

            05:04:15.760 --> 05:04:20.960
            such as geographic location, latency and performance. So that's an overview of Azure

            05:04:20.960 --> 05:04:30.240
            availability zones. The next topic we'll be covering are the availability options for Azure

            05:04:30.240 --> 05:04:34.720
            virtual machines. While we've briefly mentioned these terms in the past, we'll now explore them

            05:04:34.720 --> 05:04:40.240
            in detail, specifically in the context of VMs. Azure virtual machines provide several options

            05:04:40.240 --> 05:04:44.560
            for achieving high availability and ensuring business continuity. Here are the primary

            05:04:44.560 --> 05:04:50.640
            strategies. Availability sets. An availability set is a logical grouping that informs Azure about

            05:04:50.640 --> 05:04:56.000
            application redundancy and availability requirements. Ideally to ensure high availability

            05:04:56.000 --> 05:05:02.400
            and meet Azure's 99.95% SLA, place at least two VMs within an availability set. There are no

            05:05:02.400 --> 05:05:07.360
            charges for the availability set itself. Costs arise only for the individual VM instances created

            05:05:07.360 --> 05:05:12.960
            within virtual machine scale sets. These sets enable the automatic deployment and scalability

            05:05:12.960 --> 05:05:18.560
            of identical VMs. VMs can auto adjust their capacity as per demand, facilitating auto scaling

            05:05:18.560 --> 05:05:23.920
            for applications. VM scale sets are built to integrate with Azure load balancer and application

            05:05:23.920 --> 05:05:29.760
            gateway, ensuring traffic is evenly distributed across VM instances. VM distribution across fault

            05:05:29.760 --> 05:05:36.160
            domains and update domains further fortifies high availability. Azure site recovery. This service

            05:05:36.160 --> 05:05:41.920
            delivers disaster recovery capabilities for VMs. It facilitates VM replication to a secondary

            05:05:41.920 --> 05:05:46.640
            location, which could be another Azure region, a different data center or an on premises site.

            05:05:46.640 --> 05:05:52.320
            Both physical servers and virtual ones, including those on Hyper-V and VMware can be replicated

            05:05:52.320 --> 05:05:58.960
            using site recovery. Azure backup. Azure backup offers backup solutions for VMs, their applications

            05:05:58.960 --> 05:06:04.160
            and data. You can back up to the cloud, ensuring backups are application consistent, meaning they're

            05:06:04.160 --> 05:06:08.880
            usable and can be restored as needed. These backups can either be retained in the originating

            05:06:08.880 --> 05:06:13.840
            region or transfer to another for disaster recovery. Additionally, Azure backup provides

            05:06:13.840 --> 05:06:18.560
            extensive retention periods and backup archiving aligning with regulatory compliance needs.

            05:06:18.560 --> 05:06:23.520
            Overall, these are the main options for availability options for Azure virtual machines.

            05:06:23.520 --> 05:06:33.040
            Hey, this is Andrew Brown from exam Pro and in this section we'll be going over Azure virtual

            05:06:33.040 --> 05:06:37.840
            machines. Azure virtual machines offer a highly configurable server experience.

            05:06:37.840 --> 05:06:42.000
            Through virtualization, you can run a server without the hassles and expenses of maintaining

            05:06:42.000 --> 05:06:47.200
            physical hardware. However, it's important to note that VMs are not entirely maintenance free.

            05:06:47.200 --> 05:06:51.920
            They still require OS patch applications and package installations and configurations.

            05:06:51.920 --> 05:06:58.640
            Key points about Azure VMs configuration and size. The size of the VM is determined by its image.

            05:06:58.640 --> 05:07:04.960
            This image defines the combination of vcpus memory and storage capacity subscription limits.

            05:07:04.960 --> 05:07:08.800
            As of now, there's a limit of 20 VMs per region on a per subscription basis.

            05:07:08.800 --> 05:07:16.720
            Billing Azure VMs are billed at an hourly rate. Availability a single instance VM offers 99.9%

            05:07:16.720 --> 05:07:22.880
            availability when all its storage disks are a premium quality to achieve a 99.95% availability

            05:07:22.880 --> 05:07:28.240
            deploy to instances in an availability set. Storage you can attach multiple managed disks

            05:07:28.240 --> 05:07:33.520
            to your Azure VMs. Networking components when you launch an Azure virtual machine,

            05:07:33.520 --> 05:07:37.600
            other networking components will be either created or associated to your virtual machine,

            05:07:37.600 --> 05:07:43.200
            including network security group, a virtual firewall with rules concerning ports and protocols.

            05:07:43.200 --> 05:07:48.560
            This is attached to the NIC network interface, a device that handles IP protocols and network

            05:07:48.560 --> 05:07:54.560
            communication. Virtual machine instance, the actual server that's running public IP address,

            05:07:54.560 --> 05:07:59.520
            the address that you will use publicly access your VM virtual network, the network in which

            05:07:59.520 --> 05:08:04.720
            your VM is located. Overall, Azure virtual machines offer a versatile and strong cloud

            05:08:04.720 --> 05:08:09.120
            computing space allowing easy and seamless deployment of robust applications and systems.

            05:08:09.120 --> 05:08:19.520
            The next topic we'll be covering our operation systems in Azure VMs. So what is it operation

            05:08:19.520 --> 05:08:24.000
            system? Well, I'm sure you already know this, but the OS is the program that manages all other

            05:08:24.000 --> 05:08:29.760
            programs in a computer. The most commonly known operation systems are Windows, Mac OS and Linux.

            05:08:29.760 --> 05:08:33.840
            When you launch a virtual machine, you need to choose an image which has a specific operation

            05:08:33.840 --> 05:08:38.880
            system. Microsoft works closely with partners to ensure the images available are updated and

            05:08:38.880 --> 05:08:43.520
            optimized for an Azure runtime. You can find most of these images in the Azure marketplace,

            05:08:43.520 --> 05:08:50.160
            including as USC Linux Enterprise Server, Red Hat Enterprise Linux, Ubuntu server,

            05:08:50.160 --> 05:08:57.360
            Debian, FreeBSD, Azure Marketplace, Flat Car Container Linux, Rancher OS, Bitnami library for

            05:08:57.360 --> 05:09:04.640
            Azure, Mesosphere DC OS on Azure, Docker images, CloudBees Jenkins platform. If the available

            05:09:04.640 --> 05:09:08.960
            options do not meet your requirements, you can bring your own Linux by creating a Linux virtual

            05:09:08.960 --> 05:09:14.720
            hard disk. Note that in Azure only the fixed VHD format is supported not the Hyper-V virtual hard

            05:09:14.720 --> 05:09:21.840
            disk format. So that's an overview of the operating systems in Azure VMs.

            05:09:21.840 --> 05:09:29.680
            The next topic we'll be covering are the sizes of Azure VMs. Azure VMs come in a variety of sizes

            05:09:29.680 --> 05:09:35.440
            that are also optimized for specific use cases. Azure VMs are grouped into types such as general

            05:09:35.440 --> 05:09:42.480
            purposes and compute optimized and sizes such as B and DSV3 also called series or SKU family,

            05:09:42.480 --> 05:09:48.560
            general purpose balanced CPU to memory ratio, testing and development, small to medium databases

            05:09:48.560 --> 05:09:56.080
            and low to medium traffic web servers, SKUs, B, DSV3, DV3, DAS4, DAV4, DSV2, and so on.

            05:09:56.080 --> 05:10:03.040
            Compute optimized high CPU to memory ratio good for medium traffic web servers, network appliances,

            05:10:03.040 --> 05:10:11.600
            batch processes and app servers, SKUs, FFS, FSV2. Memory optimized high memory to CPU ratio best for

            05:10:11.600 --> 05:10:17.920
            relational database servers, medium to large caches and in memory analytics, SKUs, S3, F3,

            05:10:17.920 --> 05:10:25.920
            E4, E4, F4, S4, and so on. Storage optimized offers high disk throughput and I/O ideal for big data,

            05:10:25.920 --> 05:10:34.400
            SQL and OSQL databases, data warehousing and large transactional databases, SKUs, LSV2. GPU

            05:10:34.400 --> 05:10:39.040
            specialized VMs for heavy graphic rendering and video editing, model training and inferencing

            05:10:39.040 --> 05:10:47.200
            with deep learning available with single or multiple GPUs, SKUs, NC, NCV2, NCV3, NCAST4V3,

            05:10:47.200 --> 05:10:53.680
            ND and so on. High performance compute features the fastest and most powerful CPU virtual machines

            05:10:53.680 --> 05:11:01.120
            with optional high throughput network interfaces, SKUs, HB, HBV2, HC, H. There are previous series

            05:11:01.120 --> 05:11:07.360
            of virtual machine sizes not shown here like basic A. The type of image may limit you to specific VM

            05:11:07.360 --> 05:11:13.360
            sizes. Use Azure sorting and filtering options to explore sizes based on various parameters such as

            05:11:13.360 --> 05:11:19.600
            cost. Azure compute unit provides a way of comparing compute performance across Azure SKUs.

            05:11:19.600 --> 05:11:26.240
            ACU is standardized on a small VM assigned a value of 100. All other SKUs then represent

            05:11:26.240 --> 05:11:31.840
            approximately how much faster that SKU can run a standard benchmark. Let's break down the provided

            05:11:31.840 --> 05:11:40.320
            information. A1, A4 SKU family, CU, vCPU 100. ACU stands for Azure compute unit, which is a measure

            05:11:40.320 --> 05:11:45.040
            of the relative computational performance of different Azure SKUs. In this family, each

            05:11:45.040 --> 05:11:52.880
            virtual CPU is rated at 100 ACUs. vCPU core one to one. This means for every virtual CPU allocate,

            05:11:52.880 --> 05:12:02.480
            it corresponds to one physical core. D1, D14 SKU family. ACU vCPU ranges between 160 to 250.

            05:12:02.480 --> 05:12:07.280
            This indicates that VMs in this family have a higher computational performance per vCPU compared

            05:12:07.280 --> 05:12:14.240
            to the series vCPU core one to one. Similar to the series, each virtual CPU corresponds to one

            05:12:14.240 --> 05:12:19.760
            physical core. In summary, knowing Azure VM sizes helps pick the best option for your needs,

            05:12:19.760 --> 05:12:29.760
            ensuring efficiency and cost effectiveness. The upcoming topic explores Hyper-V, focusing

            05:12:29.760 --> 05:12:35.440
            on the distinctions between generation one and generation two. Hyper-V is a hardware virtualization

            05:12:35.440 --> 05:12:40.720
            product from Microsoft, enabling the creation and management of virtual machines. Each VM functions

            05:12:40.720 --> 05:12:44.960
            as a separate computer equipped with its own operating system and software applications.

            05:12:45.520 --> 05:12:51.280
            In many ways, Hyper-V mirrors the functionalities of VirtualBox. There are two generations of Hyper-V

            05:12:51.280 --> 05:12:57.360
            VMs. Generation one supports a wide range of guest operating systems. Generation two primarily

            05:12:57.360 --> 05:13:03.120
            supports 64 bit versions of Windows alongside more recent versions of Linux and FreeBSD operating

            05:13:03.120 --> 05:13:08.640
            systems. Azure offers both generation one and generation two VMs aligning with Hyper-V and

            05:13:08.640 --> 05:13:14.000
            structure but bearing distinct characteristics. Key differences between Azure Gen one and Gen two.

            05:13:14.640 --> 05:13:20.640
            Gen one based on BIOS architecture. Gen two utilizes UEFI based boot architecture,

            05:13:20.640 --> 05:13:25.760
            enhancing boot and installation times. Only Gen two VMs employ secure boot, ensuring the boot

            05:13:25.760 --> 05:13:30.880
            loader is authenticated by a trustworthy source. Gen two VMs support a substantially larger boot

            05:13:30.880 --> 05:13:38.000
            volume of up to 64 terabytes. Hyper-V VMs are packaged as either VHD or VHDX files, consolidating

            05:13:38.000 --> 05:13:42.480
            their structural components for efficient management and deployment. In conclusion,

            05:13:42.480 --> 05:13:47.840
            understanding Hyper-V generations aids in optimizing virtualization and ensuring OS compatibility.

            05:13:47.840 --> 05:13:58.960
            The next topic we'll be covering is SSH, RDP, and Bastion. Azure virtual machines offer multiple

            05:13:58.960 --> 05:14:05.440
            methods to connect, including SSH, RDP, and Bastion. Let's dive into each. SecureShell is a

            05:14:05.440 --> 05:14:10.400
            protocol to establish a secure connection between a client and server. This is used to remotely

            05:14:10.400 --> 05:14:16.960
            connect to your Azure VM via the terminal. SSH operates on port 22 via TCP. RSA key pairs are

            05:14:16.960 --> 05:14:22.720
            commonly used to authorize access. Remote Desktop Protocol is a proprietary protocol developed by

            05:14:22.720 --> 05:14:27.280
            Microsoft which provides a user with a graphical interface to connect to another computer over a

            05:14:27.280 --> 05:14:32.720
            network connection. This is how you can remotely connect to Windows Server via virtual desktop.

            05:14:32.720 --> 05:14:40.480
            RDP operates on port 3389, utilizing both TCP and UDP. Bastion, Azure Bastion is a service you

            05:14:40.480 --> 05:14:45.200
            deploy that lets you connect to a virtual machine using your browser and the Azure portal. It

            05:14:45.200 --> 05:14:50.640
            provides secure and seamless RDP SSH connectivity to your virtual machines directly from the Azure

            05:14:50.640 --> 05:14:56.160
            portal over TLS. Bastion is a hardened instance that is monitored. Users connect to this VM which

            05:14:56.160 --> 05:15:01.440
            then establishes a connection to the target instance, sometimes known as Jump. So to ensure

            05:15:01.440 --> 05:15:05.760
            optimized security and connectivity, it's important to understand these methods. We'll

            05:15:05.760 --> 05:15:16.000
            delve deeper into each in subsequent sections. Let's go into a bit more detail with SSH.

            05:15:16.000 --> 05:15:21.440
            SecureShell or SSH is a cryptographic network protocol commonly employed to securely access

            05:15:21.440 --> 05:15:26.720
            and manage servers remotely. It is very common to use SSH key pairs as a means to authenticate to

            05:15:26.720 --> 05:15:32.960
            your VMs. SSH key pairs is when you generate out two keys. A private key, this is the key that

            05:15:32.960 --> 05:15:37.600
            remains confidential and should never be shared or exposed. It is stored securely on your local

            05:15:37.600 --> 05:15:43.280
            system and is used to initiate a connection to the VM. A public key, as the name suggests, this key

            05:15:43.280 --> 05:15:49.360
            can be shared publicly. It is added to the server's or VM's authorized keys list. How does SSH key

            05:15:49.360 --> 05:15:55.040
            authentication work? When you attempt to SSH into a server, your system uses the private key to send

            05:15:55.040 --> 05:16:00.000
            a cryptographic proof. The server, which has the corresponding public key, verifies the authenticity

            05:16:00.000 --> 05:16:04.400
            of the cryptographic proof. If the proof is verified, meaning the keys have matched, you're

            05:16:04.400 --> 05:16:11.440
            authenticated and granted access. Advantages of using SSH key pairs. Security, SSH keys provide

            05:16:11.440 --> 05:16:15.520
            a more secure method of authentication than traditional passwords. Without the correct

            05:16:15.520 --> 05:16:20.880
            private key, unauthorized access attempts are effectively thwarted. Convenience, once set up,

            05:16:20.880 --> 05:16:25.600
            users can connect without needing to remember and input a password each time. Automation,

            05:16:25.600 --> 05:16:30.560
            automated scripts and services can use key pairs to establish connections without human intervention.

            05:16:30.560 --> 05:16:33.520
            So that's a more in-depth look into SSH.

            05:16:33.520 --> 05:16:44.000
            Let's dive into the remote desktop protocol, commonly known as RDP. RDP is a protocol

            05:16:44.000 --> 05:16:48.000
            developed by Microsoft that allows users to remotely connect to Windows systems.

            05:16:48.000 --> 05:16:52.880
            When you want to use RDP to access your Windows server, you'll first need to download the RDP file.

            05:16:52.880 --> 05:16:58.480
            For Windows 10 users, the remote desktop client is pre-installed, so there's no additional software

            05:16:58.480 --> 05:17:04.080
            to download. However, if you're using Mac OS, you can easily get the Microsoft remote desktop app

            05:17:04.080 --> 05:17:09.680
            from the Apple Store. Once you've got the necessary tools, simply open the downloaded RDP file.

            05:17:09.680 --> 05:17:13.760
            During this process, you'll be prompted to enter the username and password that you set up during

            05:17:13.760 --> 05:17:19.200
            the creation of your VM on the Azure portal. RDP uses encryption to secure communications,

            05:17:19.200 --> 05:17:24.400
            ensuring confidentiality. It also supports features like audio redirection, clipboard sharing,

            05:17:24.400 --> 05:17:28.640
            and printer redirection for a seamless remote experience. In conclusion,

            05:17:28.640 --> 05:17:32.080
            RDP provides an efficient way to remotely access Windows systems.

            05:17:32.080 --> 05:17:42.480
            The next topic we'll be covering is Azure Bastion. Azure Bastion serves as a secure bridge,

            05:17:42.480 --> 05:17:47.280
            enabling you to connect to your server via SSH or RDP without exposing it to the public.

            05:17:47.280 --> 05:17:52.560
            It will provision a web-based interface for both RDP and SSH, eliminating the need for external

            05:17:52.560 --> 05:17:58.000
            clients. This can be especially useful for devices like Google Chromebooks, which might not support

            05:17:58.000 --> 05:18:03.360
            traditional RDP clients. When setting up Azure Bastion, you'll need to add a dedicated subnet

            05:18:03.360 --> 05:18:08.640
            to your virtual network named Azure Bastion Subnet. This subnet should have at least a 27 size,

            05:18:08.640 --> 05:18:14.800
            equating to 32 addresses. If you have a Windows server which requires RDP and have a Bastion in

            05:18:14.800 --> 05:18:20.640
            the same VNet, you simply enter in your username and password as you normally would. If you have

            05:18:20.640 --> 05:18:26.320
            a Linux server, you can SSH with the Bastion. You can use SSH private key or password that you set

            05:18:26.320 --> 05:18:33.040
            when you created your VM. Key Benefits. Single click access, RDP and SSH sessions available

            05:18:33.040 --> 05:18:39.280
            directly through the Azure portal. Secure session, Azure Bastion offers RDP, SSH over TLS with

            05:18:39.280 --> 05:18:46.320
            support for TLS 1.2 plus. No public IP needed, RDP, SSH connects via the VM's private IP.

            05:18:46.320 --> 05:18:53.120
            Simplified NSG management, no need for NSGs on the Azure Bastion subnet, allows RDP, SSH solely

            05:18:53.120 --> 05:19:00.000
            from Azure Bastion. Managed service, Azure Bastion is a fully managed secure platform for RDP, SSH.

            05:19:00.720 --> 05:19:04.960
            Protection from scans, VMs aren't exposed to the internet, preventing port scanning.

            05:19:04.960 --> 05:19:10.160
            Centralized hardening, Bastion at the VNet perimeter eliminates individual VM hardening.

            05:19:10.160 --> 05:19:13.040
            So that's an overview of Azure Bastion.

            05:19:13.040 --> 05:19:21.440
            Let's take a look at a comparison between Windows versus Linux servers.

            05:19:21.440 --> 05:19:26.560
            Azure VMs offer the flexibility to run both Windows and Linux based servers.

            05:19:26.560 --> 05:19:32.160
            Windows licensing to run Windows, you'll need a valid license. If you don't activate it, certain

            05:19:32.160 --> 05:19:36.960
            features may be restricted. Azure does offer a way to leverage existing licenses through its hybrid

            05:19:36.960 --> 05:19:42.880
            benefit program. Authentication, typically you set up a username and password during the VM creation.

            05:19:42.880 --> 05:19:48.240
            Instant size to smoothly operate Windows, you typically need a larger VM size starting at

            05:19:48.240 --> 05:19:53.840
            least with a B2 due to its comprehensive desktop environment. Environment, Windows provides a full

            05:19:53.840 --> 05:19:58.560
            desktop environment complete with a graphical user interface, making it more intuitive for those

            05:19:58.560 --> 05:20:04.320
            familiar with the Windows ecosystem. Linux licensing, most Linux distributions are open

            05:20:04.320 --> 05:20:10.400
            source and don't require any licensing fees. Authentication, Linux offers flexible authentication,

            05:20:10.400 --> 05:20:15.360
            you can set up a username and password or more commonly use SSH key pairs for a more secure

            05:20:15.360 --> 05:20:21.040
            connection. Instant size Linux servers, especially those without a graphical user interface have

            05:20:21.040 --> 05:20:26.240
            minimal system requirements. This means you can run them on smaller VM sizes, conserving resources

            05:20:26.240 --> 05:20:31.840
            and cost. Environment, traditionally Linux systems operate with a terminal based environment,

            05:20:31.840 --> 05:20:37.120
            although there are distributions with graphical interfaces. Overall, your choice between Windows

            05:20:37.120 --> 05:20:41.280
            and Linux will largely depend on the specific needs of your project, familiarity with the

            05:20:41.280 --> 05:20:51.520
            operating system, licensing costs and desired system resources. The next topic we'll be covering

            05:20:51.520 --> 05:20:57.040
            is update management in Azure. Update management allows you to manage and install operating system

            05:20:57.040 --> 05:21:01.520
            updates and patches for both Windows and Linux virtual machines that are deployed in Azure on

            05:21:01.520 --> 05:21:06.960
            premises or with other cloud providers. When you launch an Azure VM, you can go to operations and

            05:21:06.960 --> 05:21:11.840
            turn on guest plus host updates. This will install the Microsoft monitoring agent that will be used

            05:21:11.840 --> 05:21:17.200
            to monitor your instances. Azure automations is the underlying service that is installed the agent.

            05:21:17.200 --> 05:21:23.200
            Update management will perform a scan for update compliance. By default, a compliance scan is

            05:21:23.200 --> 05:21:28.320
            performed every 12 hours on Windows and every three hours on Linux. It can take between 30

            05:21:28.320 --> 05:21:32.400
            minutes and six hours for the dashboard to display updated data from managed computers.

            05:21:33.040 --> 05:21:37.600
            In Azure automation, you can enable the update management change tracking and inventory and

            05:21:37.600 --> 05:21:42.480
            start or stop VMs during off hours features for your servers and virtual machines. These features

            05:21:42.480 --> 05:21:47.040
            have a dependency on a log analytics workspace and therefore require linking the workspace with

            05:21:47.040 --> 05:21:51.840
            an automation account. So Azure's update management offers a comprehensive solution

            05:21:51.840 --> 05:21:56.000
            for ensuring your virtual machines are always up to date with the latest patches and updates.

            05:22:00.880 --> 05:22:05.360
            All right, let's take a look at Azure Virtual Desktop, formerly known as Windows Virtual

            05:22:05.360 --> 05:22:11.200
            Desktop. Azure Virtual Desktop on Microsoft Azure is a desktop and app virtualization service that

            05:22:11.200 --> 05:22:17.520
            runs on the cloud. Azure Virtual Desktop works across devices like Windows, Mac iOS, Android

            05:22:17.520 --> 05:22:22.720
            and Linux with apps that you can use to access remote desktops and apps. You can use most modern

            05:22:22.720 --> 05:22:28.800
            browsers to access Azure Virtual Desktop hosted experiences. Use Azure Virtual Desktop for specific

            05:22:28.800 --> 05:22:33.040
            needs like when security is a concern because all data is saved on the server and cannot be left on

            05:22:33.040 --> 05:22:39.040
            the device of a user. key features and benefits enable secure and productive remote work on any

            05:22:39.040 --> 05:22:44.640
            device. Azure Virtual Desktop provides full Windows 10 and Windows Server desktop and application

            05:22:44.640 --> 05:22:51.280
            virtualization on any personal device. seamless integration with Microsoft 365 apps for enterprise

            05:22:51.280 --> 05:22:57.600
            and Microsoft Teams. reduce costs of licensing and infrastructure. Use eligible Windows or Microsoft

            05:22:57.600 --> 05:23:04.320
            365 licenses to access Windows Virtual Desktop and pay only for what you use. Protect against outages

            05:23:04.320 --> 05:23:09.200
            to stay productive. Help keep your team running during outages by leveraging built in Azure site

            05:23:09.200 --> 05:23:15.840
            recovery and Azure backup technologies. Simplify IT management. Windows Virtual Desktop manages the

            05:23:15.840 --> 05:23:21.040
            virtual desktop infrastructure for you so you can focus on users, apps and OS images instead of

            05:23:21.040 --> 05:23:27.120
            hardware and maintenance. Keep application and user data secure. Easily apply the right access

            05:23:27.120 --> 05:23:32.960
            controls to users and devices with Azure Active Directory conditional access. So that's an overview

            05:23:32.960 --> 05:23:42.240
            of Azure Virtual Desktop. Hey, this is Andrew Brown from exam Pro. And we're going to be launching

            05:23:42.240 --> 05:23:47.600
            our own bastion using Azure bastion services. So there's two ways to set this up, we can go to

            05:23:47.600 --> 05:23:53.280
            bastions over here, and create a bastion this way. Or we can create one. After we've created a

            05:23:53.280 --> 05:23:58.720
            virtual machine, I prefer the latter. So let's go ahead and do that and launch ourselves a new

            05:23:58.720 --> 05:24:04.560
            virtual machine. And so we could either use launch a Windows Server or a Linux server. Today, I'm

            05:24:04.560 --> 05:24:11.200
            gonna be launching a Windows Server. And what we'll do is go down here, I'll make a new group,

            05:24:11.200 --> 05:24:22.000
            we'll call it the enterprise. And as we do that, we'll just name this enterprise D. And we'll

            05:24:22.000 --> 05:24:28.400
            launch that in Canada, central or us or central us, that's fine with me. 2019 data center gen two is

            05:24:28.400 --> 05:24:34.640
            totally fine. If you go here, you're trying to find it, you go hit select. And we'll choose gen

            05:24:34.640 --> 05:24:40.160
            two data center. It is expensive, but we're not going to be using this for very long. For the

            05:24:40.160 --> 05:24:45.840
            username, I'm going to put data. And for the I'll just make it Azure user to make our lives a bit

            05:24:45.840 --> 05:24:54.240
            easier. And then we'll put testing capital T 123456. Testing 123456. And we will go down below,

            05:24:54.240 --> 05:24:57.600
            we're fine with the settings here, we're going to go next to disk, we're gonna leave the disk

            05:24:57.600 --> 05:25:04.240
            to premium, that's fine. I will let it create a new network, that's totally fine. Management is okay.

            05:25:04.240 --> 05:25:06.320
            And we'll just actually go ahead and review and create.

            05:25:12.880 --> 05:25:16.960
            And now we'll just hit Create so that it will go ahead and do that. It'll tell us that it's

            05:25:16.960 --> 05:25:21.840
            in progress. And we'll just wait a little bit here. I'll see you back in a moment.

            05:25:21.840 --> 05:25:27.200
            Alright, so our instances ready. So let's go ahead and go to this resource here.

            05:25:27.200 --> 05:25:31.840
            And then on the left hand side, you'll have connect. And so I'm going to show you and you

            05:25:31.840 --> 05:25:35.360
            don't it's not necessary for you to do this step because you're going to I'm gonna show you how to

            05:25:35.360 --> 05:25:40.480
            connect via the bastion. But I'm going to go ahead and download this file, the RDP file. And this

            05:25:40.480 --> 05:25:44.560
            will only work if you're on Windows, by the way. Well, I guess it'll work on Mac, but you'd have to

            05:25:44.560 --> 05:25:53.760
            install the the RDP service for that users with Windows there. And so here, this is Azure user,

            05:25:53.760 --> 05:25:57.920
            we're going to type in testing with a capital T, just double check that there. I'm going to log in

            05:25:57.920 --> 05:26:05.120
            make sure that this works. Do we'll do that one more time. Oh, you know, it's testing 123456.

            05:26:07.840 --> 05:26:10.320
            There we go. We'll say yes.

            05:26:10.320 --> 05:26:18.400
            And we'll just make sure that we can remote desktop into this just before anything else.

            05:26:18.400 --> 05:26:21.200
            And there we go. So that's all good to me, I don't need to see anymore.

            05:26:21.200 --> 05:26:26.320
            We'll go over to bastion, we'll say use bastion. And this is going to set up a bastion service.

            05:26:26.320 --> 05:26:33.200
            In order to use bastion, you need to have another address space defined for it. It makes it really

            05:26:33.200 --> 05:26:42.160
            easy to make it here. So I'm just going to go 10.0.1.0 forward slash 24. And we'll go ahead and

            05:26:42.160 --> 05:26:52.640
            hit OK. And so down below, it's going to choose an address space. We have a security group,

            05:26:52.640 --> 05:26:57.920
            I'm just going to put it for none. I don't think I want one on that.

            05:27:01.840 --> 05:27:05.840
            And if we scroll on down here, we have the resource group. So we're going to put in the

            05:27:05.840 --> 05:27:12.080
            same resource group. And we'll go ahead and create that. So now before this, they didn't

            05:27:12.080 --> 05:27:16.400
            have this really nice wizard used to have to go and in create all those things individually in

            05:27:16.400 --> 05:27:20.960
            your virtual network. But this is really nice. It does take a bit of time for this to provision.

            05:27:20.960 --> 05:27:25.520
            So I'll see you back here in a bit. That took a bit of time for that to create that bastion,

            05:27:25.520 --> 05:27:31.520
            but it is ready to go. And so now that we have it, we can go ahead and utilize this connection here.

            05:27:31.840 --> 05:27:38.000
            And so right away, I think it's setting up for RDP here. So what we'll do is type in Azure user,

            05:27:38.000 --> 05:27:42.720
            and then capital T testing 123456. We'll go ahead and hit connect.

            05:27:42.720 --> 05:27:49.600
            And so notice that I didn't have to use an external application, I could just

            05:27:49.600 --> 05:27:56.960
            run it in right here. It's all in the web browser. So that's pretty much how the bastion works.

            05:27:56.960 --> 05:28:00.320
            I can't remember the pricing on bastion, I think it's a little bit of money. So I don't want to

            05:28:00.320 --> 05:28:04.480
            keep this laying around here. But this is great. If you let's say you're on a Chromebook, which

            05:28:04.480 --> 05:28:09.280
            are becoming really popular, where you can't install native applications, or you're just

            05:28:09.280 --> 05:28:12.800
            having issues because you're on like Linux or something like that. So there you go, that's

            05:28:12.800 --> 05:28:17.440
            all there is to it, we'll go ahead and clean this up. And so I'm just going to go here,

            05:28:17.440 --> 05:28:22.480
            find the resource group. And we'll go ahead and delete, I'm just making sure that bastions within

            05:28:22.480 --> 05:28:39.920
            there. So it is good. And there we go. So we just launched a virtual machine for Linux. Now let's go

            05:28:39.920 --> 05:28:45.360
            ahead and launch one for Windows. So I'm going to go to the top here and type in virtual machines.

            05:28:45.360 --> 05:28:48.320
            We'll go to the first link, I'm going to hit add add virtual machine.

            05:28:50.160 --> 05:28:54.480
            And what we'll do is we'll create a new group. The last one I had was called the

            05:28:54.480 --> 05:28:58.720
            Bayes or I'm going to call this one Cardassia, Cardassia.

            05:28:58.720 --> 05:29:06.800
            And I'm going to name this machine also named Cardassia.

            05:29:06.800 --> 05:29:12.720
            And this time, what we want to do is, is we want to move over to a Windows server,

            05:29:12.720 --> 05:29:18.080
            I find the easiest one to learn with is the Windows 10 Pro server, just because I find

            05:29:18.080 --> 05:29:23.040
            these ones a little bit daunting. So I'm going to go Windows 10 Pro. And then what we're going to do

            05:29:23.040 --> 05:29:28.560
            is go choose a larger size, this is not going to work, we cannot run a Windows server on a B one

            05:29:28.560 --> 05:29:34.000
            LS. So we're going to have to go a little bit larger. And we don't have to go too much larger

            05:29:34.000 --> 05:29:38.720
            here. But the idea here is that there's going to be a more expensive spend here. So we're not going

            05:29:38.720 --> 05:29:43.360
            to be running to keep this running for long. But here we have the B two s that is the appropriate

            05:29:43.360 --> 05:29:48.720
            size to run this anything smaller, I don't think is going to work. And we are going to

            05:29:48.720 --> 05:29:51.920
            put in a password here. So I'm just going to put in Cardassia.

            05:29:51.920 --> 05:29:58.720
            And we'll do Cardassia 123.

            05:29:58.720 --> 05:30:03.680
            Put a capital on it, I guess we'll just do this here.

            05:30:03.680 --> 05:30:09.520
            And I'm just going to go back and lowercase this one.

            05:30:12.640 --> 05:30:18.160
            And we're going to allow the inbound port of 3389. Because that is what RDP needs,

            05:30:18.160 --> 05:30:21.520
            I'm going to confirm that I have a Windows license, I actually don't. But the thing is,

            05:30:21.520 --> 05:30:27.440
            you can still launch one for your test purposes, it'll just complain saying you're not activated.

            05:30:27.440 --> 05:30:32.640
            So there are some limitations, but it's good enough for us to learn. Okay. And so now that

            05:30:32.640 --> 05:30:38.320
            that is all great, we'll go next to disks, we're going to go with premium or standard SSD this time,

            05:30:39.360 --> 05:30:43.200
            we are going to go ahead and hit next and go to networking, it's going to create us a new V net,

            05:30:43.200 --> 05:30:47.600
            which is a great idea. We're going to let it create a network security group on the neck,

            05:30:47.600 --> 05:30:53.280
            just like before, we'll go ahead and hit next. We'll leave all these options alone,

            05:30:53.280 --> 05:30:58.320
            this all seems fine to me. And we'll hit next review and create.

            05:30:58.320 --> 05:31:03.680
            And we'll go ahead and create this server.

            05:31:03.840 --> 05:31:09.120
            All right, and so that's going to go ahead and create it. So I'll just see you back here in a

            05:31:09.120 --> 05:31:13.280
            moment when that's done deploying. Alright, and so after a short little while here, it looks like

            05:31:13.280 --> 05:31:18.320
            our Windows server is now deployed. So what we can do is go to that resource. If you want to just see

            05:31:18.320 --> 05:31:22.480
            what it's deployed, it's the same stuff. As always, you have your network interface card,

            05:31:22.480 --> 05:31:27.680
            your virtual networks, NSG, the IP address, but let's actually go to that resource now.

            05:31:27.680 --> 05:31:31.680
            And we'll go ahead and create that resource. And we'll go ahead and create that resource.

            05:31:31.680 --> 05:31:36.960
            Let's actually go to that resource now. And so let's see how we can gain access to this virtual

            05:31:36.960 --> 05:31:42.240
            machine. And so what we can do is use RDP. Luckily, I am on a Windows machine. And so

            05:31:42.240 --> 05:31:48.160
            I already have the RDB client that I can use. So all you got to do is download the RDB file.

            05:31:48.160 --> 05:31:53.840
            And then once we have that file, I can just double click it. And I can open this up. If you're on a

            05:31:53.840 --> 05:31:59.120
            Mac, you can download the app in the App Store. And so I'll go ahead and type in my password.

            05:31:59.120 --> 05:32:09.680
            So my username is Cardassia. And then my password was capital C, a RDA ssia 123. We'll hit OK. And

            05:32:09.680 --> 05:32:15.440
            then it'll give us another one, we'll say yes. And now we are in our virtual machine. So there you go.

            05:32:15.440 --> 05:32:21.120
            How cool is that? Let's give it a moment to load up. But this is a full Windows 10 Pro.

            05:32:21.120 --> 05:32:26.560
            And as I said before, you know, we don't actually have a license. So if you're afraid of spinning

            05:32:26.560 --> 05:32:31.120
            up, because you're gonna get charged a license fee for Windows, you do not have to worry,

            05:32:31.120 --> 05:32:36.320
            that's not going to happen, you have to do some manual intervention for that to happen. So we'll

            05:32:36.320 --> 05:32:40.800
            just wait a little while here for this to load. It is not we're not using the most powerful machine.

            05:32:40.800 --> 05:32:47.520
            So it does take a little bit of time. And so we just hit accept here. And here we are. So we are

            05:32:47.520 --> 05:32:54.080
            on we have our nice Windows machine here. Whoops. I don't know if it has any games. Let's go take a

            05:32:54.080 --> 05:33:07.200
            look. Maybe play minesweeper. No, maybe maybe you have to download in the store. I'm not that familiar

            05:33:07.200 --> 05:33:11.520
            with Windows machines. But so there you go. So we'll go ahead and close that. And you know,

            05:33:11.520 --> 05:33:15.600
            if we were using the bastion, it's the same process, you saw how we used it with SSH.

            05:33:15.600 --> 05:33:19.440
            But if we had the bastion, and it's so much work to set one up, we already did that before.

            05:33:19.440 --> 05:33:24.240
            But all you do is enter your credentials in on the page, just as we did. And it and it's just a lot

            05:33:24.240 --> 05:33:28.480
            easier that way. So let's go ahead and just tear down this machine, we're all done with it. So I'm

            05:33:28.480 --> 05:33:35.920
            just going to hit delete. And if we find that resource group, we should be able to easily

            05:33:35.920 --> 05:33:40.960
            delete them all, I find the easiest ways to go up here, go to all resources. And then there's

            05:33:40.960 --> 05:33:45.600
            the resource group there, and then hit Delete resource group. And then I'll type in the name

            05:33:45.600 --> 05:33:49.760
            of it, which is Cardassia. And I'll delete all those resources. But after that's done,

            05:33:49.760 --> 05:33:55.120
            always just take a double check on your all resources tab. And just make sure that those

            05:33:55.120 --> 05:33:59.520
            resources are gone. Because sometimes they stick around. But there you go. That's as simple as it

            05:33:59.520 --> 05:34:10.640
            was to launch a Windows machine. Hey, this is Andrew Brown from exam Pro. And let's take a look

            05:34:10.640 --> 05:34:15.040
            here at virtual machines, which I consider the backbone of most cloud service providers.

            05:34:15.040 --> 05:34:20.240
            And Azure keeps it really simple by calling it virtual machines. So we can go up here and type

            05:34:20.240 --> 05:34:24.640
            in virtual machine and make our way over here. But right now I don't have any options because

            05:34:24.640 --> 05:34:28.880
            I'm using a tenant that doesn't have a subscription applied to it. So what I'm going to do is go

            05:34:28.880 --> 05:34:35.680
            switch back to my original tenant. And this one has a subscription applied to it. And so what I'll

            05:34:35.680 --> 05:34:41.200
            do is just click back up here. And now we'll just type in virtual machines. And I can now see,

            05:34:41.760 --> 05:34:46.320
            I have options of creating virtual machines. Let's go ahead and go create a Linux one first.

            05:34:46.320 --> 05:34:49.760
            And then we'll go ahead and create a Windows one. And then we'll see how we can connect to it. All

            05:34:49.760 --> 05:34:54.080
            right. So first, we'll go to the top here and hit add, we'll click on virtual machine.

            05:34:54.080 --> 05:34:59.200
            And we're gonna be presented with a lot of options. So we'll have to choose a subscription.

            05:34:59.200 --> 05:35:04.320
            And so there is mine, I want to probably create a new resource group here, I'm going to call this

            05:35:04.320 --> 05:35:14.640
            one Bayshore. And we'll name this Bayshore again, I'm going to launch this in us east, I'll just set

            05:35:14.640 --> 05:35:19.920
            it to one availability zone for the time being. Then here we have what we can choose as an image,

            05:35:19.920 --> 05:35:25.440
            I can click on see all images and choose from a variety of them. So if I didn't want to use

            05:35:25.440 --> 05:35:30.480
            Ubuntu, I could launch something else like Debian or something like that. But really, I just want to

            05:35:30.480 --> 05:35:36.800
            stick with Ubuntu because I'm fine with that version with 18. Then here's what really matters

            05:35:36.800 --> 05:35:40.720
            is the size because that's going to affect our costs. So if we click on see all sizes,

            05:35:40.720 --> 05:35:45.440
            we have this nifty table where we can sort the cost, it's just loading in the cost here,

            05:35:45.440 --> 05:35:50.000
            it's dynamic, this is going to be based on what your base subscription is. So if you're

            05:35:50.000 --> 05:35:54.400
            in Canada, you're gonna see Canadian prices, even the US, you can see us prices,

            05:35:54.400 --> 05:36:01.600
            etc, etc. And I care a lot about cost here. So I'm just going to sort this by cost. And here we have

            05:36:01.600 --> 05:36:08.880
            the B one LS, which is very cost effective. We have a RAM of point five gigabytes, and some other

            05:36:08.880 --> 05:36:14.640
            options there. So we'll go ahead and select that there. And we have a couple options, we can use

            05:36:14.640 --> 05:36:21.440
            SSH public key, or we can utilize a password. And so I think what we'll do is use an SSH public key,

            05:36:21.440 --> 05:36:25.840
            because that's pretty much the standard there. We're going to name the username beige or if it

            05:36:25.840 --> 05:36:31.520
            lets us probably won't probably want some additional options there. No, it's okay. Oh,

            05:36:31.520 --> 05:36:37.040
            great. And we'll go ahead and generate a new key pair. And I'm just going to name that one beige

            05:36:37.040 --> 05:36:44.960
            or and we have some options here for inbound rules. So you could set to none. This is just

            05:36:44.960 --> 05:36:51.120
            setting up the NSG for you. But we're probably going to want to have that port open for SSH

            05:36:51.120 --> 05:36:56.400
            because that's how we're going to make our way back in here. If we're running a like an Apache

            05:36:56.400 --> 05:37:01.600
            server, we'd want to have port 80 open. So we can go ahead and do that. We'll take a look at now

            05:37:01.600 --> 05:37:09.680
            disks. So here we have options between premium, standard and standard HHD. I just want this to be

            05:37:09.680 --> 05:37:14.720
            cost effective. So I'm just going to go with standard HDD. But generally, you want to have

            05:37:14.720 --> 05:37:20.160
            at least standard or premium SSD when you're running real web development workloads.

            05:37:20.960 --> 05:37:24.720
            Then there's encryption here. And so it's always turned on by default, which is great.

            05:37:24.720 --> 05:37:29.040
            They also have this option of double encryption with the platform managing customer managed key,

            05:37:29.040 --> 05:37:32.880
            we're just gonna leave that as default, enable Ultra Disk compatibility, that's not something we

            05:37:32.880 --> 05:37:37.360
            need to do here because we are not using Ultra Disk. And here you can see that you can attach

            05:37:37.360 --> 05:37:42.240
            multiple disks here. So I can go and do that. But that's not something I need to do today.

            05:37:42.240 --> 05:37:47.440
            And some other advanced options, which we do not care about, we'll go over to networking. And so

            05:37:47.440 --> 05:37:52.720
            it's going to end up creating us a new v net for us. And we'll create a new subnet for us and assign

            05:37:52.720 --> 05:38:00.560
            it a IP address. It will also set up a NICs network security group. So the network security group is

            05:38:00.560 --> 05:38:05.360
            not going to be applied at the subnet level, it's gonna be applied at the NIC, which is attached to

            05:38:05.360 --> 05:38:11.600
            the DC to there. And so we'll just leave it to basic, we're gonna allow inbound inbound ports

            05:38:11.600 --> 05:38:18.320
            for port 80. And 22 that was carried over from earlier, we can put this behind a load balancer,

            05:38:18.320 --> 05:38:22.720
            but I don't think we're going to do that right now. We'll go over to management, we have some

            05:38:22.720 --> 05:38:28.720
            additional options here for monitoring. This is all okay, here, we can set it to auto shutdown,

            05:38:28.720 --> 05:38:35.840
            actually, I'll leave that alone. You can also enable backups here. We'll go advanced. And now

            05:38:35.840 --> 05:38:42.640
            we have this option here for custom data. I covered a section on cloud and it and they don't

            05:38:42.640 --> 05:38:46.960
            call this user data, but most other providers will call this user data. So we could provide

            05:38:46.960 --> 05:38:53.360
            a bash script or additional information here if we wanted to. Then down below, there's some host

            05:38:53.360 --> 05:38:56.720
            group options, we're not gonna worry about that in proximity placement group, this is really

            05:38:56.720 --> 05:39:04.720
            important if you need to have instances nearby. I think this is pretty common with what's it called

            05:39:04.720 --> 05:39:10.240
            high capacity workloads, h h FC, I can't remember the initialism right now, but we covered in the

            05:39:10.240 --> 05:39:15.040
            core content, then we can tag our resource here. We'll just leave that alone. I don't care about

            05:39:15.040 --> 05:39:20.800
            tagging too much. But generally, it's good to tag in practice. And then we will get to review and

            05:39:20.800 --> 05:39:26.160
            create our server here, we'll go ahead and hit Create. And then we'll have to download our

            05:39:26.160 --> 05:39:32.960
            private key so we can utilize it later. And so that's downloaded there. And now we're just waiting

            05:39:32.960 --> 05:39:38.080
            for it to deploy this. And I'll see you back here in a moment. So we had to wait a little bit there.

            05:39:38.080 --> 05:39:43.600
            And finally, our deployment is complete. And we can go ahead and just review all the things that

            05:39:43.600 --> 05:39:49.040
            it created. So notice that it created the virtual machine, it created a network interface, a NIC for

            05:39:49.040 --> 05:39:56.160
            us, the NSG, the network security group, the virtual network, and also a public IP address.

            05:39:56.160 --> 05:40:01.360
            When I do clean up a lot of things I always miss are these IP addresses. And I know that

            05:40:01.360 --> 05:40:07.520
            Azure gave me a warning that said, Hey, you're about to spend $700 yearly on IP addresses,

            05:40:07.520 --> 05:40:12.160
            because you're releasing them. So when we do the cleanup step, I'll definitely emphasize about

            05:40:12.160 --> 05:40:16.560
            deleting those IP addresses and how to go about that. Let's go take a look at the actual resource

            05:40:16.560 --> 05:40:23.120
            now. So here we are. And you can see we have a lot of options, the left hand side, such as the disk.

            05:40:23.120 --> 05:40:30.000
            So we can see the disk options there. And there's additional security options. Let's go take a look

            05:40:30.000 --> 05:40:36.080
            at how we can go ahead and connect to the server. And so there's different options here. So we have

            05:40:36.080 --> 05:40:41.520
            RDP SSH and bastion. Since we are using a Linux machine, we're not going to be using RDP that's

            05:40:41.520 --> 05:40:49.040
            really for Windows. But the trick here is that I would need to have a client on my computer to

            05:40:49.040 --> 05:40:54.080
            connect like I think it's called putty. If you're on a Linux based machine, it's a lot easier.

            05:40:54.880 --> 05:41:00.160
            And certainly I have the Linux subsystem installed. So I could probably connect that way.

            05:41:00.160 --> 05:41:05.120
            But I figured let's just go ahead and connect via bastion because I think this is a pretty

            05:41:05.120 --> 05:41:11.600
            darn cool feature. So let's go ahead and create ourselves a bastion. And this will take a little

            05:41:11.600 --> 05:41:16.480
            bit of time here. But we'll go ahead here and just set up a subnet. So to associate a virtual

            05:41:16.480 --> 05:41:21.040
            network to bastion, it must contain a subnet with the Azure bastion subnet. So they actually have a

            05:41:21.040 --> 05:41:27.120
            special subnet for it. So what we'll do is we'll just go back to our, our server here,

            05:41:27.120 --> 05:41:33.680
            which we call Bayshore. And I think we can find a subnet through here. So on the left hand side,

            05:41:33.680 --> 05:41:39.680
            if we go to networking, we probably could find it that way. So I'm just looking for that security

            05:41:39.680 --> 05:41:50.160
            group. In there. It should be maybe it's not there. If it's not there. Well, you know, we

            05:41:50.160 --> 05:41:55.760
            could just go over make our way over to subnets. It's not a big deal. Because it's called Bayshore,

            05:41:55.760 --> 05:42:01.920
            it's pretty darn easy to find to begin with. And so under subnets here, what we need to do is add a

            05:42:01.920 --> 05:42:09.040
            special one here. And I just got to remember how this works. So you need to create a subnet called

            05:42:09.040 --> 05:42:14.560
            Azure bastion subnet with a prefix of at least 27. So we'll go ahead and add a new subnet.

            05:42:15.360 --> 05:42:24.000
            And we'll call it that. We'll take out the space there. And the range is 10 010, etc. So we'll just

            05:42:24.000 --> 05:42:40.800
            do it on to 0.2.0 forward slash 27. 10 002 is not contained. Yeah, it overlaps. So we'll do two

            05:42:42.000 --> 05:42:45.680
            not contain the virtual network address space. Oh, right. So we have to add the address space first.

            05:42:45.680 --> 05:42:52.560
            Oops, we'll just hit cancel here. That's okay, we'll discard that we'll make our way over to

            05:42:52.560 --> 05:42:59.840
            address space. And we'll go ahead and add 10.0.2.0 forward slash 24. They'll give us a pretty darn

            05:42:59.840 --> 05:43:06.080
            large range there. And so now what we'll do is go back to our subnet.

            05:43:08.080 --> 05:43:15.280
            And we'll go ahead and create that there. And it said only needed 27. So we'll just give it only 27.

            05:43:15.280 --> 05:43:20.640
            We don't need to go bigger than we need. And that should be okay, we'll go ahead and hit Save.

            05:43:20.640 --> 05:43:26.720
            And it shouldn't take too long. So now that we have that we can go back here.

            05:43:26.720 --> 05:43:29.280
            And we'll give give us another go here.

            05:43:36.400 --> 05:43:42.080
            It's there. So it shouldn't be complaining. Maybe what we'll do is just start from the start here

            05:43:42.080 --> 05:43:52.160
            again. Yeah, there you go. The Azure portal is like that a lot where you will have something set

            05:43:52.160 --> 05:43:57.280
            up and it has the old state of it. And so you just have to trust yourself that you know what you're

            05:43:57.280 --> 05:44:00.800
            doing. And you have to go back. But if you don't have a lot of confidence, a lot of times you'll

            05:44:00.800 --> 05:44:04.320
            get stuck and you'll think, Okay, I don't have it right. But I always just try again and hit refresh.

            05:44:05.360 --> 05:44:09.680
            Because the Azure portal is very inconsistent. So we're just going to wait for this to create

            05:44:09.680 --> 05:44:15.040
            this does take a little while to create. So I'll see you back in a moment. So after waiting five

            05:44:15.040 --> 05:44:20.240
            minutes, our bastion is now created. And so what we can do is without even using a putty client or

            05:44:20.240 --> 05:44:27.600
            having to use Linux directly, we can just connect via the bastion. So here, we'll see we have some

            05:44:27.600 --> 05:44:34.880
            options here. So we want to do SSH, private key from local file. Okay. And what we can do is go

            05:44:34.880 --> 05:44:41.680
            ahead and select our base or key. And then I'll just scroll down here and hit connect. Oh, and I

            05:44:41.680 --> 05:44:49.040
            think we made the username Bayshore. And we'll go ahead and connect now. And it's complaining about

            05:44:49.040 --> 05:45:00.160
            a pop up here. So we'll go up here and say, always allow. And we'll try that again. And then we'll

            05:45:00.160 --> 05:45:06.960
            say allow again. And so now that we're into our server here, let's go ahead and try to install

            05:45:06.960 --> 05:45:12.240
            Apache and see if we can get the least the default page running. So this is using Ubuntu, if my memory

            05:45:12.240 --> 05:45:18.960
            serves me correctly, it should be app get install Apache two. And we'll just hit y for continue.

            05:45:18.960 --> 05:45:24.960
            And we'll just wait for this install doesn't take too darn long.

            05:45:29.840 --> 05:45:34.320
            And after a short little wait there, it finally did install. Also, if you notice this little icon

            05:45:34.320 --> 05:45:39.200
            here, we have a little clipboard here. I don't seem to ever use that there. So that's fine.

            05:45:39.200 --> 05:45:46.480
            Now when you install Apache, we might have to go ahead and start it up. So let's just take a look

            05:45:46.480 --> 05:45:52.560
            to see if it actually is in the running directory here. So we'll go to CD var www. And so that's

            05:45:52.560 --> 05:45:59.120
            where the default directory is. Right. But we can just check to see if it's running by doing a PS

            05:45:59.120 --> 05:46:07.280
            ox. I think it's HTTP D, or we can say Apache here. And so it looks like it's already running.

            05:46:07.280 --> 05:46:13.040
            So that's pretty great for us. And since it's running on port 80, and we've opened up port 80,

            05:46:13.040 --> 05:46:18.880
            we should probably be able to access that here. So let's go back to our actual virtual machine.

            05:46:18.880 --> 05:46:27.280
            So we'll go to virtual machines. And we have that virtual machine running, I'm just going to click

            05:46:27.280 --> 05:46:34.400
            into it because I just want to find out its public IP address. So here it is there. And for lucky,

            05:46:34.400 --> 05:46:39.680
            this will just work just a copy to clipboard button right there. And look at that we have

            05:46:39.680 --> 05:46:44.560
            the default page. Isn't that cool? So that's all there really is to it. And I could even update

            05:46:44.560 --> 05:46:48.240
            this page, you don't have to do it, but I'm just gonna update it for fun. Actually, I probably

            05:46:48.240 --> 05:46:52.960
            have to restart the server. So maybe I won't do that. But yeah, so we connected through the bastion.

            05:46:52.960 --> 05:46:58.240
            So that was pretty darn easy. We probably could have also used the cloud shell to connect.

            05:46:58.240 --> 05:47:02.480
            But maybe we should we could give that a go as well.

            05:47:02.480 --> 05:47:09.200
            Since we're all done here, let's go ahead and do some cleanup. The first thing I want to do

            05:47:09.200 --> 05:47:12.800
            is the easiest way is actually to go to all resources here, the left hand side.

            05:47:12.800 --> 05:47:16.560
            And this really gives you an idea of everything that's running your account. So actually have

            05:47:16.560 --> 05:47:21.840
            other stuff in here that's not relevant. But the idea is that all of our stuff is running within a

            05:47:21.840 --> 05:47:27.440
            resource group. And so I'm just taking a look there. I'm not seeing this is all resources here.

            05:47:27.440 --> 05:47:33.440
            See if you see resource group here. Yeah, they're all there right there. So I can go ahead and click

            05:47:33.440 --> 05:47:38.160
            that. And so everything more or less should be self contained within here. See all that stuff.

            05:47:38.160 --> 05:47:44.000
            You can even see the V net is part of it as well. And so if I go ahead and delete this resource

            05:47:44.000 --> 05:47:48.880
            group, it should delete all this stuff. So I'm just going to type Bayshore to confirm.

            05:47:50.240 --> 05:47:55.600
            And we'll go ahead and delete. And that should do a good job of cleaning up all those files.

            05:47:55.600 --> 05:48:00.960
            I'm not sure if it will delete the IP, it should right there. But if it doesn't,

            05:48:00.960 --> 05:48:07.040
            what I recommend is after everything is deleted, just go back here to all resources. And just

            05:48:07.040 --> 05:48:11.840
            double check to make sure they all vanish. Because when this is done, they're all going to start to

            05:48:11.840 --> 05:48:15.280
            vanish from this list. And if there's anything remaining, you'll know because it's still here,

            05:48:15.280 --> 05:48:21.040
            right? So just be careful about that. That's all I want you to know. And so that's the Linux part.

            05:48:21.040 --> 05:48:24.080
            And so let's go ahead and actually now set up a Windows Server.

            05:48:24.080 --> 05:48:33.200
            Hey, this is Andrew Brown from exam Pro. And in this section, we'll be covering Azure App Service.

            05:48:33.200 --> 05:48:39.360
            Azure App Service is an HTTP based platform for web apps, or est fall API's and mobile

            05:48:39.360 --> 05:48:44.560
            back end services, you can choose your programming language in Python, Java or any other language and

            05:48:44.560 --> 05:48:49.920
            run it in either a Windows or Linux environment. It is a platform as service. So it's the Heroku

            05:48:49.920 --> 05:48:54.960
            equivalent for Azure. Azure App Service takes care of the following underlying infrastructure

            05:48:54.960 --> 05:48:59.920
            OS and language security patches, load balancing, auto scaling and infrastructure management.

            05:48:59.920 --> 05:49:05.280
            Azure App Service makes it easy to implement common integrations and features such as Azure

            05:49:05.280 --> 05:49:10.480
            DevOps for deployments, GitHub and Docker Hub package management systems easy to set up staging

            05:49:10.480 --> 05:49:16.720
            environments, custom domains and attaching TLS or SSL certificates. You pay based on an Azure App

            05:49:16.720 --> 05:49:22.240
            Service plan. Shared tier includes free and shared options. Linux isn't supported here.

            05:49:22.240 --> 05:49:28.560
            Dedicated tier includes basic standard premium premium to premium three. And there's isolated

            05:49:28.560 --> 05:49:34.240
            tier. Azure App Service is versatile, you can deploy single or multi container Docker applications.

            05:49:34.240 --> 05:49:38.960
            When you create your app, you have to choose a unique name since it becomes a fully qualified

            05:49:38.960 --> 05:49:43.280
            domain. Overall, Azure App Service simplifies your web hosting needs,

            05:49:43.280 --> 05:49:46.400
            ensuring you can focus on coding and let Azure do the heavy lifting.

            05:49:46.400 --> 05:49:56.560
            Let's delve into runtimes in Azure App Service. So what is a runtime environment,

            05:49:56.560 --> 05:50:01.120
            a runtime environment refers to the software and settings needed for a program to run in a defined

            05:50:01.120 --> 05:50:06.080
            way at runtime. A runtime generally means what programming language and libraries and framework

            05:50:06.080 --> 05:50:10.960
            you are using. A runtime for Azure App Services will be a predefined container that has your

            05:50:10.960 --> 05:50:16.480
            programming language and commonly used library for that language installed. With Azure App Services,

            05:50:16.480 --> 05:50:21.440
            you're presented with a range of runtimes to choose from including dotnet dotnet core Java,

            05:50:21.440 --> 05:50:28.080
            Ruby, node.js, PHP and Python. Moreover, Azure App Services generally supports multiple versions of

            05:50:28.080 --> 05:50:33.680
            each programming language. For example, for Ruby, you might find versions 2.6 and 2.7.

            05:50:34.320 --> 05:50:39.040
            It's worth noting that cloud providers, including Azure may phase out support for older versions

            05:50:39.040 --> 05:50:43.120
            over time. This not only ensures that they're offering the latest and most efficient tools,

            05:50:43.120 --> 05:50:47.360
            but also promotes better security practices among users pushing them to keep up with the

            05:50:47.360 --> 05:50:51.680
            latest patches. So that's an overview of runtimes in Azure App Service.

            05:50:51.680 --> 05:51:00.480
            The next thing we'll be covering are custom containers in Azure App Service.

            05:51:00.480 --> 05:51:05.760
            Azure App Service gives you the flexibility to use custom containers for both Windows and Linux.

            05:51:05.760 --> 05:51:09.760
            The primary reason you might opt for a custom container is to use a distinct runtime that

            05:51:09.760 --> 05:51:14.480
            isn't natively supported or to incorporate specific packages and software. Here's a

            05:51:14.480 --> 05:51:18.880
            straightforward process to get started with custom containers in Azure App Service.

            05:51:18.880 --> 05:51:23.360
            Design your container begin by creating a Docker container tailored to your needs on your local

            05:51:23.360 --> 05:51:28.480
            machine. Push to Azure once your container is ready, push it to the Azure Container Registry.

            05:51:28.480 --> 05:51:33.040
            This centralized repository ensures that your container is easily accessible within Azure.

            05:51:33.040 --> 05:51:38.400
            Deploy and go live. Finally, deploy your container image directly to the Azure App Service.

            05:51:38.400 --> 05:51:42.000
            Once deployed, Azure takes care of scaling, maintenance, and updates.

            05:51:42.000 --> 05:51:46.880
            Another advantage of custom containers in Azure App Service is that they offer more granular

            05:51:46.880 --> 05:51:51.680
            control over your environment. You can fine tune performance, security, and other aspects of your

            05:51:51.680 --> 05:52:00.880
            application environment to suit your needs. The next topic we'll be covering are deployment slots

            05:52:00.880 --> 05:52:05.600
            in Azure App Service. Deployment slots allow you to create different environments of your

            05:52:05.600 --> 05:52:10.480
            web application associated to a different host name. This is useful when you require a testing,

            05:52:10.480 --> 05:52:15.360
            staging, or QA environment alongside your production setup. Deployment slots let you

            05:52:15.360 --> 05:52:19.920
            swiftly replicate your production setting for various purposes, ensuring consistent testing

            05:52:19.920 --> 05:52:25.760
            environments. You can also swap environments. This is useful for executing blue/green deployments.

            05:52:25.760 --> 05:52:30.080
            By using swap, you can promote your staging environment to production with ease.

            05:52:30.080 --> 05:52:34.000
            You can promote our staging to production by swapping. If something goes wrong,

            05:52:34.000 --> 05:52:38.080
            you could swap them back. This capability ensures minimal downtime and enhances the

            05:52:38.080 --> 05:52:42.240
            user experience since you can introduce changes in a controlled manner, rolling them back if

            05:52:42.240 --> 05:52:47.520
            necessary. In addition, Azure ensures that when swapping, the instances are warmed up before

            05:52:47.520 --> 05:52:53.200
            traffic is rerouted, resulting in zero downtime. So that's a quick overview of deployment slots.

            05:52:53.200 --> 05:53:02.000
            The next topic we'll be covering is the App Service environment in Azure App Service.

            05:53:02.000 --> 05:53:07.040
            App Service environment is an Azure App Service feature that provides a fully isolated and

            05:53:07.040 --> 05:53:12.080
            dedicated environment for securely running App Service apps at high scale. This allow you to

            05:53:12.080 --> 05:53:18.320
            host Windows and Linux web apps, Docker containers, mobile apps and functions. App Service environments

            05:53:18.320 --> 05:53:22.960
            are appropriate for application workloads that require very high scale isolation and secure

            05:53:22.960 --> 05:53:28.320
            network access and high memory utilization. Customers can create multiple ASCs within a

            05:53:28.320 --> 05:53:33.040
            single Azure region or across multiple Azure regions making ASCs ideal for horizontally

            05:53:33.040 --> 05:53:38.640
            scaling stateless application tiers in support of high requests per second workloads. ASCs comes

            05:53:38.640 --> 05:53:43.520
            with its own pricing tier called the isolated tier. ASCs can be used to configure security

            05:53:43.520 --> 05:53:48.960
            architecture. Apps running on ASCs can have their access gated by upstream devices such as web

            05:53:48.960 --> 05:53:54.160
            application firewalls. App Service environments can be deployed into availability zones using

            05:53:54.160 --> 05:54:00.160
            zone pinning. There are two deployment types for an App Service environment external ASC and ILBS.

            05:54:00.160 --> 05:54:05.360
            External ASC exposes the ASC hosted apps on an internet accessible IP address.

            05:54:06.000 --> 05:54:10.560
            If the VNet is connected to your on-premises network, apps in your ASC also have access to

            05:54:10.560 --> 05:54:15.840
            resources there without additional configuration. Because the ASC is within the VNet, it can also

            05:54:15.840 --> 05:54:21.760
            access resources within the VNet without any additional configuration. ILBS exposes the ASC

            05:54:21.760 --> 05:54:27.680
            hosted apps on an IP address inside your VNet. The internal endpoint is an internal load balancer.

            05:54:27.680 --> 05:54:31.120
            So that's an overview of App Service environment in Azure App Service.

            05:54:31.520 --> 05:54:37.360
            The next thing we'll be going over is deployment in Azure App Service. So what is deployment? Well,

            05:54:37.360 --> 05:54:41.520
            it's the action of pushing changes or updates from a local environment or repository into a

            05:54:41.520 --> 05:54:47.440
            remote environment. Azure App Services provides many ways to deploy your applications, including

            05:54:47.440 --> 05:54:52.960
            run from package, deploy zip or war, deploy via FTP, deploy via cloud sync such as Dropbox or

            05:54:52.960 --> 05:54:57.120
            OneDrive, deploy continuously with GitHub, Bitbucket, and now you can deploy from any

            05:54:57.120 --> 05:55:17.280
            location in Azure. So run from a package is when the files in the package are not copied to the

            05:55:17.280 --> 05:55:23.040
            ww root directory. Instead, the zip package itself gets mounted directly as the read only ww root

            05:55:23.040 --> 05:55:28.000
            directory. All other deployment methods in App Service have deployed to the following directory

            05:55:28.000 --> 05:55:35.600
            for Windows D colon we use backslashes home site ww root for Linux we use forward slashes home site

            05:55:35.600 --> 05:55:41.440
            ww root. Since the same directory is used by your app at runtime, it's possible for deployment to

            05:55:41.440 --> 05:55:45.600
            fail because of file lock conflicts and for the app to behave unpredictably because some of the

            05:55:45.600 --> 05:55:51.280
            files are not yet updated. zip and war file deployment uses the same kudu service that

            05:55:51.280 --> 05:55:56.400
            powers continuous integration based deployments. kudu is the engine behind get deployments in

            05:55:56.400 --> 05:56:01.920
            Azure App Service. It's an open source project that can also run outside of Azure. kudu supports

            05:56:01.920 --> 05:56:07.200
            the following functionality for zip file deployment, deletion of files leftover from a previous

            05:56:07.200 --> 05:56:12.320
            deployment option to turn on the default build process, which includes package restore deployment

            05:56:12.320 --> 05:56:17.520
            customization, including running deployment scripts, deployment logs, and a file size limit

            05:56:17.520 --> 05:56:25.920
            of 2048 megabytes. You can deploy using Azure CLI Azure API via rest and Azure portal. You can use

            05:56:25.920 --> 05:56:31.360
            file transfer protocol to upload files, you will need your own FTP client, you just drag and upload

            05:56:31.360 --> 05:56:38.560
            your files, go to the deployment center, get the FTP credentials for your FTP client. You can use

            05:56:38.560 --> 05:56:44.560
            Dropbox or OneDrive to deploy using a cloud sync. Dropbox is a third party cloud storage service.

            05:56:44.560 --> 05:56:50.080
            OneDrive is Microsoft's cloud storage service. You go to deployment center configure for Dropbox

            05:56:50.080 --> 05:56:54.720
            or OneDrive. When you turn on sync, it will create a folder in your Dropbox Cloud Drive,

            05:56:54.720 --> 05:57:02.720
            OneDrive apps, Azure Web Apps, Dropbox apps, Azure. This will sync with your home site wwroot. So you

            05:57:02.720 --> 05:57:08.240
            just update files in that folder. In summary, Azure App Service offers a range of deployment methods,

            05:57:08.240 --> 05:57:17.680
            ensuring flexibility and ease for developers. The next topic we'll be covering is auto scale

            05:57:17.680 --> 05:57:23.120
            in Azure App Service. Auto scaling is the process of adjusting a server infrastructure capability

            05:57:23.120 --> 05:57:27.520
            to fulfill incoming requests from your web application. It usually takes seconds for the

            05:57:27.520 --> 05:57:31.760
            changes to take effect and can be done automatically according to pre configured metrics.

            05:57:31.760 --> 05:57:36.880
            It does not need any new deployment or coding changes. Scaling options in Azure App Service,

            05:57:37.440 --> 05:57:41.680
            horizontal scaling, this involves adding or removing servers from your infrastructure.

            05:57:41.680 --> 05:57:46.640
            For example, during high traffic periods, you might scale up from one to three virtual machines.

            05:57:46.640 --> 05:57:51.440
            When demand decreases, you can reduce the count to minimize costs. Vertical scaling,

            05:57:51.440 --> 05:57:57.040
            this is just the resources of an existing server such as CPU memory or storage. For example, if

            05:57:57.040 --> 05:58:01.280
            you find that your application is processing a large amount of data and needs more storage for

            05:58:01.280 --> 05:58:06.160
            logs, you might opt to increase the storage capacity of your existing server. Overall,

            05:58:06.160 --> 05:58:11.120
            Azure App Service auto scaling dynamically adjusts resources to meet real time application demands.

            05:58:11.120 --> 05:58:19.360
            The next thing we'll be covering is the Azure App Service plan.

            05:58:19.360 --> 05:58:23.520
            Azure App Service plan determines the region of the physical server where your web application

            05:58:23.520 --> 05:58:28.960
            will be hosted and defines the amount of storage RAM and CPU your application will use. It offers

            05:58:28.960 --> 05:58:35.440
            several pricing tiers, share tiers, there are two share tiers free and shared. Free tier provides

            05:58:35.440 --> 05:58:40.320
            this tier offers one gigabyte of disk space supports up to 10 apps on a single shared instance

            05:58:40.320 --> 05:58:45.040
            provides no availability SLA and allows each app a compute quota of 60 minutes per day.

            05:58:45.040 --> 05:58:50.720
            Shared tier provides hosting multiple apps up to 100 on a single shared instance,

            05:58:50.720 --> 05:58:55.920
            no availability SLA is offered and each app gets a compute quota of 240 minutes per day.

            05:58:55.920 --> 05:58:59.440
            It's worth noting that Linux based instances aren't supported in this tier.

            05:59:00.560 --> 05:59:07.760
            Dedicated tiers basic standard premium premium to premium three basic offers more disk space

            05:59:07.760 --> 05:59:12.560
            unlimited apps three levels in this tier that offer varying amounts of compute power memory

            05:59:12.560 --> 05:59:19.920
            and disk storage. Standard allows scaling out to three dedicated instances guarantees 99.95%

            05:59:19.920 --> 05:59:25.760
            availability and also has three levels with varying resources. Premium provides the ability

            05:59:25.760 --> 05:59:32.160
            to scale up to 10 dedicated instances and ensures 99.95% availability and it includes multiple

            05:59:32.160 --> 05:59:38.880
            hardware level options. isolated tier dedicated Azure Virtual Network full network and compute

            05:59:38.880 --> 05:59:46.720
            isolation scale out to 100 instances and availability SLA of 99.95%. So the Azure

            05:59:46.720 --> 05:59:50.880
            App Service plan lets you tailor your hosting environment and budget to fit your application

            05:59:50.880 --> 06:00:01.120
            needs. The next topic we'll be going over is enabling diagnostic logging in Azure App Service.

            06:00:01.120 --> 06:00:05.600
            Azure provides built in diagnostics to assist with debugging an app service app.

            06:00:05.600 --> 06:00:09.920
            Diagnostics logging is an important part of any web applications operation.

            06:00:09.920 --> 06:00:14.720
            It allows you to troubleshoot exceptions, not exception errors, alerts and warnings as well

            06:00:14.720 --> 06:00:19.680
            as track and improve the user experience. With Azure diagnostics logging, you may log

            06:00:19.680 --> 06:00:25.760
            application events generated by your application, web server logging with a raw version of requests

            06:00:25.760 --> 06:00:31.280
            made to your app only available for the Windows platform. Detailed error pages saving copies of

            06:00:31.280 --> 06:00:35.920
            the error pages presented to your user only available for the Windows platform.

            06:00:35.920 --> 06:00:40.160
            Fail request tracing with detailed information regarding failed requests.

            06:00:40.160 --> 06:00:44.400
            Deployment logging logging detailed information about the deployment process in order to

            06:00:44.400 --> 06:00:49.840
            troubleshoot when a deployment fails. To enable application logging for Windows apps in the Azure

            06:00:49.840 --> 06:00:55.040
            portal, navigate to your app and select app service logs. Select on for either application

            06:00:55.040 --> 06:01:00.720
            logging or application logging or both. The file system option is for temporary debugging purposes

            06:01:00.720 --> 06:01:05.840
            and turns itself off in 12 hours. The blob option is for long term logging and needs a blob storage

            06:01:05.840 --> 06:01:10.800
            container to write logs to. You can also set the level of details included in the log is shown in

            06:01:10.800 --> 06:01:16.720
            the table below. Disabled this level doesn't capture any logs. Error at this level only error

            06:01:16.720 --> 06:01:22.720
            and critical logs are captured. Warning this level captures logs that are warning error and critical

            06:01:22.720 --> 06:01:28.000
            information. This level encompasses a broader range of logs capturing info, warning error and

            06:01:28.000 --> 06:01:33.520
            critical categories. Verbose this is the most detailed level capturing all categories trace,

            06:01:33.520 --> 06:01:39.120
            debug, info, warning, error and critical. In essence, as you move from disabled to verbose,

            06:01:39.120 --> 06:01:43.760
            the range of logs captured increases with verbose capturing the most comprehensive set of logs.

            06:01:43.760 --> 06:01:50.320
            Enable application logging for Linux container in app service logs set the application logging

            06:01:50.320 --> 06:01:56.640
            option to file system and quota specify the disk quota for the application logs in retention period

            06:01:56.640 --> 06:02:01.600
            set the number of days the logs should be retained. When finished, select save it.

            06:02:01.600 --> 06:02:05.600
            So as your app services, diagnostic logging is essential for optimizing

            06:02:05.600 --> 06:02:07.920
            troubleshooting and monitoring your application.

            06:02:07.920 --> 06:02:17.920
            Let's take a look at configuring Azure Web App settings. Azure Web App settings can be configured

            06:02:17.920 --> 06:02:23.200
            through the Azure portal or the Azure CLI. The Azure portal also offers a bulk editing option.

            06:02:23.200 --> 06:02:27.120
            The main settings that may be configured for your Azure Web App are the following

            06:02:27.120 --> 06:02:33.360
            TSL SSL settings to have a secure and encrypted communication channel API settings such as

            06:02:33.360 --> 06:02:38.880
            technology stack or platform settings app settings you can override your configuration stored on the

            06:02:38.880 --> 06:02:44.960
            web configure connection strings in order to do not have it written on the web config. Default

            06:02:44.960 --> 06:02:51.200
            documents displays default web pages when accessing the root of your website URL path mappings configure

            06:02:51.200 --> 06:02:57.040
            settings according to the user OS. Overall, Azure Web App settings offer a simplified way to optimize

            06:02:57.040 --> 06:03:06.640
            and secure your Azure Web application. Hey, this is Andrew Brown from exam Pro. And we are going

            06:03:06.640 --> 06:03:11.520
            to be learning about Azure App Services in this follow along. And it's a service that's supposed

            06:03:11.520 --> 06:03:16.160
            to make it easy for you to deploy web applications I say supposed to because it really depends on

            06:03:16.160 --> 06:03:21.600
            your stack. Azure has more synergies with other stacks and others. So like if you're like me,

            06:03:21.600 --> 06:03:25.920
            you're like Ruby on Rails, you're going to find a lot of friction with Rails and Linux. But if

            06:03:25.920 --> 06:03:30.720
            you're using something like Windows servers, or Python or dotnet, you're going to have a much

            06:03:30.720 --> 06:03:34.960
            easier time. So really great service, just wish they'd make it a bit more broad there. But let's

            06:03:34.960 --> 06:03:40.560
            hop into it. So before we can go use that service, let's make sure that it's activated. And so we'll

            06:03:40.560 --> 06:03:46.320
            go over here. And we'll go to Azure subscription. And then down below, we're going to go to resource

            06:03:46.320 --> 06:03:52.960
            provider. Now you think what you could do is just type in app services. And you'd be wrong because

            06:03:52.960 --> 06:03:57.520
            the service is under a particular provider. So if you want to figure out what provider it is,

            06:03:57.520 --> 06:04:05.120
            we can go Azure resource providers. And they have a page on documentation here that lists them all.

            06:04:05.120 --> 06:04:12.960
            So if I search for Azure App Services, it's under web and domain registration. So we're going to

            06:04:12.960 --> 06:04:17.840
            make sure this is registered. If we're using a custom domain, which we are not today, we need

            06:04:17.840 --> 06:04:23.680
            this one activated. So going back here, I will type in web and you can see it's registered. So

            06:04:23.680 --> 06:04:29.040
            if yours is not registered, go ahead and hit that I believe this by default is generally registered

            06:04:29.040 --> 06:04:34.320
            with new Azure accounts. So I don't think that is an issue for you. But we'll go back up here,

            06:04:34.320 --> 06:04:41.280
            close these additional tabs, and we will type in Azure App Services. And we will look for that

            06:04:41.280 --> 06:04:48.160
            service. So there it is. And we'll go ahead and hit add. And so I'm going to give it a new name,

            06:04:48.160 --> 06:04:52.480
            I just made it a moment ago, but I'm going to try again and try to use the same name. So we're going

            06:04:52.480 --> 06:04:59.280
            to call this Voyager. Great. And then I'm going to go ahead and name this Voyager. And I already

            06:04:59.280 --> 06:05:05.440
            know that that is taken. So I'm going to type in Delta flyer. And these are fully qualified domain.

            06:05:05.440 --> 06:05:10.160
            So they are unique with Azure App Services, you can run a Docker container, we're doing code this

            06:05:10.160 --> 06:05:16.400
            time around. And what I like to use is a Ruby. But again, you know, if I want to use the CI CD,

            06:05:16.400 --> 06:05:20.320
            I'm not going to be able to use the deployment center with Ruby. So that is not possible.

            06:05:20.320 --> 06:05:25.200
            And so we're going to go with Python and run either a flask or a Django app, I haven't decided

            06:05:25.200 --> 06:05:31.920
            yet. I am in Canada. So let's go to Canada East. And down below here, we have the plans.

            06:05:31.920 --> 06:05:36.080
            Generally, the plans will tell you the cost underneath, look, you'll notice that it's

            06:05:36.080 --> 06:05:40.320
            loading. But I just want to show you that there are some discrepancies in terms of pricing. So

            06:05:40.320 --> 06:05:48.080
            if I was to go to Azure App Services pricing, and we were to pull this up here, we can kind of see

            06:05:48.080 --> 06:05:56.080
            the pricing here. Okay, and if we scroll on down right now, we're looking at a premium v2. And

            06:05:56.080 --> 06:06:01.280
            oh, no, I don't need help. I'm okay. You'll notice that it's 20 cents per hour. So if I go here and

            06:06:01.280 --> 06:06:08.720
            do that times 730, because there's 730 hours in a year, that's $146. I believe this is showing me

            06:06:08.720 --> 06:06:17.600
            in USD dollars. Yeah. And, and here it's showing me 103 Canadian, which is lower. So it could be

            06:06:17.600 --> 06:06:23.280
            that because I'm running in a Canada East region, it's the price is different. But you could imagine

            06:06:23.280 --> 06:06:32.800
            that if I had this at this cost at what did we say here at 146 USD, check had, I'd actually be

            06:06:32.800 --> 06:06:39.120
            paying $182. So you got to watch out for that kind of stuff. But I'm pretty sure this is what the

            06:06:39.120 --> 06:06:43.840
            cost is. So just be aware that if you look stuff up in here, it's not necessarily reflective. So

            06:06:43.840 --> 06:06:48.480
            you got to do a little bit more work to figure that out. If we wanted to go here, we cannot

            06:06:48.480 --> 06:06:52.800
            choose the free tier when we're using Linux. If we're using Windows, I believe we can use it.

            06:06:52.800 --> 06:06:57.600
            We're working with Linux today. So that's just how it's going to be. For the B one, this is totally

            06:06:57.600 --> 06:07:02.400
            fine. But we want to utilize deployment slots. deployment slots is an advanced feature of

            06:07:02.400 --> 06:07:07.280
            the production version. And that's the only way we're going to be able to use it here. This is 20

            06:07:07.280 --> 06:07:12.320
            cents per hour again. So I don't want to be doing this for too long. But I think what we'll do is

            06:07:12.320 --> 06:07:17.280
            before we do that, we can just do an upgrade to dev to prod. So we can experience that I'm going

            06:07:17.280 --> 06:07:24.800
            to go and just choose B one, okay. So go next. We do not need any application insights for the

            06:07:24.800 --> 06:07:31.600
            time being, and it will not let us so it's okay. We'll go next review and create. And we'll go

            06:07:31.600 --> 06:07:39.680
            ahead and create this resource here. And I will see you back when this is done. So our resources

            06:07:39.680 --> 06:07:44.480
            now set up, we'll go to resource. And now that we're in here, you'll notice if we hit browse,

            06:07:44.480 --> 06:07:48.880
            we're not going to see anything because we do not have anything deployed, which makes sense, right.

            06:07:48.880 --> 06:07:52.880
            So we're gonna actually have to go ahead and deploy something. So we are going to make our

            06:07:52.880 --> 06:07:58.640
            way over to the deployment center. And it's just going to tell us that we have yet to configure

            06:07:58.640 --> 06:08:04.480
            anything. And that's totally fine. We're going to go to settings. It'll give it a moment. And so

            06:08:04.480 --> 06:08:09.600
            the thing is, is that we're going to need something to deploy. I did not create an app. But the great

            06:08:09.600 --> 06:08:15.360
            thing is in the Azure documentation, they have a bunch of quick starts here. All right. And

            06:08:15.360 --> 06:08:21.440
            apparently they have one for Ruby as well. But today we are looking at Python. And so they actually

            06:08:21.440 --> 06:08:29.200
            have an example repository for us here, which is github.com Azure samples, Python docs, hello world.

            06:08:29.200 --> 06:08:33.120
            And I mean, I could go make a repo for you. But we might as well just use the one that is already

            06:08:33.120 --> 06:08:38.160
            provided to us. So I'm just going to pull this up to show you what's in it. It's a very, very simple

            06:08:38.160 --> 06:08:42.240
            application. Even if you don't know anything about building web apps, I'm going to walk you through

            06:08:42.240 --> 06:08:47.520
            it really easily here. Okay, so we're going to open up app.py. So we are using flask. If you've

            06:08:47.520 --> 06:08:54.560
            never heard of flask, it is a very minimal Python framework for creating web apps. Very uninspiring

            06:08:54.560 --> 06:08:59.760
            homepage here, but it gets the job done. It's going to create a default route for us, which

            06:08:59.760 --> 06:09:05.440
            we have there, we're going to call Hello here. And we're going to have Hello world. So that's all

            06:09:05.440 --> 06:09:11.760
            that's going on here. Very, very simple. And we have a requirements. This is our package manager.

            06:09:11.760 --> 06:09:15.760
            I don't know why Python uses txt files is very outdated to me, but that's what they use.

            06:09:15.760 --> 06:09:22.480
            And here we have flask. Alright, so we're going to use that repo. It's a public repo. So it should

            06:09:22.480 --> 06:09:30.320
            be very easy for us to connect. So we'll drop down, go to GitHub. And the next thing we need to do is

            06:09:30.320 --> 06:09:35.600
            authorize GitHub. Alright, so I ran into a bit of trouble there because I could not authenticate my

            06:09:35.600 --> 06:09:40.800
            GitHub account. But you know what, I just made another GitHub account. So that made it a lot

            06:09:40.800 --> 06:09:45.440
            easier. I'm going to go ahead here, hit GitHub, and we're going to try to authorize it. And so

            06:09:45.440 --> 06:09:50.160
            now I'm logged into this new one called exam Pro dev. And we'll go ahead and authorize this

            06:09:50.160 --> 06:09:55.680
            application. And we're now in good shape. This repository doesn't have anything in it. So

            06:09:56.400 --> 06:10:02.640
            if I want to clone something, I guess I'll probably have to fork that repo. So we'll give it a moment

            06:10:02.640 --> 06:10:06.400
            to authorize and while that's going, I think that's what I'm going to do. I'm going to go and

            06:10:06.400 --> 06:10:15.920
            fork the example repo if I can find the link again here. Myself. I believe

            06:10:15.920 --> 06:10:22.800
            it is. That's still authorizing over there. I'm still looking for it. So

            06:10:23.920 --> 06:10:27.120
            it was like examples or something samples or examples.

            06:10:27.120 --> 06:10:33.760
            Alright, so I found a way around the problem. I just made a new GitHub account. So that's all I

            06:10:33.760 --> 06:10:39.120
            had to do. And I just won't be using my primary account till I get my phone back. But so what

            06:10:39.120 --> 06:10:44.640
            we'll do is go hit connect, I'll hit authorize. And it didn't prompt me because it already connected

            06:10:44.640 --> 06:10:48.640
            to this new one called exam Pro dev, you might have to put your credentials in here. And it's

            06:10:48.640 --> 06:10:52.240
            going to ask me to select some things. It's a new account. So there are no organizations,

            06:10:52.240 --> 06:10:57.680
            there are no repositories, there are no branches totally brand new. So what I'm going to need to do

            06:10:57.680 --> 06:11:04.240
            is get a repo in there. So we'll just go ahead and fork the Azure samples one. So that is Azure

            06:11:04.240 --> 06:11:12.880
            samples, Python, docs, hello world. If I type that right, we're in good shape, I'm going to go ahead

            06:11:12.880 --> 06:11:20.880
            and fork this repository. I'll say got it. And then I'll move this off screen here. This is now

            06:11:20.880 --> 06:11:27.680
            cloned, you should see a clone here. And we'll go back here. And this probably isn't live. So

            06:11:27.680 --> 06:11:33.120
            there's no refresh button here. So we'll have to hit discard. And we will give this another go here.

            06:11:33.120 --> 06:11:40.160
            And we will select our organization, which is our name, there was the repository should be main

            06:11:40.160 --> 06:11:45.280
            branch is kind of outdated. I'm sorry, but it's called master. That's what it is. Not my fault.

            06:11:45.280 --> 06:11:53.280
            That's Azure's fault. Okay. And I think that's it. I don't know if we need a workflow configuration

            06:11:53.280 --> 06:12:00.640
            file. I don't think so. It's going to double check here. No, I don't think so. And what we'll do is

            06:12:00.640 --> 06:12:16.000
            we'll just go ahead and save that. And so now we are set up for deployment.

            06:12:16.000 --> 06:12:22.800
            Alright, so now that that's all hooked up, if we were to go to browse, we're actually still

            06:12:22.800 --> 06:12:28.480
            seeing the default page, a deployment hasn't been triggered just yet. So the way it works is it's

            06:12:28.480 --> 06:12:33.360
            using GitHub action. So if we click into our, I call it main branch, I know they got the wrong name,

            06:12:33.360 --> 06:12:38.480
            but we're going to click into our GitHub workflows. And then below here, we can see we have a yaml

            06:12:38.480 --> 06:12:43.520
            file. And this is for GitHub actions integration here. And so what it's doing is it's specifying

            06:12:43.520 --> 06:12:49.440
            the branch, what how it's going to build, it's going to run on Ubuntu latest, the steps it's

            06:12:49.440 --> 06:12:53.200
            going to do, it's going to check it out, it's going to set up the Python version, it's going

            06:12:53.200 --> 06:12:59.840
            to build it, it's going to do that stuff. And so in order for this to take action, we'd actually

            06:12:59.840 --> 06:13:05.920
            have to go ahead and make some kind of manual change, which we have yet to do so. So what we'll

            06:13:05.920 --> 06:13:14.400
            do is we'll go back to our main here. And it should be as simple as just changing something here.

            06:13:14.400 --> 06:13:19.280
            So it's not, I'm not sure how it's supposed to know that it's supposed to be doing the Hello,

            06:13:19.280 --> 06:13:24.240
            I guess. Yeah, sorry. So this means it's going to route over to here. So I'm just going to make any

            06:13:24.240 --> 06:13:29.280
            kind of change here. It doesn't matter what it is just one space, we'll go ahead and give it a commit.

            06:13:29.280 --> 06:13:36.240
            And if I go back to my latest commits, we should see that I made that change. There it is.

            06:13:36.240 --> 06:13:40.320
            We'll go back over here. And this should be deploying.

            06:13:40.320 --> 06:13:48.720
            So if we go over to logs, here, you can see one's in progress right now. Okay. And so that's what

            06:13:48.720 --> 06:13:52.480
            we're waiting, we're just going to see that finish there, we probably open the logs and get some more

            06:13:52.480 --> 06:13:57.520
            information there. And so it just brings you back over to GitHub actions. And so here's GitHub actions,

            06:13:57.520 --> 06:14:02.080
            and it's performing the stuff here. So we're just gonna give it time here. And I'll see you back in

            06:14:02.080 --> 06:14:07.440
            a moment. So we didn't have to wait too long, it only took one minute and 29 seconds. If we go back

            06:14:07.440 --> 06:14:14.000
            over here, we might need to do a refresh. And so we can see this is reflected over here. And so if

            06:14:14.000 --> 06:14:18.400
            we go back to it doesn't really matter if we go to settings or logs here, but I'm gonna hit browse,

            06:14:18.400 --> 06:14:23.520
            and see if my page is deployed, it still is not. So we do have a small little problem here. And

            06:14:23.520 --> 06:14:26.720
            it's really going to just have to do with how the app is served. So that's what we need to figure

            06:14:26.720 --> 06:14:32.000
            out next. Alright, so our app is not currently working. And there's a few approaches we can take.

            06:14:32.000 --> 06:14:36.560
            And the thing I can think right away is we should go and SSH into that instance. If you scroll on

            06:14:36.560 --> 06:14:41.920
            down here from developer tools, you can go to SSH and click this button. And that's going to SSH you

            06:14:41.920 --> 06:14:50.720
            right into that machine right away. You can also access SSH via the CLI command. So I believe it's

            06:14:50.720 --> 06:15:01.280
            like it's like AZ web app. SSH, it'll do the exact same thing you do that from the cloud shell. But

            06:15:01.280 --> 06:15:06.000
            that's not we're doing today. But give us an LS in here. And we're in Linux, we can see we have our

            06:15:06.000 --> 06:15:12.800
            app here. And what I would do is I would see what's running. So I would do a Puma, or sorry,

            06:15:12.800 --> 06:15:20.800
            not Puma, PS ox grep, Python. And you can notice that we have G unicorn that's running. So that is

            06:15:20.800 --> 06:15:25.040
            where our Python instances are running. So you're not looking for flask, you're looking for Python

            06:15:25.040 --> 06:15:30.560
            here. And if we wanted to make sure that was working, we just type in curl, localhost.

            06:15:33.520 --> 06:15:39.200
            And so that is going to return a port 80. So that tells me that because I curl just means like,

            06:15:39.200 --> 06:15:44.480
            let's go look at that page, it should return some HTML, like print out the HTML to us. So that means

            06:15:44.480 --> 06:15:52.560
            the app is not running. So what you could do is run flask run. And it's going to start on port 5000.

            06:15:52.560 --> 06:16:00.160
            Right, so what I can do is I can go up back to my deployment center here.

            06:16:01.680 --> 06:16:07.680
            And I'm going to go get that link here. And just ignore the fact that it's working. It's it's not

            06:16:07.680 --> 06:16:12.800
            working right now. I know for certain it's not. But if we do 5000, that won't resolve because

            06:16:12.800 --> 06:16:18.880
            port 5000 isn't open. So we can't really just put 5000 in there. And the default server here would

            06:16:18.880 --> 06:16:28.960
            be 5000. So if I stop this, and I specify port 80, right, then this will start up the app on port 80.

            06:16:28.960 --> 06:16:35.680
            And so now when you go here, okay, it will work. This is not a great way. Because, of course,

            06:16:35.680 --> 06:16:40.960
            as soon as you kill it here, technically, the site should stop running. And so you'll run into that

            06:16:40.960 --> 06:16:46.880
            step. So what we need to do is provide a configuration to G unicorn, which is a Python

            06:16:46.880 --> 06:16:50.640
            thing. Again, it's not so important that you know how like what these things are. But the idea is

            06:16:50.640 --> 06:16:55.040
            that you understand as administrator, you want to make sure you have an app that runs after you do

            06:16:55.040 --> 06:17:01.200
            a deploy. And so in this particular one, we need a startup dot txt. And interestingly enough, there

            06:17:01.200 --> 06:17:06.000
            is a example code by the same author of the other one we were looking at here, I believe it's the

            06:17:06.000 --> 06:17:13.040
            same person. Or it might not be, but they have a startup txt, right. And so in here, you can see

            06:17:13.040 --> 06:17:19.040
            that it binds on port 000, it starts up for workers starts up the app. All right. And so that's

            06:17:19.040 --> 06:17:26.000
            something that we can go ahead and do. So what I will do is I will go back to my GitHub repository

            06:17:26.000 --> 06:17:34.560
            that we have here. And I can just go ahead and add a new file. So I'm going to say,

            06:17:34.560 --> 06:17:45.520
            add a file, create a new file here, we'll call it startup dot txt. I'm going to copy this command

            06:17:45.520 --> 06:17:52.560
            here and paste it in there. So G unicorn will bind the workers and start up on the app. startup app

            06:17:52.560 --> 06:17:57.120
            is being ran by something here. So if I go back here, I think they have a startup pie here.

            06:17:57.120 --> 06:18:06.400
            And that's all that it is doing. I think I want to I could do it this way, I suppose,

            06:18:06.400 --> 06:18:11.520
            let me just see here. There's just a slightly different name. So they actually have like a full

            06:18:11.520 --> 06:18:19.600
            app going on here. And I just want a very simple flask app. So I think what I can do is put flask

            06:18:19.600 --> 06:18:29.760
            run here. Or 80. And that should start up the app there, I'm going to go ahead and commit that file.

            06:18:29.760 --> 06:18:34.560
            Okay. And as soon as I commit that, if I go back to my actions,

            06:18:35.440 --> 06:18:41.440
            it created that startup file there. So it should trigger a build. It's queued up.

            06:18:41.440 --> 06:18:48.000
            And I'll just put this tab up here. So we'll be back here in two seconds. And if I give this a

            06:18:48.000 --> 06:18:53.280
            nice refresh, yeah, you can see it deploys in progress. So this doesn't take too long, we'll

            06:18:53.280 --> 06:18:57.760
            just wait, close that there. We'll just wait a few minutes, we'll click logs, it just opens it back up

            06:18:57.760 --> 06:19:02.720
            here. And we'll see how that goes. Alright, so your deploy may have finished there. But the thing is,

            06:19:02.720 --> 06:19:07.520
            is that we're not going to really know if a change has taken effect unless we actually go ahead and

            06:19:07.520 --> 06:19:13.200
            update our code. So what I want you to do is go to your code tab, go to your app.pi, we'll hit edit,

            06:19:13.200 --> 06:19:19.840
            and I'm going to go ahead and change this to Vulcan. And then we'll scroll on down, hit commit

            06:19:19.840 --> 06:19:25.040
            changes. And we'll make our way back over to our deployment center. And we'll give it a refresh

            06:19:25.040 --> 06:19:29.680
            here. And we're just going to wait until this one is complete. And we will double check to make sure

            06:19:29.680 --> 06:19:35.200
            that that has changed. If it's not, we will take action to fix that. Okay. Alright, so we just

            06:19:35.200 --> 06:19:41.120
            waited a little while there for that deploy to happen. And if we go to our website here, it is

            06:19:41.120 --> 06:19:46.080
            taking effect. So that's all we had to do to get it working. So that's pretty good. So that is

            06:19:46.080 --> 06:19:55.280
            deployment. So let's talk about deployment slots. In order to utilize this feature, we're going to

            06:19:55.280 --> 06:19:59.760
            actually have to upgrade our account because we cannot utilize them. At this, the basic plan here,

            06:19:59.760 --> 06:20:06.000
            we got to go to standard or premium. So let's go ahead and give that an upgrade. So here's the B1,

            06:20:06.000 --> 06:20:13.920
            we're going to go to production here. And I think Yeah, we're gonna have to choose this one here.

            06:20:13.920 --> 06:20:17.920
            Very expensive. So the thing is, we're going to just upgrade it temporarily,

            06:20:17.920 --> 06:20:23.680
            unless there's more options down below that are cheaper. Yeah, these are the standard tiers.

            06:20:24.560 --> 06:20:28.960
            Let's go with this one here, because it's only $80. Again, we're not going to be doing this for

            06:20:28.960 --> 06:20:33.920
            long. But I want to show you how to do staging slots and auto scaling. Okay, so we'll go ahead

            06:20:33.920 --> 06:20:40.560
            and apply that there. And now it says that it's applied. So if I go back to our app here,

            06:20:40.560 --> 06:20:44.400
            and we click on deployment slots, sometimes it doesn't show up right away. If it doesn't,

            06:20:44.400 --> 06:20:49.120
            that's not a big deal. You just wait a bit. But today, it's super fast. So we're going to go

            06:20:49.120 --> 06:20:54.240
            ahead and add a new slot, we're going to call it staging, we're going to deploy from our production

            06:20:54.240 --> 06:21:03.120
            branch here, and I'm going to go ahead and create that there. And we'll just wait until that's done,

            06:21:03.120 --> 06:21:09.840
            okay. Great. So we waited a little bit there, and our slot is created. So I'm going to just hit

            06:21:09.840 --> 06:21:15.520
            close there. And so now let's go take a look and see if we can actually see the application here.

            06:21:15.520 --> 06:21:19.440
            So I just clicked into it, I click browse, and we're getting the default page. So nothing is

            06:21:19.440 --> 06:21:24.720
            actually really deployed to it. So how are we going to do that? That's the main question here.

            06:21:24.720 --> 06:21:30.240
            So what I'm going to do is I'm going to make my way over to the deployment center.

            06:21:30.240 --> 06:21:39.040
            And you can see that it's not configured for this slot. So we are going to have to set it up all

            06:21:39.040 --> 06:21:43.040
            over again, even though copied over configuration settings, it didn't copy over the code.

            06:21:43.040 --> 06:21:48.160
            So we go to GitHub, we'll choose our organization. Again, I'm going to choose the repository,

            06:21:48.160 --> 06:21:52.800
            we're going to choose that main branch again, there, we're going to let it add a workflow.

            06:21:52.800 --> 06:21:56.080
            And notice that this time, it's going to call it staging dot yaml. So there'll be a separate

            06:21:56.080 --> 06:22:00.080
            workflow that gets created, we're going to go ahead and save that there.

            06:22:00.080 --> 06:22:10.800
            And what we can do is, again, click on to our branch name there. And if we click into our

            06:22:10.800 --> 06:22:16.000
            workflows, we'll note now notice that we have a staging example, it's the same thing. But it

            06:22:16.000 --> 06:22:23.040
            should be able to now deploy. So the whole purpose of these deployment branches is that it helps us,

            06:22:23.040 --> 06:22:28.160
            we can deploy different versions of our apps. But it also, it's just a place where we can

            06:22:28.160 --> 06:22:33.280
            view things before we actually roll them out. So we want to make sure 100% that they are working

            06:22:33.280 --> 06:22:38.000
            correctly. I don't think this will automatically push out, let me just go to my actions to see if

            06:22:38.000 --> 06:22:43.040
            this is deploying. Notice that we have two workflows. Now we have staging here. And yeah,

            06:22:43.040 --> 06:22:47.680
            it looks like it's going to deploy here. So we'll just wait a little bit. But maybe what we can do

            06:22:47.680 --> 06:22:53.120
            is try to have a slightly different version for each one here. Okay. But we'll just let that

            06:22:53.120 --> 06:23:01.360
            finish and I'll see you back in a moment. Alright, so our deploy finished there. So now if we go

            06:23:01.360 --> 06:23:06.640
            back to our website, here we go browse, we should see that application says hello Vulcan.

            06:23:06.640 --> 06:23:12.240
            And if we go and take out this, we still have hello Vulcan. So how can we have a variant of this

            06:23:12.240 --> 06:23:16.240
            so that we can push out to that. So what I'm going to do is I'm going to go back to my application

            06:23:16.240 --> 06:23:22.640
            here, I'm going to go to code. And I'm just going to make a minor change. I don't say else's. Does

            06:23:22.640 --> 06:23:29.360
            that spell right startup doesn't look correct to me. So maybe I'll go and adjust that file,

            06:23:29.360 --> 06:23:33.760
            but it doesn't seem to be affecting anything, which is I'm a bit surprised there. So what I'll do

            06:23:33.760 --> 06:23:40.400
            is, I'm going to go and edit that file and give it the proper name. Can I rename this file?

            06:23:41.520 --> 06:23:46.800
            Yes, I can. So we'll call that startup file. I thought we knew that for deploying, I guess it

            06:23:46.800 --> 06:23:51.920
            just works without it, which is nice. If we go back here, I'm going to go and actually just want

            06:23:51.920 --> 06:24:01.520
            to edit my app here again. And I'm going to go and edit this. And we'll say, Hello, and Doria.

            06:24:01.520 --> 06:24:05.360
            Or Hello, and Dorian's maybe.

            06:24:08.240 --> 06:24:11.920
            And so if I go back to my actions, the question, what is it deploying? Is it going to deploy

            06:24:11.920 --> 06:24:16.880
            the production or the staging? And it looks like it's going to do

            06:24:16.880 --> 06:24:24.800
            both. Looks like it's doing both here. But one way we could tell is we can go to our logs here.

            06:24:24.800 --> 06:24:29.360
            And we can see that. So we did to deploy. So there's one change here.

            06:24:29.360 --> 06:24:33.360
            If we go back to our main application or deployment center here,

            06:24:36.880 --> 06:24:43.040
            we go over to our logs, you can see that they're both deploying. So it doesn't seem like it's a

            06:24:43.040 --> 06:24:48.880
            great thing that that's how it works. So the question is, is then how would we facilitate

            06:24:48.880 --> 06:24:53.360
            that deploy? Right? How could we do that? I suppose what we could do is just make a separate

            06:24:53.360 --> 06:25:01.280
            staging branch. So if I go over to code here, I don't think we can just make branches through

            06:25:01.280 --> 06:25:05.920
            here. So what I'm going to have to do is go ahead and Oh, I can create a branch right here. So we'll

            06:25:05.920 --> 06:25:13.520
            just type in staging. And we'll go create ourselves a new branch. And now we're in this branch. And

            06:25:13.520 --> 06:25:22.080
            what I'm going to do is go ahead and modify this. And we're just going to call this Hello, Klingons.

            06:25:22.080 --> 06:25:29.200
            Okay, we'll go ahead and update that. And so this should be a separate branch. So you think what we

            06:25:29.200 --> 06:25:34.400
            could do is go in and just change our settings so that it deploys from that one. We'll go back to

            06:25:34.400 --> 06:25:42.240
            our deployment slots. We'll click into staging here. And we need to change our configuration

            06:25:42.240 --> 06:25:50.800
            settings. I think we could just do it from here. Hold on here. I could have swore it specified the

            06:25:50.800 --> 06:25:56.800
            branch to go to deployment center here. I think it's set up on that other branch there. I think

            06:25:56.800 --> 06:26:05.760
            we just adjusted here. So yeah, I think we could just adjust these settings. We can't discard them.

            06:26:05.760 --> 06:26:14.480
            But maybe what we can do is just go in and modify that file. So we will go into our code here.

            06:26:14.480 --> 06:26:21.920
            And we will go ahead and click into here, go into staging, and we'll just change what the

            06:26:21.920 --> 06:26:32.960
            branch is called. So we'll just say staging. And we'll hit start commit, and we will save that.

            06:26:32.960 --> 06:26:39.360
            And we'll see if it actually reflects those changes there. So we will go here and hit refresh.

            06:26:39.360 --> 06:26:45.520
            We'll see if it picks up staging. Now if we go to settings,

            06:26:47.200 --> 06:26:52.800
            it's not picking it up. So I'm not sure I don't think from a redeploy operation,

            06:26:52.800 --> 06:26:56.880
            we don't want to redeploy. So maybe what we'll do is just we'll have to do a disconnect here

            06:26:56.880 --> 06:27:04.720
            because it's clicked it has the wrong one here. So say workflow file. Okay, well, let's go ahead

            06:27:04.720 --> 06:27:09.520
            and delete it. It's not a big deal. We'll just have to make a new one here. We'll go to GitHub,

            06:27:09.520 --> 06:27:15.760
            we'll choose our organization again, or repository, our staging branch this time around,

            06:27:16.320 --> 06:27:20.000
            we'll let it add one see it says we use an available workflow. So we could have kept it

            06:27:20.000 --> 06:27:26.560
            there and added it there. And we'll go ahead and save that. So now we'll have two separate branches

            06:27:26.560 --> 06:27:32.080
            there. And we'll give that some time to deploy, because that will now trigger deploy off the bat.

            06:27:32.080 --> 06:27:36.000
            And so I'll see you back here in a moment. Alright, so after a short little wait here,

            06:27:36.000 --> 06:27:39.680
            it looks like our app is done deploying. So we'll go over here, we'll make sure that this is our

            06:27:39.680 --> 06:27:44.880
            staging server is good. And we want to see that our production is different. Perfect. So we now

            06:27:44.880 --> 06:27:50.480
            have a way to deploy to each one. But imagine that we want to swap our traffic. So we're happy with

            06:27:50.480 --> 06:27:55.200
            our staging server, we want to roll that out to production. And that's where we can do some swap.

            06:27:55.200 --> 06:27:59.920
            And so what we'll do is click the swap button. And we're going to say the source is the staging.

            06:27:59.920 --> 06:28:04.640
            And this is our target production. And we're going to perform that swap. Right now, we can't do

            06:28:04.640 --> 06:28:09.440
            a preview because we don't have a particular setting set, that's okay. And it's kind of

            06:28:09.440 --> 06:28:13.680
            showing if there are any changes. So set of configuration changes, we don't have any. So

            06:28:13.680 --> 06:28:19.840
            that's totally fine as well. We'll go ahead and hit swap. And that's going to swap those two,

            06:28:19.840 --> 06:28:24.080
            I believe it's have to have zero downtime. So we'll be in good shape if that happens there.

            06:28:24.080 --> 06:28:28.960
            And we'll just give it a moment to do that.

            06:28:28.960 --> 06:28:37.440
            Great. And so after a short little wait there, the swap is complete. And so if we remember clearly,

            06:28:37.440 --> 06:28:41.280
            this was our production, right. And so if I was to hit refresh,

            06:28:42.080 --> 06:28:46.240
            so now say Klingons, and if I go to my staging server, it should be the other way around, right?

            06:28:46.240 --> 06:28:52.640
            Good. So now imagine that I want to just split the traffic, that's something else that we can do.

            06:28:52.640 --> 06:28:58.480
            So notice over here, we have these percentages here. Not sure why it won't let me change those.

            06:28:58.480 --> 06:29:04.400
            So maybe I'll have to look into that. So I'll be back. So I'm not sure why it's not showing us

            06:29:04.400 --> 06:29:08.880
            that traffic slot there. But what I'm going to do is just maybe try to trigger deploy back into our

            06:29:08.880 --> 06:29:13.920
            staging. And maybe that's what it wants to see. So what I'm going to do is go back to my code here,

            06:29:13.920 --> 06:29:18.640
            we'll be in our staging branch here, I'm going to go ahead and edit this file here.

            06:29:18.640 --> 06:29:27.680
            And we will just change this to majority. And we will hit update.

            06:29:27.680 --> 06:29:34.160
            And we will let that go ahead and deploy. So if we go to actions here, we can see that it is

            06:29:34.160 --> 06:29:39.600
            deploying. And we'll just give it some time. Okay, so see you back here in a bit. I mean,

            06:29:39.600 --> 06:29:42.720
            the other reason could be that we're just not at the main level. Hold on here.

            06:29:42.720 --> 06:29:50.880
            If we go back here to deployment slots, you know what, I think it's just because I was clicked into

            06:29:50.880 --> 06:29:55.680
            here. And then I was clicked into deployment slots that they're both grayed out. Yeah, it is. So we

            06:29:55.680 --> 06:30:00.000
            can actually do it that top level there. It doesn't hurt to do another deploy, though. So we'll just

            06:30:00.000 --> 06:30:04.960
            wait for always for that deploy to finish. And then we'll come here and adjust that there. Okay.

            06:30:04.960 --> 06:30:09.840
            Alright, so let's take a look at doing some traffic switching here. So right now,

            06:30:09.840 --> 06:30:15.760
            if we were to go to our production, we have Klingons. And if we were to go to our staging,

            06:30:15.760 --> 06:30:25.840
            we have a drawer. And so imagine that we only want 50% of that traffic to show up. So what we can do

            06:30:25.840 --> 06:30:33.680
            is put in 50%. And what I'm going to do is, um, do I hit Enter here, or Oh, sorry, save up here.

            06:30:33.680 --> 06:30:40.800
            There we go. And so what's going to happen is this should take effect, I think right away. Yep. And

            06:30:40.800 --> 06:30:46.080
            so now we have 50 50 50% chance of getting something else here. So I'm just gonna keep on

            06:30:46.080 --> 06:30:51.680
            hitting Enter here. If that doesn't work, we can try an incognito tab. And there we go, we got the

            06:30:51.680 --> 06:30:57.600
            opposite there. And so this is serving up staging, right. And this is serving up production, but

            06:30:57.600 --> 06:31:03.280
            they're both on the production URL. So that's the way you can split the traffic. So that's pretty

            06:31:03.280 --> 06:31:11.120
            much all I wanted to show you for deployment slots. Let's now talk about scaling. Hey, this

            06:31:11.120 --> 06:31:16.160
            is Andrew Brown from exam Pro. And in this section, we'll be covering Azure Container Instances.

            06:31:16.160 --> 06:31:20.000
            Azure Container Instances allow you to launch containers without the need to worry about

            06:31:20.000 --> 06:31:24.960
            configuring or managing the underlying virtual machine. Azure Container Instances is designed

            06:31:24.960 --> 06:31:30.080
            for isolated containers. They are tailored for simple applications, task automation and tasks

            06:31:30.080 --> 06:31:35.040
            like build jobs. containers can be provisioned within seconds, whereas VMs can take several

            06:31:35.040 --> 06:31:40.240
            minutes. containers are built per second, whereas VMs are built per hour providing potential cost

            06:31:40.240 --> 06:31:46.880
            savings. containers have granular and custom sizing of vCPUs memory and GPUs whereas VM sizes

            06:31:46.880 --> 06:31:52.560
            are predetermined. ACI can deploy both Windows and Linux containers. You can persist storage with

            06:31:52.560 --> 06:31:58.720
            Azure files for your ACI containers. Once deployed, ACI is are accessible via a fully qualified domain

            06:31:58.720 --> 06:32:04.640
            name like custom label dot Azure region dot Azure container dot IO. Azure provides quick start

            06:32:04.640 --> 06:32:09.280
            images to start launching example applications. But you can also source containers from

            06:32:09.280 --> 06:32:13.520
            Azure Container Registry, Docker Hub, or even privately hosted Container Registry.

            06:32:14.560 --> 06:32:18.560
            Container groups are collection of containers that get scheduled on the same host machine.

            06:32:18.560 --> 06:32:24.560
            The containers in a container group share lifecycle resources, local network and storage volumes.

            06:32:24.560 --> 06:32:30.320
            Container groups are similar to a Kubernetes pod. Multi container groups currently support only

            06:32:30.320 --> 06:32:35.920
            Linux containers. There are two ways to deploy a multi container group to deploy a multi container

            06:32:35.920 --> 06:32:40.080
            group. You can use either a resource manager template if deploying additional Azure service

            06:32:40.080 --> 06:32:45.680
            resources or a YAML file for deployments involving only container instances. Overall,

            06:32:45.680 --> 06:32:49.200
            Azure container instances simplify container deployment and scaling,

            06:32:49.200 --> 06:32:51.760
            removing the complexities of infrastructure management.

            06:32:51.760 --> 06:33:00.480
            The next topic we'll be going over our container restart policies.

            06:33:00.480 --> 06:33:04.640
            A container restart policy specifies what a container should do when their process has

            06:33:04.640 --> 06:33:08.640
            completed. These policies ensure that the container instances can handle different

            06:33:08.640 --> 06:33:12.800
            scenarios effectively based on the specific requirements of the application or task.

            06:33:12.800 --> 06:33:16.640
            Azure container instances has three restart policy options.

            06:33:16.640 --> 06:33:22.000
            Always, this policy ensures that the containers restart continuously regardless of whether they

            06:33:22.000 --> 06:33:26.240
            exit successfully or not. It's useful for applications that need to be constantly

            06:33:26.240 --> 06:33:31.680
            available such as web servers. Never, with this policy containers do not restart once

            06:33:31.680 --> 06:33:36.320
            they've completed their execution. This is ideal for tasks that are designed to run once and then

            06:33:36.320 --> 06:33:42.160
            terminate such as batch jobs or scheduled tasks. On failure, containers will only restart if they

            06:33:42.160 --> 06:33:46.720
            stop due to an error or unexpected termination. This ensures that if a container crashes or

            06:33:46.720 --> 06:33:50.560
            faces an unexpected error, it will try to restart and continue its operations.

            06:33:50.560 --> 06:33:55.280
            Overall, choosing the appropriate restart policy is vital for the stability and

            06:33:55.280 --> 06:33:57.120
            responsiveness of your applications.

            06:33:57.120 --> 06:34:05.360
            The next topic we'll be covering our container environment variables.

            06:34:05.920 --> 06:34:09.840
            Environment variables are key value pairs that can be used to configure and manage the

            06:34:09.840 --> 06:34:15.760
            behavior of applications running inside containers. Environment variables allow you to pass configuration

            06:34:15.760 --> 06:34:20.000
            details to your containers, which can be critical in guiding applications on how to connect to

            06:34:20.000 --> 06:34:24.160
            databases, where to find certain resources, or how to adjust their behavior based on the

            06:34:24.160 --> 06:34:28.720
            environment they're running in. In Azure, you can easily set up these environment variables

            06:34:28.720 --> 06:34:34.560
            for your containers using the Azure portal, CLI, or PowerShell. Secured environment variables,

            06:34:34.560 --> 06:34:39.280
            by default, environment variables are stored in plaintext. To address this, Azure offers

            06:34:39.280 --> 06:34:43.920
            the option to secure your environment variables. Instead of storing them in plaintext, which could

            06:34:43.920 --> 06:34:48.720
            expose sensitive information if breached, you can leverage the secure environment variables flag.

            06:34:48.720 --> 06:34:52.480
            So that's a quick overview of container environment variables.

            06:34:52.480 --> 06:35:01.920
            The next topic we'll be covering is container troubleshooting. Troubleshooting containers

            06:35:01.920 --> 06:35:05.600
            in Azure involves a series of commands that help diagnose and resolve issues.

            06:35:05.600 --> 06:35:10.960
            As container logs, this command lets you fetch logs from your container. These logs can provide

            06:35:10.960 --> 06:35:16.640
            insights into application behavior and possible errors. As container attach, if you need diagnostic

            06:35:16.640 --> 06:35:21.440
            data during container startup, use this command. It helps in understanding issues that might arise

            06:35:21.440 --> 06:35:26.480
            during the initialization phase of a container. As container exec, for a deeper dive into the

            06:35:26.480 --> 06:35:31.040
            container, this command starts an interactive session. This is useful for live debugging and

            06:35:31.040 --> 06:35:36.160
            to inspect the containers current state. As monitor metrics list, this command gives you metrics

            06:35:36.160 --> 06:35:40.720
            related to your container such as CPU usage, which can be essential for performance tuning

            06:35:40.720 --> 06:35:45.920
            or identifying bottlenecks. So these are the commonly used commands for container troubleshooting.

            06:35:45.920 --> 06:35:54.960
            Hey, this is Andrew Brown from exam Pro. And we're going to take a look at Azure container

            06:35:54.960 --> 06:36:00.240
            instances. So here it is. So all we got to do is go to container instances, we'll hit add.

            06:36:00.240 --> 06:36:04.720
            And the nice thing is that Azure provides us with a Hello World one. So it's very easy for us to get

            06:36:04.720 --> 06:36:10.560
            started. It's a Linux machine. And it looks like it's pretty inexpensive there. So we'll stick with

            06:36:10.560 --> 06:36:16.560
            that. I'm going to create a new group here, we're going to call it banana. And we'll name the

            06:36:16.560 --> 06:36:23.200
            container instance banana. And East us to seems fine to me, you'll notice we're on a quick start

            06:36:23.200 --> 06:36:28.080
            image. If we wanted, we could use something from the Docker hub and provide our own link. But we'll

            06:36:28.080 --> 06:36:34.240
            just stick with the quick start image for today. We're going to go ahead and hit next to networking

            06:36:34.240 --> 06:36:40.160
            just to see what we have as options, you can make it public or private. We'll go to advanced Hold on

            06:36:40.160 --> 06:36:45.360
            here. Yep, those are just the ports you can expose. We'll go to advance. And for the restart policy,

            06:36:45.360 --> 06:36:50.960
            we can set on failure always or never, we can pass in environment variables. And I've covered this a

            06:36:50.960 --> 06:36:56.880
            lot more in detail in the lecture content. So we don't need to really dive deep into this. And we'll

            06:36:56.880 --> 06:37:02.640
            go ahead and create this instance. And so we'll have to wait a little while here. And I'll see

            06:37:02.640 --> 06:37:08.000
            you back in a moment. Okay, and so after a short wait, our container instance is ready, we'll go to

            06:37:08.000 --> 06:37:13.520
            that resource there and take a look around. So on the left hand side, we can go to containers. And

            06:37:13.520 --> 06:37:18.640
            there we can see it running, we can see the events down below of what's going on. So you can see that

            06:37:18.640 --> 06:37:25.360
            it's pulled the image, it successfully pulled it, and it started the container, some properties,

            06:37:25.360 --> 06:37:29.120
            nothing interesting there, the logs, if we wanted to see stuff. And if we wanted to connect to the

            06:37:29.120 --> 06:37:34.000
            instance, we could also go here and hit connect, which is kind of nice. I don't have any purpose

            06:37:34.000 --> 06:37:38.320
            to do that right now. So and it's also not going to work the way we're doing it. But I just wanted

            06:37:38.320 --> 06:37:44.320
            to show you you had those opportunities. You can do identity. So that means manage it with role

            06:37:44.320 --> 06:37:49.760
            based access controls. But what I want to see is actually this Hello, world working, I'm assuming

            06:37:49.760 --> 06:37:54.880
            that must be a Hello page, I've never looked at it before. So we're going to go here, grab the

            06:37:54.880 --> 06:38:00.800
            public IP address, and paste it on in the top. And there we go. So we have deployed a instance

            06:38:00.800 --> 06:38:07.040
            onto Azure container instances or a container, I should say. So nothing super exciting to talk

            06:38:07.040 --> 06:38:14.480
            about here. But we do need to know the basics there. If we wanted to deploy other containers,

            06:38:14.480 --> 06:38:20.400
            it's just the one there. So that's all you really need to do. But yeah, so yeah, hopefully that

            06:38:20.400 --> 06:38:24.560
            gives you an idea there. I'll just go back to the list here. So we can see it. And we'll go ahead

            06:38:24.560 --> 06:38:29.600
            and just delete that probably do it for the for the resources on the left hand side, like I always

            06:38:29.600 --> 06:38:37.680
            like to do. And we will go into banana here. And we will delete banana. And there you go.

            06:38:37.680 --> 06:38:49.040
            Hey, this is Andrew Brown from exam Pro. In this section, we're diving into the Azure container

            06:38:49.040 --> 06:38:54.320
            registry. Azure container registry is a managed Docker registry service based on the open source

            06:38:54.320 --> 06:38:59.920
            Docker registry 2.0. It's designed for building storing and managing containerized applications

            06:38:59.920 --> 06:39:05.040
            and images. Use Azure container registries with your existing container development and deployment

            06:39:05.040 --> 06:39:10.400
            pipelines. Use Azure container registry tasks to automate image builds directly in Azure when you

            06:39:10.400 --> 06:39:15.760
            commit code. You can seamlessly pull images from ACR for deployment to various orchestrators such

            06:39:15.760 --> 06:39:22.560
            as Kubernetes DC OS and Docker swarm. Many Azure services including Azure Kubernetes service,

            06:39:22.560 --> 06:39:28.240
            Azure App Service, Azure batch and Azure service fabric offer direct support to interface with ACR.

            06:39:28.240 --> 06:39:33.760
            This ensures a cohesive workflow for deploying applications. Developers can also push container

            06:39:33.760 --> 06:39:37.920
            images to a container registry as part of a container development workflow with delivery

            06:39:37.920 --> 06:39:44.080
            tools such as Azure pipelines and Jenkins. ACR offers various interfaces for interaction,

            06:39:44.080 --> 06:39:49.680
            you can manage and configure it using the Azure CLI, Azure PowerShell, Azure portal, Azure SDK,

            06:39:49.680 --> 06:39:54.960
            or even the Docker extension for Visual Studio Code. In conclusion, Azure container registry

            06:39:54.960 --> 06:39:59.840
            securely and efficiently manages your Docker images, streamlining build, storage and deployment.

            06:39:59.840 --> 06:40:08.080
            The next topic we'll be covering are Azure container registry tasks.

            06:40:08.080 --> 06:40:13.360
            ACR tasks are designed to automate the process of patching the operating system and frameworks

            06:40:13.360 --> 06:40:18.800
            within your Docker containers. For quick tasks, ACR tasks let you instantly push a specific

            06:40:18.800 --> 06:40:23.360
            container image to Azure's container registry without needing a local Docker engine installation.

            06:40:23.360 --> 06:40:28.960
            ACR tasks offer automation flexibility, you can set up automated builds that are triggered by

            06:40:28.960 --> 06:40:35.040
            different events such as updates made to the source code, updates to a containers base image,

            06:40:35.040 --> 06:40:41.200
            or predetermined schedules or timers. With ACR tasks, multi-step workflows become easier. For

            06:40:41.200 --> 06:40:45.440
            example, you could build a web application image, run the web application container,

            06:40:45.440 --> 06:40:49.760
            build a web application test image, and deploy the container that will run tests on the web

            06:40:49.760 --> 06:40:55.440
            application. Each ACR task has an associated source code context, the location of a set of

            06:40:55.440 --> 06:41:01.040
            source files used to build a container image or other artifact. Furthermore, ACR tasks support

            06:41:01.040 --> 06:41:05.920
            the use of run variables, making it possible to repurpose task definitions and enforce consistent

            06:41:05.920 --> 06:41:12.080
            image and artifact tagging standards. In summary, ACR tasks amplify the automation, efficiency,

            06:41:12.080 --> 06:41:21.520
            and consistency of container management in Azure. The next topic we'll be going over is Docker.

            06:41:21.520 --> 06:41:26.720
            Docker is a powerful platform designed for automating the deployment, scaling, and management

            06:41:26.720 --> 06:41:32.320
            of applications using containerization. Docker abstracts infrastructure and environment variables,

            06:41:32.320 --> 06:41:36.640
            allowing you to create a controlled environment within your Docker container. We can install

            06:41:36.640 --> 06:41:41.040
            Docker images into those Docker containers, with each Docker image representing one or a group of

            06:41:41.040 --> 06:41:46.480
            common software. The machine on which Docker is installed and running is usually referred to as a

            06:41:46.480 --> 06:41:51.200
            Docker host or host. When you deploy an application on the host, it will create a logical entity to

            06:41:51.200 --> 06:41:56.160
            host where the application called a container or Docker container. A Docker container does not have

            06:41:56.160 --> 06:42:01.520
            any OS installed and running on it. It has a virtual copy of the process table network interface

            06:42:01.520 --> 06:42:05.280
            and the file system mount point which have been inherited from the OS of the host on which the

            06:42:05.280 --> 06:42:10.240
            container is hosted and running. The kernel of the host OS is shared across all the containers

            06:42:10.240 --> 06:42:15.200
            that are running on it. This allows each container to be isolated from the other present on the same

            06:42:15.200 --> 06:42:19.840
            host. It supports multiple containers with different application requirements and dependencies

            06:42:19.840 --> 06:42:26.560
            to run on the same host if the OS requirements are the same. Docker key benefits. Docker supports

            06:42:26.560 --> 06:42:30.960
            multiple applications with different requirements and dependencies to be hosted on the same host

            06:42:30.960 --> 06:42:36.640
            if the OS requirements are the same. Storage optimized containers are typically a few megabytes

            06:42:36.640 --> 06:42:41.680
            in size and consume very little disk space allowing a large number of applications to be hosted on the

            06:42:41.680 --> 06:42:47.840
            same host. Robustness, robustness containers don't contain a full OS making them more lightweight

            06:42:47.840 --> 06:42:52.400
            than virtual machines. As a result, they use significantly less memory and can boot up in

            06:42:52.400 --> 06:42:58.240
            mere seconds whereas a VM might take several minutes. Reduces costs. Docker is less demanding

            06:42:58.240 --> 06:43:03.760
            when it comes to the hardware required to run it. Better disaster recovery. You can back up a Docker

            06:43:03.760 --> 06:43:07.920
            image of the state of the container at a specific point in time and restore it later if serious

            06:43:07.920 --> 06:43:13.920
            issues arise. Faster configuration with consistency. You can just put your configurations into code and

            06:43:13.920 --> 06:43:19.600
            deploy it saves a lot of time from preparing the setup and deployment documentation. Overall,

            06:43:19.600 --> 06:43:24.240
            Docker provides a robust, efficient and cost effective solution for application deployment

            06:43:24.240 --> 06:43:33.440
            and management through containerization. The next topic we'll be going over is a Dockerfile

            06:43:33.440 --> 06:43:38.160
            in Docker. A Dockerfile is a text document that contains all the commands a user could call on

            06:43:38.160 --> 06:43:43.120
            the command line to assemble an image. By using the Docker build command, users could automate

            06:43:43.120 --> 06:43:48.000
            the image creation process by executing the instructions laid out in the Dockerfile. Here

            06:43:48.000 --> 06:43:52.720
            are some essential points to understand about Dockerfiles. The Dockerfile is a text file that

            06:43:52.720 --> 06:43:57.680
            contains the instructions that you would execute on the command line to create an image. A Dockerfile

            06:43:57.680 --> 06:44:02.480
            is a step by step set of instructions. Docker offers standard commands for use within the

            06:44:02.480 --> 06:44:08.800
            Dockerfile such as from specifies the base image to start with copy copies files from the host

            06:44:08.800 --> 06:44:16.160
            system into the image run executes a command env sets environment variables expose informs Docker

            06:44:16.160 --> 06:44:21.360
            that the container will listen on a specified network port at runtime. CMD provides defaults

            06:44:21.360 --> 06:44:26.080
            for the executing container. Docker will build a Docker image automatically by reading these

            06:44:26.080 --> 06:44:31.200
            instructions from the Dockerfile. Overall, a Dockerfile provides a reproducible and consistent

            06:44:31.200 --> 06:44:41.040
            method to build Docker container images. Hey, it's Andrew Brown from exam Pro. And in this section,

            06:44:41.040 --> 06:44:45.440
            we'll delve into Azure functions. But first, it's essential to understand the concepts of

            06:44:45.440 --> 06:44:50.960
            serverless and functions as a service. So what is serverless serverless architecture generally

            06:44:50.960 --> 06:44:55.920
            describes fully managed cloud services, the classification of a cloud service being serverless

            06:44:55.920 --> 06:45:00.400
            is not a Boolean answer, but an answer on a scale where a cloud service has a degree of serverless.

            06:45:01.040 --> 06:45:04.400
            A serverless service could have all or most of the following characteristics,

            06:45:04.400 --> 06:45:10.000
            high elasticity and scalability, high availability, high durability and secure by default,

            06:45:10.000 --> 06:45:14.960
            abstracts away the underlying infrastructure and are built based on the execution of your business

            06:45:14.960 --> 06:45:20.160
            task. serverless can scale to zero meaning when not in use the serverless resources cost nothing

            06:45:20.160 --> 06:45:26.240
            pay for value model where you only pay for actual usage eliminating costs for idle resources.

            06:45:26.240 --> 06:45:30.640
            An analogy of serverless could be similar to an energy rating labels which allows consumers to

            06:45:30.640 --> 06:45:35.200
            compare the energy efficiency of a product. Some services are more serverless than others.

            06:45:35.200 --> 06:45:41.120
            What is function as a service flyers empowers developers to concentrate on crafting specific

            06:45:41.120 --> 06:45:46.320
            pieces of code known as functions. These functions can be event driven, meaning they either trigger

            06:45:46.320 --> 06:45:50.800
            based on events or produce event data. Typically, several functions are interwoven to form a

            06:45:50.800 --> 06:45:55.920
            serverless application and these functions are activated only when called upon function as a

            06:45:55.920 --> 06:46:00.560
            service is not serverless on its own flyers is only serverless if it's fully managed and scales

            06:46:00.560 --> 06:46:05.680
            to zero. In conclusion, serverless and flyers represent transformative approaches in cloud

            06:46:05.680 --> 06:46:09.760
            computing emphasizing efficiency, scalability and cost effectiveness.

            06:46:09.760 --> 06:46:19.520
            The next topic we'll be covering is Azure functions. Azure functions is a function as

            06:46:19.520 --> 06:46:24.000
            a service offering that allows developers to focus on writing code and not worry about maintaining

            06:46:24.000 --> 06:46:29.200
            the underlying computing infrastructure. A function app defines the underlying compute for a collection

            06:46:29.200 --> 06:46:35.200
            of functions. A function app defines the hosting runtime and other global configurations. A function

            06:46:35.200 --> 06:46:40.640
            represents code along with application runtime configuration. A trigger is the chosen event data

            06:46:40.640 --> 06:46:45.680
            that will cause function to execute. You can only have one trigger. Input bindings are what are

            06:46:45.680 --> 06:46:50.800
            multiple data sources that will be passed to the function when a trigger occurs. Output bindings

            06:46:50.800 --> 06:46:55.280
            are one more data sinks that will receive output of data from the function on successful execution.

            06:46:55.280 --> 06:47:03.680
            There are four versions of Azure functions 1x 2x 3x and 4x we are currently using 4x.

            06:47:03.680 --> 06:47:10.240
            Azure functions storage considerations. Every function app requires a storage account to

            06:47:10.240 --> 06:47:15.200
            operate. If that account is deleted, your functions won't work. Azure functions uses

            06:47:15.200 --> 06:47:20.400
            the following storage types in the storage account. Blob storage maintain binding state

            06:47:20.400 --> 06:47:25.680
            and function keys. Azure files file share used to store and run your function app code in a

            06:47:25.680 --> 06:47:30.400
            consumption plan and premium plan. Azure files is set up by default but you can create an app

            06:47:30.400 --> 06:47:36.320
            without Azure files under certain conditions. Hue storage used by task hubs and durable functions

            06:47:36.320 --> 06:47:43.840
            and table storage also used by task hubs and durable functions. Azure functions anatomy of a

            06:47:43.840 --> 06:47:50.640
            function function dot j s o n configuration of a single function defining bindings code the code

            06:47:50.640 --> 06:47:57.520
            for your function dot funk ignore files to ignore host dot j s o n global configuration of all

            06:47:57.520 --> 06:48:03.840
            functions at the function app level local project a place to locally store code. In conclusion,

            06:48:03.840 --> 06:48:08.560
            Azure functions offers developers an effortless way to build event driven solutions without managing

            06:48:08.560 --> 06:48:18.000
            infrastructure. The next topic we'll be overgoing is the authorization levels for Azure functions

            06:48:18.000 --> 06:48:24.000
            HTTP triggers. Authorization level determines what keys if any need to be present on the request in

            06:48:24.000 --> 06:48:29.440
            order to invoke the function. The authorization level can be one of the following values anonymous

            06:48:29.440 --> 06:48:35.520
            no API key is required function a specific API key for that function is needed admin the master

            06:48:35.520 --> 06:48:40.480
            key for all functions within that function app is required. In this example, we're creating an

            06:48:40.480 --> 06:48:46.320
            HTTP trigger the desired authorization level can be selected. Note that the authorization level can

            06:48:46.320 --> 06:48:52.320
            usually be changed after creation in the portal and is set on the trigger. Azure functions debugging,

            06:48:52.320 --> 06:48:57.040
            you can enable streaming logs for Azure functions to see near real time logging when an error

            06:48:57.040 --> 06:49:01.920
            occurs. There are two ways to view a stream of log files being generated by your function

            06:49:01.920 --> 06:49:07.600
            executions built in log streaming the app service platform provides an inbuilt feature to stream

            06:49:07.600 --> 06:49:14.000
            application log files allowing developers to trace function executions live live metric stream when

            06:49:14.000 --> 06:49:18.320
            your function app is connected to application insights you can view log data and other metrics

            06:49:18.320 --> 06:49:23.200
            in near real time in the Azure portal using live metric stream. It's worth highlighting that these

            06:49:23.200 --> 06:49:27.120
            log streams can be viewed both in the portal and in most local development environments.

            06:49:27.920 --> 06:49:33.680
            Overall, Azure functions provide adaptable HTTP trigger authorization and robust debugging tools

            06:49:33.680 --> 06:49:43.600
            enhancing security and developer troubleshooting. The next let's break them down. Lightweight and

            06:49:43.600 --> 06:49:47.680
            serverless Azure functions are compact and potentially serverless removing the need for

            06:49:47.680 --> 06:49:53.280
            heavy infrastructure, efficiency and speed easy to write, deploy and upgrade without affecting

            06:49:53.280 --> 06:49:58.400
            other website components. Azure functions are fast to execute because there is no large application

            06:49:58.400 --> 06:50:03.600
            startup time initialization and other events fired before the code is executed. Event driven

            06:50:03.600 --> 06:50:08.640
            execution ensures they run only when an event triggers them. Zero maintenance, no need for

            06:50:08.640 --> 06:50:13.360
            active infrastructure management or associated costs. They scale automatically to meet traffic

            06:50:13.360 --> 06:50:18.880
            demands even scaling to zero cost when idle. Development ease Azure functions can be built,

            06:50:18.880 --> 06:50:23.600
            tested and deployed directly from the Azure portal. They provide built in CI CD through

            06:50:23.600 --> 06:50:27.360
            Azure DevOps and monitoring with Azure Monitor streamline the development process.

            06:50:27.360 --> 06:50:32.800
            Cost effective you pay only for the actual runtime eliminating costs when functions are idle.

            06:50:32.800 --> 06:50:38.080
            interoperability using industry standard protocols. Azure functions can seamlessly

            06:50:38.080 --> 06:50:44.800
            communicate with various API's databases and libraries. Azure functions use cases.

            06:50:45.520 --> 06:50:50.960
            For business use cases, Azure functions are great for scheduled tasks, reminders and notifications,

            06:50:50.960 --> 06:50:55.760
            lightweight web API, sending background emails, running background backup tasks and performing

            06:50:55.760 --> 06:51:01.600
            back end calculations. For technical use cases, Azure functions are ideal and sending emails,

            06:51:01.600 --> 06:51:06.080
            starting backup, order processing and task scheduling such as database cleanup,

            06:51:06.080 --> 06:51:12.080
            sending notifications, messages and IoT data processing. Azure functions are best suited for

            06:51:12.080 --> 06:51:17.600
            smaller apps have events that can work independently of other websites. In conclusion, Azure functions

            06:51:17.600 --> 06:51:21.520
            are serverless and efficient streamlining development for both business and technical

            06:51:21.520 --> 06:51:30.880
            tasks and event driven compact applications. The next topic we'll be covering is our Azure

            06:51:30.880 --> 06:51:35.280
            function templates. Azure provides function templates to get you started with common

            06:51:35.280 --> 06:51:40.880
            function scenarios. In Visual Studio Code, the selection of a function template occurs exclusively

            06:51:40.880 --> 06:51:49.360
            during the project creation phase. HTTP triggered by an HTTP request and returns HTTP. Timer triggered

            06:51:49.360 --> 06:51:54.320
            based on a predefined schedule. Blob storage triggered when files are either uploaded or

            06:51:54.320 --> 06:52:00.160
            updated in a blob storage container. Cosmos DB executes in response to the addition or modification

            06:52:00.160 --> 06:52:07.200
            of documents in Cosmos DB. Queue storage triggered by Azure storage queue messages. Event Grid

            06:52:07.200 --> 06:52:11.600
            triggered by event from event grid. Many Azure services can trigger a function through event

            06:52:11.600 --> 06:52:16.240
            grid. Essentially event grid operates as a serverless event bus that is deeply integrated

            06:52:16.240 --> 06:52:22.160
            with various Azure services. Event Hub triggered by event hub event and is particularly effective

            06:52:22.160 --> 06:52:26.800
            for streaming scenarios. Service bus queue triggered when there's a new message in a

            06:52:26.800 --> 06:52:32.800
            service bus queue making it optimal for messaging systems. Service bus topics triggered by an event

            06:52:32.800 --> 06:52:38.720
            from bus topic aligning it with the pub sub model. Send grid specifically designed to be triggered by

            06:52:38.720 --> 06:52:44.720
            an email event within the third party service. Send grid. Overall Azure function templates offer

            06:52:44.720 --> 06:52:49.040
            developers a structured foundation for common scenarios enabling quicker deployment and

            06:52:49.040 --> 06:52:58.240
            integration within Azure. The next topic we'll be going over are the functions configuration

            06:52:58.240 --> 06:53:04.320
            for Azure functions. Each function comes with a specific configuration file named function.json.

            06:53:04.320 --> 06:53:09.760
            This file serves an important role outlining the trigger bindings and additional configuration

            06:53:09.760 --> 06:53:15.200
            settings for the function. The essential elements of this file include type specifies the binding

            06:53:15.200 --> 06:53:20.240
            type. Direction indicates whether the binding is for receiving data into the function or sending

            06:53:20.240 --> 06:53:25.840
            data from the function. Name represents the data binding in the function. In C# this would be an

            06:53:25.840 --> 06:53:31.680
            argument name whereas in JavaScript it would manifest as a key and a key value pair. Let's

            06:53:31.680 --> 06:53:37.040
            take a look at the host configuration for Azure functions. Every function app has a host configuration

            06:53:37.040 --> 06:53:43.600
            file named host.json. This configuration file contains global configurations options and parameters

            06:53:43.600 --> 06:53:48.720
            for all the functions within the function app. The host has a lot of configuration options. These

            06:53:48.720 --> 06:53:54.800
            include aggregator, application insights, blobs, console, cosmos db, custom handler, durable task,

            06:53:54.800 --> 06:53:59.600
            event hub, extensions, extension bundle, functions, function timeout, health monitor,

            06:53:59.600 --> 06:54:06.320
            http, logging, manage dependency, queues, retry, send grid, service bus, singleton, version, watch

            06:54:06.320 --> 06:54:11.920
            directories, and watch file settings. Essentially these configurations offer developers a framework

            06:54:11.920 --> 06:54:16.800
            to adapt functions, respond to event triggers, and ensure consistency across the function app.

            06:54:21.920 --> 06:54:25.680
            The next thing we'll be covering are the planned services in Azure functions.

            06:54:25.680 --> 06:54:30.400
            Azure functions offers three distinct planned services each tailored to different needs.

            06:54:30.400 --> 06:54:35.440
            Consumption plan cold starts. You only pay for the time your code or application is running.

            06:54:35.440 --> 06:54:39.760
            Billing is based on the number of executions, the duration of each execution, and the amount

            06:54:39.760 --> 06:54:44.400
            of memory used. Just pay while you have functions running and scale out automatically even through

            06:54:44.400 --> 06:54:50.560
            long loading times. Premium plan pre-warmed. The user has designated a set of pre-warmed cases

            06:54:50.560 --> 06:54:55.280
            which are already online and ready to react instantly. Azure provides any additional computing

            06:54:55.280 --> 06:54:59.680
            services that are required when your function is running. You pay for the constantly pre-warmed

            06:54:59.680 --> 06:55:04.480
            instances including any additional instances needed to scale the Azure app in out. Azure

            06:55:04.480 --> 06:55:08.480
            functions host instances are added and removed based on the number of incoming events.

            06:55:08.480 --> 06:55:14.400
            Dedicated plan vm sharing. When you use app service for other apps your functions will run

            06:55:14.400 --> 06:55:19.280
            on the same plan at no extra cost. You may scale it up manually by adding more vm instances for

            06:55:19.280 --> 06:55:23.920
            an app service plan. You may have auto scale enabled. Optimal when you have existing under

            06:55:23.920 --> 06:55:29.680
            utilized vms which also operate other instances of the app service. In summary when choosing an

            06:55:29.680 --> 06:55:34.480
            Azure functions plan weigh your budget, responsiveness needs, and current infrastructure for optimal

            06:55:34.480 --> 06:55:43.440
            performance and value. The next thing we'll be covering are triggers and bindings in Azure

            06:55:43.440 --> 06:55:48.640
            functions. Triggers and bindings lets you avoid hard coding access to other services and abstracting

            06:55:48.640 --> 06:55:54.160
            away boilerplate code keeping your functions lean. What is a trigger? A trigger is a specific type of

            06:55:54.160 --> 06:55:59.040
            event which causes the function to run. It defines how a function is invoked and a function must only

            06:55:59.040 --> 06:56:03.360
            have one trigger. Triggers can have associated data which is often provided as the payload of

            06:56:03.360 --> 06:56:08.800
            the function. What is a binding? Bindings define if your function is connected to another service.

            06:56:08.800 --> 06:56:13.920
            The data from bindings is provided to the function as parameters. Bindings are optional and a function

            06:56:13.920 --> 06:56:19.600
            can have multiple input and output bindings. Azure functions support a wide range of bindings

            06:56:19.600 --> 06:56:25.360
            to facilitate integration and data processing. These include storage solutions like blob storage,

            06:56:25.360 --> 06:56:30.880
            Azure Cosmos DB, and Azure SQL, dapper, event grid, and event hub cater to event driven

            06:56:30.880 --> 06:56:37.840
            architectures with IoT hub focusing on event data from hardware devices. HTTP and webhooks facilitate

            06:56:37.840 --> 06:56:43.360
            real-time data interaction while Kafka processes stream data. Mobile apps helps in mobile development

            06:56:43.360 --> 06:56:49.040
            and notification hubs are for push notifications. Hue storage, RabbitMQ, a messaging broker, and

            06:56:49.040 --> 06:56:53.840
            Service Bus ensure seamless data transfer and messaging. SendGrid optimizes email delivery.

            06:56:53.840 --> 06:56:59.760
            SignalR, an open source .NET library, provides asynchronous notifications to web apps.

            06:56:59.760 --> 06:57:05.680
            Table storage is an NOSQL key value store. Timer triggers are based on schedule rejects expressions

            06:57:05.680 --> 06:57:09.440
            and Twilio offers a cloud platform for voice and text messaging systems.

            06:57:10.640 --> 06:57:15.040
            The table provides a breakdown of various Azure functions integrations and their support across

            06:57:15.040 --> 06:57:20.880
            versions 1, X, and 2, X and higher. Both blob storage and Azure Cosmos DB are fully supported

            06:57:20.880 --> 06:57:26.960
            across all categories for both versions. Azure Data Explorer, Azure SQL, dapper, Kafka, and SignalR

            06:57:26.960 --> 06:57:32.560
            are supported from version 2, X onwards. Some integrations such as mobile apps, notification

            06:57:32.560 --> 06:57:37.680
            hubs, and SendGrid have limited support across the versions specifically with triggers, inputs,

            06:57:37.680 --> 06:57:44.720
            or outputs. Others like EventGrid, EventHubs, HTTP and Webhooks, IoT Hub, QStorage, Service Bus,

            06:57:44.720 --> 06:57:49.760
            and Table Storage have broad support but may lack in one or two categories. Overall,

            06:57:49.760 --> 06:57:54.560
            Azure functions offer serverless computation and seamless service integration. Using triggers and

            06:57:54.560 --> 06:57:58.880
            bindings, they eliminate redundant code. The platform supports diverse bindings,

            06:57:58.880 --> 06:58:00.480
            but some integrations have limits.

            06:58:05.360 --> 06:58:09.120
            The next topic we'll be covering into is the binding direction in Azure functions.

            06:58:09.120 --> 06:58:15.200
            All triggers and bindings have a direction property in the function.json file. The direction

            06:58:15.200 --> 06:58:20.880
            of triggers is always in. Input and output bindings use in, out, or both. Some bindings

            06:58:20.880 --> 06:58:26.400
            support a special direction in out. The trigger is defined alongside the input and output bindings.

            06:58:26.400 --> 06:58:30.800
            Trigger will have the same as the input type but with trigger appended. For example, an input

            06:58:30.800 --> 06:58:35.200
            binding named blob would have a trigger named blob trigger. If you use an out, only the advanced

            06:58:35.200 --> 06:58:40.160
            editor is available via the integrate tab in the portal. If you use an out, only the advanced

            06:58:40.160 --> 06:58:46.080
            editor is available via the integrate tab in the portal. In scenarios requiring periodic data

            06:58:46.080 --> 06:58:50.640
            processing, Azure functions offers tailored solutions. Suppose every hour you want to read

            06:58:50.640 --> 06:58:55.200
            new log files delivered by your application and you need to transform the data to be ingested in

            06:58:55.200 --> 06:59:00.800
            your NoSQL database that resides in Cosmos DB. You'll use the trigger type timer because it's a

            06:59:00.800 --> 06:59:05.760
            scheduled job that will run at a specific time. The blob storage would be in binding as the

            06:59:05.760 --> 06:59:10.320
            function reads the data from it. The Cosmos DB would be in out binding, enabling the function

            06:59:10.320 --> 06:59:15.280
            to write the processed data into the database. In essence, by understanding and effectively

            06:59:15.280 --> 06:59:20.000
            leveraging these binding directions, developers can architect efficient, event-driven solutions

            06:59:20.000 --> 06:59:30.160
            that seamlessly integrate various Azure services. Hey, this is Andrew Brown from exam Pro. And in

            06:59:30.160 --> 06:59:34.800
            this section, we'll be covering Azure Front Door. Azure Front Door is a traffic manager,

            06:59:34.800 --> 06:59:39.280
            traffic accelerator, global load balancer and content distribution network.

            06:59:39.280 --> 06:59:43.760
            Azure Front Door is a modern application delivery network platform providing a secure,

            06:59:43.760 --> 06:59:49.440
            scalable CDN, dynamic site acceleration and global HTTP load balancing for your global

            06:59:49.440 --> 06:59:56.080
            web applications. Azure Front Door features caching similar to traditional CDNs. Azure Front

            06:59:56.080 --> 07:00:01.840
            Door offers caching with specified rules and expiration policies. Resiliency by distributing

            07:00:01.840 --> 07:00:06.800
            incoming traffic across multiple or different Azure regions. Cookie-based session affinity

            07:00:06.800 --> 07:00:10.960
            for restful applications when traffic needs to be redirected back to the same back end.

            07:00:10.960 --> 07:00:15.360
            Health probe to determine the healthiest and closest back end to the client request.

            07:00:15.920 --> 07:00:20.720
            Web application firewall, a crucial security measure protecting your back ends from malicious

            07:00:20.720 --> 07:00:28.320
            attacks and vulnerabilities. URL redirect, redirecting traffic based on protocol HTTP or HTTPS

            07:00:28.320 --> 07:00:34.240
            hostname, path and query string. URL rewrite with a powerful engine for rewriting income requests

            07:00:34.240 --> 07:00:39.760
            to a different back end request. And Azure Front Door is made up of front ends domains.

            07:00:39.760 --> 07:00:44.320
            These front ends domains are connected to back end pools where those connections are filtered

            07:00:44.320 --> 07:00:51.200
            by routing rules. Azure Front Door core components. Profile, containers all front door components.

            07:00:51.200 --> 07:00:55.360
            Endpoint, acts as the pathway or bridge connecting the front end to the back end.

            07:00:55.360 --> 07:01:00.320
            Origin groups, a grouping of origins. Origin, defining the road to back end.

            07:01:00.320 --> 07:01:07.120
            Rule sets, a grouping of rules. Rules, routing rules. Overall, Azure Front Door optimizes web

            07:01:07.120 --> 07:01:12.480
            application delivery within the Azure ecosystem. By utilizing its features, businesses can enhance

            07:01:12.480 --> 07:01:22.000
            web traffic management efficiency. The next topic we'll be covering are the tiers for Azure Front

            07:01:22.000 --> 07:01:27.360
            Door. Azure Front Door offers two distinct tiers tailored for different needs. First, we have

            07:01:27.360 --> 07:01:33.440
            standard. This auction optimizes content delivery offers both static and dynamic content acceleration

            07:01:33.440 --> 07:01:38.720
            offering global load balancing SSL offload domain and certificate management, enhanced traffic

            07:01:38.720 --> 07:01:44.960
            analytics and basic security capabilities. And we have premium. This option includes all the features

            07:01:44.960 --> 07:01:50.480
            of the standard tier Azure Front Doors premium tier offers extensive security capabilities with WAF

            07:01:50.480 --> 07:01:54.880
            thought protection, private link support and integration with Microsoft Threat Intelligence

            07:01:54.880 --> 07:02:00.480
            and security analytics. In conclusion, Azure Front Door provides standard for content delivery and

            07:02:00.480 --> 07:02:04.560
            premium with added security ensuring global application performance and protection.

            07:02:04.960 --> 07:02:10.320
            The next topic we'll be going over is routing in Azure Front Door. Routing in Azure Front Door

            07:02:10.320 --> 07:02:15.440
            determines the path and HTTP requests from a user takes to reach a configured back end service.

            07:02:15.440 --> 07:02:20.800
            Here's how it works. An HTTP request from a user is directed to the nearest edge location.

            07:02:20.800 --> 07:02:26.000
            It then matches with an Azure Front Door profile and evaluates any web application firewall rules.

            07:02:26.000 --> 07:02:30.560
            Following this, it matches with an Azure Front Door route evaluates engine rules and either

            07:02:30.560 --> 07:02:35.360
            returns cache content or selects the appropriate origin group. Finally, the request is directed to

            07:02:35.360 --> 07:02:40.480
            the selected origin, which then sends it to the corresponding back end. Azure Front Door offers

            07:02:40.480 --> 07:02:45.520
            four distinct traffic routing methods. latency routes requests to the back ends with the lowest

            07:02:45.520 --> 07:02:51.280
            latency within a specified sensitivity range. priority directs requests based on a user defined

            07:02:51.280 --> 07:02:56.240
            priority number weighted distributes requests to back ends proportionally based on assignment

            07:02:56.240 --> 07:03:01.200
            weight coefficients. Session affinity ensures requests from the same end user are directed to

            07:03:01.200 --> 07:03:07.200
            the same back end ideal for stateful back ends. In summary, Azure Front Door enhances user experience

            07:03:07.200 --> 07:03:10.000
            and back end performance through its efficient routing capabilities.

            07:03:10.000 --> 07:03:18.800
            The next topic we'll be covering is origin and origin groups in Azure Front Door.

            07:03:18.800 --> 07:03:22.320
            The origin is what Azure Front Door will point it to the end user.

            07:03:22.320 --> 07:03:24.560
            Origin is the endpoint that points to your back end.

            07:03:24.560 --> 07:03:29.680
            Azure Front Door provides robust support for a variety of origins to seamlessly integrate

            07:03:29.680 --> 07:03:34.480
            with its application delivery network. Among the supported origins are Azure Blob Storage,

            07:03:34.480 --> 07:03:38.800
            which offers vast storage capabilities and Azure Storage with static website hosting,

            07:03:38.800 --> 07:03:43.920
            catering to web hosting needs. Additionally, Azure supports cloud services, app services,

            07:03:43.920 --> 07:03:48.800
            and static web apps for diverse application deployments. For comprehensive web app storage,

            07:03:48.800 --> 07:03:53.600
            and static web apps for diverse application deployments. For comprehensive API management,

            07:03:53.600 --> 07:03:58.800
            Azure Front Door integrates with API management. Furthermore, application gateway, public IP

            07:03:58.800 --> 07:04:03.520
            address, Azure Traffic Manager, Azure Spring Cloud, and Azure Container instances are also

            07:04:03.520 --> 07:04:08.640
            supported. Notably, there's flexibility for users as they can also add custom origins by providing

            07:04:08.640 --> 07:04:14.160
            a host name. Priority in Azure Front Door determines who is the primary recipient of traffic

            07:04:14.160 --> 07:04:19.360
            or who to send traffic to first. You select a value ranging from one to five. A lower value

            07:04:19.360 --> 07:04:24.400
            signifies a higher priority and multiple back ends can share this number. Weights allow you to

            07:04:24.400 --> 07:04:29.360
            determine the split of traffic distribution between origins of the same priority, a number between one

            07:04:29.360 --> 07:04:36.160
            to 1000. The default value is 50. Origin groups in Azure Front Door are collections of origins.

            07:04:36.160 --> 07:04:41.520
            Every origin must be part of an origin group. By default, Azure Front Door profiles contain

            07:04:41.520 --> 07:04:46.640
            an origin group named default origin group. Origin groups facilitate the application of health

            07:04:46.640 --> 07:04:51.280
            probes to assess the condition of your origins and load balancing settings to manage the distribution

            07:04:51.280 --> 07:04:56.400
            among them. To direct inbound traffic to a particular origin group, an employee must link

            07:04:56.400 --> 07:05:02.160
            to the origin group through a designated route. Overall, Azure Front Door optimizes web traffic

            07:05:02.160 --> 07:05:07.360
            management with diverse origins, prioritization, and weight mechanisms. Using origin groups,

            07:05:07.360 --> 07:05:11.200
            it leverages health probes and load balancing for efficient application delivery.

            07:05:11.200 --> 07:05:19.920
            The next topic we'll be covering are health checks in Azure Front Door.

            07:05:19.920 --> 07:05:24.880
            Azure Front Door uses origin group health probes to periodically ping a back end, verifying whether

            07:05:24.880 --> 07:05:30.560
            it returns a healthy response. Typically, a healthy response is determined by status 200.

            07:05:30.560 --> 07:05:35.200
            If a back end fails to produce a healthy response, Azure Front Door will redirect the traffic to

            07:05:35.200 --> 07:05:39.280
            other available and healthy back ends, assuming other origins are configured.

            07:05:39.280 --> 07:05:46.000
            What is a HTTP response code? When a user sends an HTTP request, a HTTP response is returned.

            07:05:46.000 --> 07:05:51.120
            An HTTP response will have a response code to communicate how a back end server interpreted

            07:05:51.120 --> 07:05:56.480
            the request. A response code is a number that coordinates to what happened. For example,

            07:05:56.480 --> 07:06:03.360
            200 signifies OK, 403 means forbidden, 404 indicates not found, 500 represents internal

            07:06:03.360 --> 07:06:09.680
            server error. Azure Front Door load balancing settings. Origin group load balancing settings

            07:06:09.680 --> 07:06:14.080
            in Azure Front Door enable you to specify the criteria determining the health of a back end.

            07:06:14.080 --> 07:06:18.560
            Essentially, these settings define which sample set should be used to classify a back end as either

            07:06:18.560 --> 07:06:24.480
            healthy or unhealthy. When the latency sensitivity is set to zero, Azure Front Door prioritizes and

            07:06:24.480 --> 07:06:29.200
            routes traffic to the quickest available back end. If it's set to any other value, the system

            07:06:29.200 --> 07:06:34.240
            adopts a round-robin approach, distributing traffic between the fastest back end and subsequent ones,

            07:06:34.240 --> 07:06:37.200
            all within the bounds of the pre-configured latency sensitivity.

            07:06:37.200 --> 07:06:46.880
            The next topic we'll be covering are routes in Azure Front Door. Routes in Azure Front Door

            07:06:46.880 --> 07:06:51.600
            serve as mapping tools, linking your domains and corresponding URL path patterns to specific

            07:06:51.600 --> 07:06:57.040
            origin groups. Routes have caching and compression features applied. Rules from rule sets can be

            07:06:57.040 --> 07:07:02.880
            associated to routes to apply intelligent routing. One of the standout features of Azure Front Door

            07:07:02.880 --> 07:07:07.920
            is its capability for traffic acceleration. This feature ensures faster global delivery of your

            07:07:07.920 --> 07:07:13.120
            application without necessitating any changes to your existing application code. Azure achieves

            07:07:13.120 --> 07:07:17.600
            this traffic acceleration by directing traffic to the nearest edge location to on-ramp into the

            07:07:17.600 --> 07:07:22.800
            Azure network. Traffic that is following within the internal Azure network travels at accelerated

            07:07:22.800 --> 07:07:27.680
            speed while also taking the most direct path. Think of it as an expressway. In essence,

            07:07:27.680 --> 07:07:31.520
            Azure Front Door routes linked domains to origin groups, incorporating caching,

            07:07:31.520 --> 07:07:40.960
            compression, and intelligent routing. The next topic we'll be covering are rule sets in Azure

            07:07:40.960 --> 07:07:46.640
            Front Door. Azure Front Door rules engine allows you to customize how HTTP requests gets handled

            07:07:46.640 --> 07:07:51.440
            at the edge and provides a more controlled behavior to your web application. This interface

            07:07:51.440 --> 07:07:56.560
            is a configuration screen for defining rules in Azure Front Door, a content delivery and application

            07:07:56.560 --> 07:08:01.680
            acceleration service. Let's break down what's presented. Rule name by rule. This is the name

            07:08:01.680 --> 07:08:06.560
            assigned to the current rule condition. If represents the conditions under which the rules

            07:08:06.560 --> 07:08:12.000
            action should be executed. Request header, the rule is triggered based on an HTTP header present

            07:08:12.000 --> 07:08:16.640
            in the incoming request. Header name by header, the rule looks for this specific header in the

            07:08:16.640 --> 07:08:22.320
            incoming request. Operator equals specifies the comparison type. Here it checks if the header's

            07:08:22.320 --> 07:08:27.520
            value exactly matches the defined value. Header value, my value the value that my header should

            07:08:27.520 --> 07:08:32.560
            have to meet the condition. String transform to lowercase before checking the value, it will

            07:08:32.560 --> 07:08:38.400
            convert the header's value to lowercase. Action then represents the action to be taken if the

            07:08:38.400 --> 07:08:44.960
            condition is met. URL redirect, the action taken will be a URL redirect. Redirect type found

            07:08:44.960 --> 07:08:52.160
            specifies the type of HTTP redirect. 302 means a temporary redirect. Redirect protocol match request

            07:08:52.160 --> 07:08:57.680
            a protocol of the redirected URL will match that of the original request. Destination host not

            07:08:57.680 --> 07:09:02.560
            specified in the image, which means it will redirect to the same host or domain. Destination

            07:09:02.560 --> 07:09:06.640
            path go here this is the path to which the user will be redirected if the condition is met.

            07:09:06.640 --> 07:09:14.080
            Some of the available conditions include device type HTTP version and request cookies. It also

            07:09:14.080 --> 07:09:19.120
            examines post args the query string and the remote address of the requester details like the request

            07:09:19.120 --> 07:09:24.400
            body request file name request file extension and request header is scrutinized. Furthermore,

            07:09:24.400 --> 07:09:29.760
            the request method request path request protocol and request URL are taken into account during

            07:09:29.760 --> 07:09:35.600
            processing. Azure Front Door utilizes rule sets to manage its operations offering a range of

            07:09:35.600 --> 07:09:40.640
            operators for precise control. These operators include equal contains less than greater than

            07:09:40.640 --> 07:09:45.680
            less than or equal greater than or equal begins with ends with and regex. Additionally, each of

            07:09:45.680 --> 07:09:50.480
            these operators has a corresponding not variant providing enhanced flexibility and specificity

            07:09:50.480 --> 07:09:57.280
            in defining rule conditions. Action, cache expiration, cache behavior, bypass override

            07:09:57.280 --> 07:10:03.760
            set of missing cache key query string behavior include cache every unique URL exclude ignore

            07:10:03.760 --> 07:10:10.080
            query string, modify request header modify response header operator append overwrite delete.

            07:10:10.880 --> 07:10:16.240
            URL redirected redirect type found moved temporary redirect permanent redirect

            07:10:16.240 --> 07:10:24.000
            redirect protocol match request HTTP HTTPS URL rewrite source pattern and destination

            07:10:24.000 --> 07:10:29.600
            and origin group override. So that's an overview of rule sets for Azure Front Door.

            07:10:29.600 --> 07:10:39.600
            Hey, this is Andrew Brown. And this fall long, we're going to be utilizing Azure Front Door.

            07:10:39.600 --> 07:10:43.280
            So before we do that, we're going to need ourselves a storage account to set up some

            07:10:43.280 --> 07:10:49.040
            static website storage. So what I want you to do is go to storage accounts. And there is a static

            07:10:49.040 --> 07:10:53.840
            web app host hosting that we could use, but we're going to do the old school way, because it's

            07:10:53.840 --> 07:10:58.560
            always great to learn a few different ways to do things in Azure. And so there's probably another

            07:10:58.560 --> 07:11:03.920
            fall along where we use this static static site thing there. So what we're going to do is create

            07:11:03.920 --> 07:11:13.040
            a new, we're going to create a new resource group, I'm going to call this one, my Azure Front Door.

            07:11:13.040 --> 07:11:18.000
            And we'll say, Okay, and from here, we'll have to name it something. So we'll just say

            07:11:18.000 --> 07:11:25.600
            my Azure Front Door, or sorry, we'll do static storage, storage 8888. If you can't get the

            07:11:25.600 --> 07:11:30.720
            four eights, because I'm using it, then just give it a different number sequence, because these are

            07:11:30.720 --> 07:11:36.480
            treated like fully qualified domains, choose like a US region, so that we're all doing the same thing.

            07:11:36.480 --> 07:11:40.320
            For performance, we're going to stick with standard, it doesn't matter if it's on geo redundant,

            07:11:40.320 --> 07:11:44.240
            we're not doing anything fancy there. So what I want you to do is go ahead and hit Review,

            07:11:44.240 --> 07:11:49.280
            and Create, and then give it a moment and hit Create. And we're going to wait for that to

            07:11:49.280 --> 07:11:54.320
            finish deployment. And from there, we'll then have to enable static website. So it doesn't take

            07:11:54.960 --> 07:12:02.400
            too long to deploy. So we'll just give it a moment. And while that's going, we do need to

            07:12:02.400 --> 07:12:08.560
            create ourselves a index HTML file. So you're going to need some kind of editor. So I'm just

            07:12:08.560 --> 07:12:18.800
            opening up Visual Studio code on my computer. Give it a moment there. And I'm just creating a new

            07:12:18.800 --> 07:12:24.720
            file here. This is taking it taking a moment to load. Okay, so and what we need to do is just

            07:12:24.720 --> 07:12:29.200
            create an index HTML file. These are really basic, you can find them anywhere online. But this one's

            07:12:29.200 --> 07:12:34.000
            going to say hello, Mars, hello, Mars. Very, very simple. So I'm going to go ahead and save this to

            07:12:34.000 --> 07:12:42.160
            my desktop. So save as and show local, maybe there we go. That's a little bit more sane. And we'll

            07:12:42.160 --> 07:12:51.360
            just say index dot HTML. And we will now go to the resource. And we're going to go to website static

            07:12:51.360 --> 07:12:56.320
            is a blade on left hand side. So we can do a sack website stuff, we're gonna say index HTML,

            07:12:56.320 --> 07:12:59.760
            I think we have to set that for it to work. I cannot remember if that's the case, we have a

            07:12:59.760 --> 07:13:04.640
            primary endpoint, this is these matter for later, but we'll come back to that. And we're going to

            07:13:04.640 --> 07:13:09.200
            go over to our containers, and we're going to have to create a new container. So I'm just going to

            07:13:09.200 --> 07:13:12.800
            call that actually, we don't because we're going to put it in web. So when we turned on static

            07:13:12.800 --> 07:13:19.120
            website hosting, it already gave us a blob or container, a container for us to add our add our

            07:13:19.120 --> 07:13:23.200
            upload our files there. So we'll go to upload here. And then I'm going to go ahead and select

            07:13:23.200 --> 07:13:29.920
            that index HTML file and upload it in place. We need to change our access level for this,

            07:13:30.960 --> 07:13:39.200
            this container to I think, just blob. So I'm just double checking here.

            07:13:39.200 --> 07:13:46.000
            Yeah, I think it's blob access can only be anonymous request container data is not available.

            07:13:46.000 --> 07:13:48.000
            So we'll say, Okay, I believe that is correct.

            07:13:48.000 --> 07:13:56.080
            Okay, sometimes you can like we're clicked into it. But I think like in my instructions,

            07:13:56.080 --> 07:13:59.520
            I do it a little bit different. So I'm just going to double check to see what the settings are there,

            07:13:59.520 --> 07:14:02.880
            just so you can see it if you're following my instructions. So change access.

            07:14:02.880 --> 07:14:10.320
            Private blob. Yeah, okay, so that's fine. So blob access should be okay. And so now what we want to

            07:14:10.320 --> 07:14:14.240
            do is just test that our page is working. So if we go back to static website here,

            07:14:14.240 --> 07:14:19.440
            on the left hand side, we can grab this primary endpoint, and we should be able to post it

            07:14:19.440 --> 07:14:23.920
            anywhere here. So you have the old tutorial here, this is a moment ago. So that's why it's a bit

            07:14:23.920 --> 07:14:28.960
            confusing. But so hello, Mars is working, but this is on static storage, this isn't in front of or

            07:14:28.960 --> 07:14:35.600
            behind Azure front door, which is what we'll want to do next. So what I want you to do is just close

            07:14:35.600 --> 07:14:40.800
            a couple of these tabs out, we're going to type in Azure front door, or front door should be enough

            07:14:40.800 --> 07:14:46.640
            front. There we go. And we have a whole bunch of options. We'll just hit Create. That's a front

            07:14:46.640 --> 07:14:51.440
            door we actually do use for the platform. We have Azure front door, we have quick create, I always

            07:14:51.440 --> 07:14:56.480
            go custom. I don't think I've ever done quick create, I just, I just have more trust and custom.

            07:14:56.480 --> 07:15:06.320
            And from here, we will choose front door. And East us is fine. Just wondering where our storage

            07:15:06.320 --> 07:15:10.960
            account is. That's why we should always just kind of set them to be the same place. So storage

            07:15:10.960 --> 07:15:16.720
            account. I don't think it will matter. But I'm just going to double check storage account.

            07:15:21.600 --> 07:15:24.640
            And this one is in East us, so we're going to be okay.

            07:15:24.640 --> 07:15:32.400
            Let's make sure they match just so we have less problems. And I'm going to call this one my Azure

            07:15:32.400 --> 07:15:38.240
            front door. Now there are more functionalities in the premium, but standard is fine for us.

            07:15:38.240 --> 07:15:46.880
            We'll go next to secrets. This is if we want to add a certificate, like you could bring your

            07:15:46.880 --> 07:15:52.160
            own certificate. But we're not too worried about that we're gonna have to add a new endpoint,

            07:15:52.160 --> 07:15:57.360
            we're gonna just say my endpoint here. There's a lot of small steps in here. So this should be fun.

            07:15:57.360 --> 07:16:01.120
            Hopefully we don't configure anything wrong here. And then we need to add a route,

            07:16:01.120 --> 07:16:07.600
            say my route. And it's going to use the default domain, that's totally fine.

            07:16:07.600 --> 07:16:11.600
            We don't have to do anything, it's going to just be on the forward slash asterisk there,

            07:16:11.600 --> 07:16:16.400
            we do need to create an origin group. So we'll go here and create a new origin group. So my

            07:16:16.400 --> 07:16:22.320
            origin group. And then from there, we need to add an origin. Yes, it is very squirrelly going through

            07:16:22.320 --> 07:16:29.360
            all this, my origin, the origin type is going to be Azure, or sorry, storage, static website.

            07:16:29.360 --> 07:16:34.720
            And from here, we need to choose the right one, we call it static storage. This is fine, this is all

            07:16:34.720 --> 07:16:40.000
            fine, we'll go ahead and hit add. And down below, we have some load balancing, we don't care about

            07:16:40.000 --> 07:16:46.000
            any of that. So you can see status is enabled. All this should be okay, the protocol here for

            07:16:46.000 --> 07:16:51.680
            the health probe should be HTTP. Actually, let me double check because remember, this is where I ran

            07:16:51.680 --> 07:17:00.240
            into some trouble. I believe Yeah, HTTP, I think it's HTTPS. Okay, I think I read somewhere that's

            07:17:00.240 --> 07:17:04.880
            like, static storage doesn't use HTTP. But clearly it does. Because when we went to the link earlier,

            07:17:04.880 --> 07:17:09.200
            it was HTTPS. So I might have the screenshots wrong, but I've corrected them in the actual

            07:17:09.200 --> 07:17:15.360
            instructions on my site. We'll go ahead and save that I think it's HTTPS. And then the protocol

            07:17:15.360 --> 07:17:21.040
            here, we'll just leave it matching, it's totally fine. origin path is fine, we'll go ahead and add

            07:17:21.040 --> 07:17:26.000
            that there. And we'll go review create. We'll give it a moment and we'll create.

            07:17:26.000 --> 07:17:42.160
            Alright, so after waiting about a few minutes, like two, three minutes, it looks like Azure

            07:17:42.160 --> 07:17:45.920
            front door setup. So we'll go to the resource. And I'm just hoping this works. Sometimes you

            07:17:45.920 --> 07:17:49.360
            have to play around with the settings. But if you see the endpoint hostname, we'll go ahead and grab

            07:17:49.360 --> 07:17:56.080
            that there, paste it on in, we get a 404. So something's not working just right. So we'll

            07:17:56.080 --> 07:17:59.600
            have to go do some debugging, which I was hoping we didn't have to do. So we go the front door

            07:17:59.600 --> 07:18:04.560
            manager. This is the same setup we have here before there are like different ways to get to it.

            07:18:04.560 --> 07:18:10.400
            But we'll have to just kind of go through and debug it. So we do have my route, my origin group.

            07:18:10.400 --> 07:18:15.360
            So we can click into our origin group. And then from here, we'll expand it, we have our route.

            07:18:15.360 --> 07:18:21.120
            So there's something that is not correct. And that's what we have to figure out.

            07:18:21.120 --> 07:18:25.520
            So I'm just going to double check my instructions, because this was a bit

            07:18:25.520 --> 07:18:33.840
            tricky to figure out. And it really came down to like these protocols here. So

            07:18:37.760 --> 07:18:41.600
            let me keep checking. And I mean, I think the probe is working correctly. So if we go in the origin,

            07:18:41.600 --> 07:18:44.960
            if this wasn't working correctly, then it wouldn't it wouldn't show green.

            07:18:44.960 --> 07:18:51.200
            Go back up a step here. You know, maybe we should just wait a little bit because sometimes it takes

            07:18:51.200 --> 07:18:56.240
            time to propagate. And I don't I don't 100% trust that it's not working, because I feel

            07:18:56.240 --> 07:18:59.520
            like we configured it exactly right. So I'll open up a new tab here.

            07:19:04.160 --> 07:19:13.600
            Says 404 still my origin group.

            07:19:13.600 --> 07:19:19.600
            That's fine.

            07:19:19.600 --> 07:19:29.520
            We'll go here. Yeah, so what I'm going to do is go back to our storage account,

            07:19:29.520 --> 07:19:36.640
            I just want to double check what that string was. For the static website, I'm pretty sure it was HTTPS.

            07:19:36.640 --> 07:19:41.600
            It is HTTPS. So there's no reason that should not work.

            07:19:41.600 --> 07:19:56.320
            This is what I was trying to spare you the the debugging of this. And it's very common. It's not

            07:19:56.320 --> 07:20:01.680
            just Azure, anything that has a CDN, sometimes it's it's difficult to figure that stuff out. We'll go

            07:20:01.680 --> 07:20:07.600
            ahead and add that route. And we'll just carefully look at what we have here. So parents match that

            07:20:07.600 --> 07:20:15.840
            is fine. It's the correct endpoint. Both protocols are accepted. That's totally fine. redirect HTTPS

            07:20:15.840 --> 07:20:26.400
            that's totally fine. match that doesn't matter. So it should just work. The thing we didn't do

            07:20:26.400 --> 07:20:31.760
            was enable caching, which I think wouldn't hurt to do. Because it is a CDN, we don't take advantage

            07:20:31.760 --> 07:20:36.080
            of it if we don't turn it on. So we'll do that and say ignore that query string. I mean, that's

            07:20:36.080 --> 07:20:40.880
            not going to fix this problem if the routing is messed up. Again, I'm just hoping that maybe

            07:20:40.880 --> 07:20:53.920
            it just has to do with propagation. Go back to the overview here. And we will open this again.

            07:20:53.920 --> 07:21:04.800
            Whoops. Grab this. Just make sure it's doing HPS. We're working to restore all services as

            07:21:04.800 --> 07:21:08.160
            possible right now. What do you mean our services aren't available right now? Let's go look at

            07:21:08.160 --> 07:21:16.720
            Azure status page here. And we'll take a look at front door.

            07:21:16.720 --> 07:21:23.520
            As your front door, it's saying that it's fine.

            07:21:23.520 --> 07:21:33.520
            us East. There's no green beside it. Good. We go down here, I guess it's a it's a non regional

            07:21:33.520 --> 07:21:38.080
            service. So if it's green, it's green. So you know, I'm going to play around with this for a

            07:21:38.080 --> 07:21:42.640
            little 404 web. So this is better. Right? It's just saying it can't find the content.

            07:21:42.640 --> 07:21:48.000
            Well, I mean, I guess that makes sense, because that was there. So let's clear that out. Oh,

            07:21:48.000 --> 07:21:52.880
            now it's loading. So I think it what the issue is, there was no issue, it's just propagating to

            07:21:52.880 --> 07:21:57.760
            all the servers, and it took some time. So I think that's what really threw me for a loop

            07:21:57.760 --> 07:22:02.160
            when I was originally doing it. So just give it some patience. And it will work eventually. So we

            07:22:02.160 --> 07:22:12.560
            are all done here. So we can go ahead and clean this up. And I'm just looking for the resource

            07:22:12.560 --> 07:22:16.960
            group here, we'll go ahead and delete it. And there you go. That's Azure front door.

            07:22:16.960 --> 07:22:20.800
            And I'll see you in the next one. Okay.

            07:22:28.000 --> 07:22:32.560
            Hey, this is Andrew Brown from exam Pro. And in this section, we'll be covering Azure CDN.

            07:22:32.560 --> 07:22:37.920
            Azure Content Delivery Network is an Azure service that provides your applications with a distributed

            07:22:37.920 --> 07:22:43.520
            network of servers. With Azure CDN, you can improve your applications load time, save bandwidth with

            07:22:43.520 --> 07:22:49.120
            caching strategies and speed up responsiveness with compressed files. Azure CDN centralizes

            07:22:49.120 --> 07:22:53.600
            requests from your origin into a single location, making it easier to manage your inbound and

            07:22:53.600 --> 07:22:58.480
            outbound traffic with features such as caching strategies, these outline which requests are

            07:22:58.480 --> 07:23:04.400
            cached and specify their expiration timelines. file compression by minimizing static file sizes,

            07:23:04.400 --> 07:23:09.760
            Azure CDN ensures bandwidth efficiency during requests. geo filtering this allows or denies

            07:23:09.760 --> 07:23:15.360
            requests based on geographical regions, global distribution, Azure regions span across the globe,

            07:23:15.360 --> 07:23:20.960
            ensuring widespread reach integration, Azure CDN seamlessly integrates with other Azure services,

            07:23:21.520 --> 07:23:27.520
            robust security, advanced security measures are in place without any extra cost, scalability and load

            07:23:27.520 --> 07:23:32.480
            balancing Azure CDN makes application scalability straightforward thanks to its built in load

            07:23:32.480 --> 07:23:39.360
            balancing. Azure CDN can help you reduce load times, save bandwidth and improve responsiveness.

            07:23:39.360 --> 07:23:45.760
            It's used to cache static content such as images, CSS or HTML. Azure CDN is ideal when you're

            07:23:45.760 --> 07:23:50.800
            developing or managing websites or mobile apps encoding and distributing streaming media gaming

            07:23:50.800 --> 07:23:56.800
            software firmware updates at IoT and points. In essence, Azure CDN provides a robust framework

            07:23:56.800 --> 07:24:06.080
            to enhance the delivery and performance of your digital assets. The next topic we'll delve into

            07:24:06.080 --> 07:24:11.840
            are the different tiers available for Azure CDN. Azure CDN is available in the following tiers,

            07:24:11.840 --> 07:24:19.360
            Microsoft CDN, standard Verizon, standard Akamai, premium Verizon. Akamai is one of the world's

            07:24:19.360 --> 07:24:24.480
            largest CDN provider with a large distributed network of servers around the world. On the other

            07:24:24.480 --> 07:24:30.080
            hand, Verizon Media operates a global CDN platform with a focus on media streaming, delivery and

            07:24:30.080 --> 07:24:35.600
            security. The CDN features greatly vary based on the chosen option and it requires exploring a large

            07:24:35.600 --> 07:24:40.880
            feature table comparison. Keep in mind that Azure CDN from Akamai is scheduled to be retired on

            07:24:40.880 --> 07:24:52.400
            October 31, 2023. So that's a quick overview of Azure CDN tiers. Next, we'll explore the purge

            07:24:52.400 --> 07:24:57.760
            feature in Azure CDN. The purge function in Azure CDN serves as an essential tool when you want to

            07:24:57.760 --> 07:25:02.720
            refresh cache content. It enables the removal of cache content from all edge points of presence,

            07:25:02.720 --> 07:25:06.480
            ensuring that the latest assets are fetched directly from the origin when requested.

            07:25:07.120 --> 07:25:12.320
            When you're looking to purge specific files within a directory, wildcards represented by an asterisk

            07:25:12.320 --> 07:25:17.200
            can be employed. For example, to clear all files in a directory, you'd utilize this wildcard

            07:25:17.200 --> 07:25:22.320
            feature. However, note that the capabilities like purge all and wildcard purge aren't available for

            07:25:22.320 --> 07:25:28.160
            Azure CDN when sourced from Akamai. Overall, the purge feature in Azure CDN provides administrators

            07:25:28.160 --> 07:25:32.560
            with granular control over the content caching, ensuring that users always have access to the

            07:25:32.560 --> 07:25:42.400
            most updated assets. Hey, this is Andrew Brown from exam Pro. And in this section, we're diving

            07:25:42.400 --> 07:25:47.520
            into Azure Service Bus. Service Bus is a fully managed enterprise message broker that allows

            07:25:47.520 --> 07:25:52.640
            you to publish or subscribe to topics and queue messages. It can scale your applications with

            07:25:52.640 --> 07:25:57.840
            asynchronous messages and built in integration with Azure services. Azure Service Bus allows

            07:25:57.840 --> 07:26:02.960
            for single or batch messaging message load balancing topic subscriptions, message sessions

            07:26:02.960 --> 07:26:08.560
            and transactions ensuring compliance with industry standards. This includes protocols such as AMQP

            07:26:08.560 --> 07:26:17.280
            1.0 with JMS 2.0 available for premium SKU and JMS 1.1 for standard SKU. Service Bus key concepts.

            07:26:17.280 --> 07:26:22.800
            The namespace works like a server with NQs and topics. Queue contains the messages.

            07:26:23.440 --> 07:26:28.880
            Sender is who sends the message. Receiver is who receives the message. Topic is a queue with

            07:26:28.880 --> 07:26:34.480
            multiple receivers that works like a queue. Subscription is a receiver in a topic. A batch

            07:26:34.480 --> 07:26:40.080
            is a group of messages. Safe batch validates if each message can be included the batch. Session

            07:26:40.080 --> 07:26:44.800
            allows you to use FIFO and group your messages in a queue. Keek returns a message to the queue

            07:26:44.800 --> 07:26:49.360
            without removing it. Dead letter queue, a queue for messages that were unable to be delivered

            07:26:49.360 --> 07:26:53.760
            through the normal queue. Keek and lock retrieves a message from the queue without removing it and

            07:26:53.760 --> 07:26:58.640
            locks it so other receivers cannot receive it. Receive and delete retrieves and delete a message

            07:26:58.640 --> 07:27:03.440
            from the queue. Auto delete on idle sets a time span to delete the queue if it is not used.

            07:27:03.440 --> 07:27:08.640
            Duplicate detection history checks if the message was not sent earlier before sending a message it.

            07:27:08.640 --> 07:27:13.920
            Overall, this gives you a comprehensive overview of Azure Service Bus and its various components

            07:27:13.920 --> 07:27:23.920
            and features. The next topic we'll be covering is a namespace in Azure Service Bus. An Azure

            07:27:23.920 --> 07:27:28.560
            Service Bus namespace serves as a container for all messaging components, including both queues

            07:27:28.560 --> 07:27:34.240
            and topics. Container for messaging components, one namespace can house multiple queues and topics,

            07:27:34.240 --> 07:27:38.480
            making them versatile structures within the Azure Service Bus. They're commonly used as

            07:27:38.480 --> 07:27:43.840
            application containers. Capacity slice, think of a service bus namespace as a segment of a large

            07:27:43.840 --> 07:27:48.560
            scale cluster. This cluster comprises numerous all active virtual machines that fall under your

            07:27:48.560 --> 07:27:54.320
            control. Azure availability zones, a namespace can potentially span up to three Azure availability

            07:27:54.320 --> 07:27:59.680
            zones offering enhanced availability and resilience. Benefits at scale using Azure Service

            07:27:59.680 --> 07:28:04.800
            Bus means you're using a messaging system built for large scale operations offering high reliability

            07:28:04.800 --> 07:28:10.160
            and strength. Serverless messaging with Azure Service Bus, it is serverless messaging. This

            07:28:10.160 --> 07:28:14.240
            means you get to use the messaging service without getting bogged down by the intricacies of the

            07:28:14.240 --> 07:28:19.120
            underlying infrastructure. So that's a quick overview of a namespace in Azure Service Bus.

            07:28:19.120 --> 07:28:29.920
            Next, let's talk about queues in Azure Service Bus. Queues are used to send and receive messages.

            07:28:29.920 --> 07:28:34.480
            Messages are stored in queues until the receiving application is ready to accept and process them.

            07:28:34.480 --> 07:28:39.520
            Messages and queues are ordered and timestamped on arrival. Once accepted by the broker,

            07:28:39.520 --> 07:28:43.840
            the message is always held durably in triple redundant storage spread across availability

            07:28:43.840 --> 07:28:49.120
            zones if the namespace is zone enabled. Service Bus never leaves messages in memory or volatile

            07:28:49.120 --> 07:28:54.000
            storage after they've been reported to the client is accepted. Messages are delivered in pull mode,

            07:28:54.000 --> 07:28:59.520
            only delivering messages when requested. Configuration aspects of Azure Service Bus

            07:28:59.520 --> 07:29:04.400
            queues include time to live. This determines the duration of message remains in the queue.

            07:29:04.400 --> 07:29:08.640
            If it isn't processed within this time frame, it either gets removed or is transferred to the dead

            07:29:08.640 --> 07:29:13.520
            letter queue. Lock duration. This represents the period during which a message is locked.

            07:29:13.520 --> 07:29:18.560
            By locking messages, Service Bus ensures that no two users can read or process the same message

            07:29:18.560 --> 07:29:23.920
            simultaneously. To sum it up, queues in Azure Service Bus are efficient tools to handle message

            07:29:23.920 --> 07:29:28.400
            sending and receiving in a structured and reliable manner. So that's an overview of

            07:29:28.400 --> 07:29:37.920
            queues in Azure Service Bus. The next topic we'll be covering are topics in Azure Service Bus.

            07:29:38.640 --> 07:29:43.600
            Topics can be used to send and receive messages. A queue is often used for point to point or one

            07:29:43.600 --> 07:29:48.800
            to one communication, whereas topics are useful in publish, subscribe or one to many communication.

            07:29:48.800 --> 07:29:53.760
            It's important to note that topics are not available at the basic pricing tier, you'd need

            07:29:53.760 --> 07:29:58.480
            to opt for either the standard or premium tier. A unique feature of topics is their support for

            07:29:58.480 --> 07:30:03.440
            multiple independent subscriptions. Multiple independent subscriptions can be attached to

            07:30:03.440 --> 07:30:08.160
            a topic and work in the same way as queues from the receiver's side. A subscriber to a topic can

            07:30:08.160 --> 07:30:12.960
            receive a copy of each message sent to that topic. It's also worth noting that subscriptions are

            07:30:12.960 --> 07:30:18.000
            named entities providing an organizational structure. You can define rules on a subscription.

            07:30:18.000 --> 07:30:23.120
            A subscription rule has a filter that specifies a condition for a message to be copied into the

            07:30:23.120 --> 07:30:29.520
            subscription as well as an optional action that modifies message metadata. When creating a topic,

            07:30:29.520 --> 07:30:35.280
            consider the following configuration settings. Max topic size, you can specify a size ranging

            07:30:35.280 --> 07:30:40.080
            from one to five gigabytes. Time to live, the setting determines the duration after which a

            07:30:40.080 --> 07:30:45.360
            message is removed from the topic. Duplicate message avoidance, this ensures that duplicate

            07:30:45.360 --> 07:30:51.040
            messages are processed. Partitioning, useful for efficiently managing a large influx of events.

            07:30:51.040 --> 07:30:56.720
            A subscription in Azure Service Bus is a named entity associated with a topic that allows

            07:30:56.720 --> 07:31:02.320
            subscribers to receive copies of messages sent to that topic. In a publish subscribe model of

            07:31:02.320 --> 07:31:07.040
            Azure Service Bus topics can be thought of as the channels to send messages. Subscriptions are like

            07:31:07.040 --> 07:31:12.000
            the virtual queues to receive those messages. There are also additional configuration settings

            07:31:12.000 --> 07:31:17.200
            for subscriptions. Max delivery count, this setting can be adjusted between one to 2000,

            07:31:17.200 --> 07:31:22.560
            defining the number of delivery attempts for a particular message. Message sessions, when sessions

            07:31:22.560 --> 07:31:26.880
            are activated, a subscription can ensure that messages are delivered in a first in first out

            07:31:26.880 --> 07:31:32.240
            sequence. So that's an overview of topics in Azure. So that's an overview of topics in Azure.

            07:31:32.240 --> 07:31:41.120
            The next topic we'll be covering is the different pricing tiers in Azure Service Bus.

            07:31:41.120 --> 07:31:46.320
            Azure Service Bus has three different pricing tiers basic, standard and premium. The more expensive

            07:31:46.320 --> 07:31:51.360
            the tiers, the more functionality it provides. Let's break down the features and their availability

            07:31:51.360 --> 07:31:56.400
            across these tiers. Queues, this is the foundational messaging structure in Service Bus

            07:31:56.400 --> 07:32:00.560
            allowing messages to be sent and received. All three tiers offer support for queues.

            07:32:00.560 --> 07:32:05.600
            Schedule messages, this feature allows users to set messages to be dispatched at a future

            07:32:05.600 --> 07:32:11.840
            specified time. It's available across all three tiers. Topics, topics support the publish subscribe

            07:32:11.840 --> 07:32:16.160
            messaging pattern. This feature isn't available in the basic tier but is offered in both the

            07:32:16.160 --> 07:32:21.920
            standard and premium tiers. Transactions, ensuring a set of operations are completed successfully and

            07:32:21.920 --> 07:32:26.880
            in order transactions are not available in the basic tier. However, both the standard and premium

            07:32:26.880 --> 07:32:32.240
            tiers support this feature. The duplication, this ensures that duplicate messages are processed more

            07:32:32.240 --> 07:32:37.040
            than once. Only the standard and premium tiers offer this feature with the basic tier lacking it.

            07:32:37.040 --> 07:32:42.160
            Sessions, ensuring ordered and related sets of messages are processed in the correct sequence.

            07:32:42.160 --> 07:32:46.560
            This feature is excluded in the basic tier but is available in the standard and premium tiers.

            07:32:46.560 --> 07:32:52.480
            Forward to send via, this facilitates forwarding a message or routing it via a specific path.

            07:32:52.480 --> 07:32:56.560
            It's not supported in the basic tier but is available in the standard and premium tiers.

            07:32:56.560 --> 07:33:02.560
            Message size dictates the maximum allowable size for an individual message. The basic and standard

            07:33:02.560 --> 07:33:08.320
            tier support messages up to 256 kilobytes while the premium tier significantly extends this limit

            07:33:08.320 --> 07:33:14.560
            to 100 megabytes. Resource isolation, this provides isolated computational resources to ensure better

            07:33:14.560 --> 07:33:19.840
            performance and reliability. It's a feature exclusive to the premium tier. Geo disaster

            07:33:19.840 --> 07:33:24.720
            recovery in the event of significant geographical or infrastructure disruptions. This recovery

            07:33:24.720 --> 07:33:29.360
            feature helps maintain service integrity. It's denoted with an asterisk suggesting there might

            07:33:29.360 --> 07:33:33.440
            be additional details or conditions. This feature is reserved for the premium tier.

            07:33:34.080 --> 07:33:39.680
            Java messaging service supporting JMS, a standard messaging protocol for Java. This feature is only

            07:33:39.680 --> 07:33:44.800
            available in the premium tier. Availability zone support, this ensures high resilience and

            07:33:44.800 --> 07:33:49.520
            availability by distributing services across multiple isolated data centers or zones.

            07:33:49.520 --> 07:33:58.800
            It's exclusive to the premium tier. The next topic we'll be going over is a dead letter queue

            07:33:58.800 --> 07:34:03.520
            in Azure Service Bus. The dead letter queue in Azure Service Bus is a specialized queue that

            07:34:03.520 --> 07:34:07.840
            stores messages that couldn't be delivered or processed successfully. These messages might

            07:34:07.840 --> 07:34:13.440
            fail due to various reasons. Message that is sent to a queue that does not exist. Queue length limit

            07:34:13.440 --> 07:34:20.080
            exceeded. Message length limit exceeded. Message is rejected by another queue exchange. Message

            07:34:20.080 --> 07:34:24.640
            reaches a threshold read counter number because it is not consumed. Sometimes this is called a

            07:34:24.640 --> 07:34:30.480
            back out queue. The message expires due to per message TTL or the message is not processed

            07:34:30.480 --> 07:34:36.320
            successfully. Dead letter queues provide several benefits including monitoring failed message

            07:34:36.320 --> 07:34:41.840
            deliveries to understand and address the underlying issues. Recueing messages for another attempt at

            07:34:41.840 --> 07:34:47.200
            processing, especially after resolving the reason for the initial failure. Initiating follow up

            07:34:47.200 --> 07:34:52.560
            actions such as alerting remediation or alternative processing paths when specific failure patterns

            07:34:52.560 --> 07:34:57.120
            are detected. In essence, dead letter queues are vital for ensuring the reliability and

            07:34:57.120 --> 07:35:06.720
            resilience of a messaging system. The next topic we'll be covering are the Azure CLI commands for

            07:35:06.720 --> 07:35:11.920
            Azure Service Bus. Azure CLI offers various subcommands specifically tailored for Azure

            07:35:11.920 --> 07:35:17.120
            Service Bus. These subcommands enable efficient management and configuration as service bus

            07:35:17.120 --> 07:35:24.640
            georecovery alias as service bus migration as service bus namespace as service bus queue as

            07:35:24.640 --> 07:35:30.480
            service bus topic. Notably, unlike Azure Storage Queue, Azure Service Bus does not have direct CLI

            07:35:30.480 --> 07:35:35.840
            commands to send messages to queues or topics. For sending messages to a queue, you'd need to use the

            07:35:35.840 --> 07:35:42.800
            Azure SDK. For example, using the node.js SDK, you can install the necessary package with npm install

            07:35:42.800 --> 07:35:47.600
            at Azure slash service bus. This will allow you to integrate Azure Service Bus functionalities

            07:35:47.600 --> 07:35:52.080
            directly into your applications and send messages programmatically. So that's an

            07:35:52.080 --> 07:36:01.840
            overview of the key Azure CLI commands for Azure Service Bus. Hey, this is Andrew Brown from exam

            07:36:01.840 --> 07:36:06.000
            pro and we are going to take a look at service bus. So what I want you to do is type in service bus at

            07:36:06.000 --> 07:36:10.880
            the top here. What's interesting is that this is the old icon, they have a new icon. So just realize

            07:36:10.880 --> 07:36:14.880
            that there's some inconsistencies there. And that's not my fault. That's Azure's fault. But the

            07:36:14.880 --> 07:36:19.120
            first thing we need to do is create a namespace because a service bus is kind of like you know,

            07:36:19.120 --> 07:36:23.200
            a storage account where you can have a variety of different kinds of storages. Well, you can have

            07:36:23.200 --> 07:36:30.560
            more than one type of messaging system. And so we have our traditional one, like event messaging,

            07:36:30.560 --> 07:36:36.640
            similar to storage queue, but with first in first out functionality. And we have pub sub via topic.

            07:36:36.640 --> 07:36:42.720
            So what you'll do is create a new service bus namespace. And I'm going to create a new resource

            07:36:42.720 --> 07:36:51.280
            group and call this the AZ 204. Service bus. And we'll say message or sorry, queue, because we're

            07:36:51.280 --> 07:36:55.600
            going to do a queue and then we're going to do a topic separately. And for this, I'm going to call

            07:36:55.600 --> 07:37:02.160
            the namespace service bus queue to keep it simple. We'll let it launch wherever it wants to launch.

            07:37:02.160 --> 07:37:08.000
            And notice there are multiple pricing tiers, depending on the tier affects the functionality.

            07:37:08.000 --> 07:37:11.680
            So if we do basic, we're only going to have access to queue, we're not going to have access to

            07:37:11.680 --> 07:37:18.720
            topics. And so this is totally safe and fine to do. Like even we did premium, it's fine,

            07:37:18.720 --> 07:37:24.400
            because it's based on your consumption. It's not based on, you know, you just having holding

            07:37:24.400 --> 07:37:28.320
            around. So we'll get the basic one here. And we'll go to networking. I don't think there's anything

            07:37:28.320 --> 07:37:33.200
            interesting there, we'll go ahead and review and create. And we'll let that create, click Create

            07:37:33.200 --> 07:37:39.280
            again. And it's deploying as that is deploying, which will not take too long, what I've done is

            07:37:39.280 --> 07:37:43.680
            set up a private repository here, you'll probably see me use this throughout the course, it's

            07:37:43.680 --> 07:37:47.280
            literally an empty repository, because I already have the code done, I've been doing the follow

            07:37:47.280 --> 07:37:51.840
            alongs, and documenting them here in the free Azure Developer Associate. But when you're doing

            07:37:51.840 --> 07:37:55.760
            follow alongs with me, you should do them with do them from scratch. And then if you need to,

            07:37:55.760 --> 07:38:01.760
            you can reference the stuff here. So I have this separate repository, I have a get pod account,

            07:38:01.760 --> 07:38:06.400
            which has a free tier, you can totally do this in your own Visual Studio code on your little local

            07:38:06.400 --> 07:38:10.560
            machine. The reason I'm doing to get pod is I always want to show you how to set up the CLI

            07:38:10.560 --> 07:38:16.400
            and those other tools. And when you launch get pod, it gives you a blank environment. So I'm just

            07:38:16.400 --> 07:38:20.720
            going to launch that up there. As that's going, we'll go back here and take a look and see if

            07:38:20.720 --> 07:38:26.720
            this is ready, just hit refresh here, it is still going. But we already have our environment. And

            07:38:26.720 --> 07:38:32.480
            while that is going in the background, I want to go install the Azure CLI. So we don't even have a

            07:38:32.480 --> 07:38:37.040
            single file here, I'm just going to say read me dot MD. So I can see what is going on here. Maybe

            07:38:37.040 --> 07:38:43.600
            we'll just dump things in here as we go, I'm going to go get the Azure CLI Linux, because this is

            07:38:43.600 --> 07:38:50.080
            running Linux Ubuntu here. So something you should always check is like, what Linux version

            07:38:51.040 --> 07:38:54.400
            am I running? If you're a Windows, of course, this is going to be different. But even

            07:38:54.400 --> 07:38:59.440
            Windows using the Windows subsystem, Linux is using Ubuntu as well. So what I'll do here,

            07:38:59.440 --> 07:39:02.480
            I'll go to the first link. Nope, that's not the one I want. Maybe the second one.

            07:39:02.480 --> 07:39:12.880
            There's usually like a command here, I can run which Linux version am I running?

            07:39:15.360 --> 07:39:24.160
            Let's try this one here. It's usually like, maybe it's this here cat proc version.

            07:39:24.160 --> 07:39:28.640
            It really does vary based on what you're using. And so here I'm going to go file

            07:39:28.640 --> 07:39:38.480
            or sorry, terminal new terminal. We'll paste that in there, hit enter. And so here it says Linux 513

            07:39:38.480 --> 07:39:51.360
            Ubuntu 1118. So I know that this is Ubuntu. I don't really like that one there. Um, let's try

            07:39:51.360 --> 07:39:57.600
            this instead. Because this doesn't read very well. There we go. We're running Ubuntu 20. Oh,

            07:39:57.600 --> 07:40:02.080
            four, I already knew that. But I just wanted to double check. And the reason that matters is that

            07:40:02.080 --> 07:40:06.800
            when you're installing the CLI, it might matter what version you're using. So we're going to go

            07:40:06.800 --> 07:40:12.720
            here. And I'm going to go to Linux. And the instructions might vary. This one says 16 1820.

            07:40:12.720 --> 07:40:15.840
            So they're all the same here. And we have this one liner here that will install.

            07:40:15.840 --> 07:40:19.840
            And what I'll do here is drop it in here and hit enter.

            07:40:19.840 --> 07:40:26.560
            I'm not sure if this font is too small. So while it's going, I'm going to see if I can bump up our

            07:40:26.560 --> 07:40:50.320
            font here. I'm looking for the terminal font size here terminal. So say 20 here. There we go. And

            07:40:50.320 --> 07:40:56.240
            so the Azure CLI should be installed. So I'll just type in clear. So say Azure, or AZ to run it.

            07:40:56.960 --> 07:41:02.960
            Looks good to me. So let's type in Azure login. I don't want to log in with that way,

            07:41:02.960 --> 07:41:09.200
            I want to log in with device. So we'll do AZ login device. Because if you're on your regular computer,

            07:41:09.200 --> 07:41:12.640
            you can just click a button and go to the browser, but I'm not gonna be able to do that. So I'm gonna

            07:41:12.640 --> 07:41:23.360
            have to do a device login device. Well, I'll have to do it the wrong way first to do it the right

            07:41:23.360 --> 07:41:28.560
            way. So hit enter, because the problem is, if I go here, it's going to go to localhost, because

            07:41:28.560 --> 07:41:33.600
            it's trying to launch in my local machine. So it does that. And that's no good. And so here it says

            07:41:33.600 --> 07:41:41.040
            do the AZ login use device code. Okay, so that's the one I really wanted to use. So hyphen hyphen

            07:41:41.040 --> 07:41:46.800
            use device code, enter. And that will give us a code. So what we do is we will need this link

            07:41:46.800 --> 07:41:56.160
            here. So I'll have to expand that to here. And then I'm going to go ahead and grab that code.

            07:41:56.160 --> 07:42:08.160
            Continue. Let's not go back, this will authenticate, it'll just take a second here.

            07:42:13.040 --> 07:42:18.560
            Close the tab here. There we go, man to close the tab. And so now I'm authenticated. So I should be

            07:42:18.560 --> 07:42:28.320
            able to do whatever I want. What I need to do next is create ourselves a message queue. So we'll go

            07:42:28.320 --> 07:42:32.480
            to the resource here. And notice here, the entities, it always says queue. Now if we had

            07:42:32.480 --> 07:42:39.120
            other than the basic, the standard plan, then we would see topics here. We'll go click into queue,

            07:42:39.120 --> 07:42:44.080
            click create a new queue, I'm going to call it my queue. We have some options here, the queue size

            07:42:44.080 --> 07:42:47.760
            can go up to five gigabytes, the max delivery count. So this is the maximum deliveries,

            07:42:47.760 --> 07:42:52.880
            time to live, that is how long they live in the queue before they are dropped out or they are

            07:42:52.880 --> 07:42:59.760
            dropped into a dead letter system there, we have locked duration. So the set the amount of time a

            07:42:59.760 --> 07:43:04.720
            message is locked for other receivers, you can enable partitioning, that's pretty complicated,

            07:43:04.720 --> 07:43:11.040
            but we'll go ahead and create our queue. And so this should be pretty darn quick, there is our

            07:43:11.040 --> 07:43:16.320
            queue, we'll click into it. And you'll notice that there isn't really a way to view messages,

            07:43:16.320 --> 07:43:24.160
            there's not a way to add messages. Here we have the service bus Explorer, which I guess technically

            07:43:24.160 --> 07:43:28.480
            you can send and receive here, I had not noticed this before, at least it was not working for me.

            07:43:28.480 --> 07:43:33.760
            So I suppose we could send a message here saying like, Hello, world. There's literally wasn't here

            07:43:33.760 --> 07:43:45.440
            last time I checked here. And we can go ahead and just hit send. Okay, and notice here, it says

            07:43:45.440 --> 07:43:52.560
            there's one active message, and we can receive it. So yes. And so it says it received the message is

            07:43:52.560 --> 07:43:58.320
            not showing us the answer. So I guess there kind of is something here, I guess they're still working

            07:43:58.320 --> 07:44:06.080
            on it. But mostly, what we're gonna have to do is do things programmatically. So that is why we have

            07:44:06.080 --> 07:44:12.240
            this account. So what I want you to do is open a new tab here, we're gonna type in Azure service

            07:44:12.240 --> 07:44:17.760
            bus documentation, because we're gonna grab some code there, modify it, make it our own. So it's a

            07:44:17.760 --> 07:44:24.480
            bit easier to work with. So here, I'm in the service bus, we'll go to tutorials. I'm not sure

            07:44:24.480 --> 07:44:37.600
            if this one is the right one. Azure service bus documentation queue. It's the same thing here.

            07:44:37.600 --> 07:44:44.320
            But this is doesn't look right. What is service bus?

            07:44:52.640 --> 07:44:55.680
            I mean, it is the right page, but it had a couple tutorials here

            07:44:55.680 --> 07:45:02.720
            that I had here. So we'll type in like Azure service bus tutorial topics.

            07:45:02.720 --> 07:45:07.840
            Sometimes things aren't where you think they're supposed to be.

            07:45:07.840 --> 07:45:14.640
            Okay, type in service bus.

            07:45:18.720 --> 07:45:24.400
            Seems like the same page again. I was quick starts, sorry. So we have tutorials here. And

            07:45:24.400 --> 07:45:28.160
            then we have quick starts. So under the quick starts, this is where I was finding the example

            07:45:28.160 --> 07:45:34.400
            code that I thought was okay. Notice that we could do everything via the CLI. That is not that fun.

            07:45:34.400 --> 07:45:38.080
            But I mean, this only does the creation of it doesn't necessarily do sending and receiving

            07:45:38.080 --> 07:45:42.320
            messages, notice that we only can use code. So we'll use JavaScript, because I think that will

            07:45:42.320 --> 07:45:47.760
            be the easiest to use. So I already have no node comes pre installed on Git pod, you'll have to

            07:45:47.760 --> 07:45:52.160
            figure that out for yourself on your own machine. Or you can just use Git pod as well, because it

            07:45:52.160 --> 07:45:58.640
            does have a generous free tier, we'll do is go ahead and paste on in this command, it doesn't

            07:45:58.640 --> 07:46:03.920
            seem to want to paste today. So I'll hit copy. And then we'll go back here and go right click,

            07:46:03.920 --> 07:46:11.440
            enter, paste, hit enter. And so what that will do is install that library. If you're not very

            07:46:11.440 --> 07:46:16.160
            familiar with node j s package, Jason is the package manager. And this is showing that this

            07:46:16.160 --> 07:46:21.040
            requirement is there, I want to install one other thing called dot e and v, this will make our lives

            07:46:21.040 --> 07:46:29.520
            a lot easier. For node, it comes for different things, but I just wanted for JavaScript here.

            07:46:29.520 --> 07:46:35.520
            So then we'll do NPM install dot e and v hyphen save. That's just a safe way for us to pass along

            07:46:35.520 --> 07:46:40.080
            our environment variables. And so now both of these are installed. So what we'll do is we'll

            07:46:40.080 --> 07:46:44.400
            go back over to this code. And we'll scroll on down and they have one called send and they have

            07:46:44.400 --> 07:46:49.680
            one called receive. So what I'll do is create myself a couple files here. So we'll have send

            07:46:49.680 --> 07:47:01.200
            dot j s. And we'll have received dot j s. And then what we'll do is go ahead and copy this is the

            07:47:01.200 --> 07:47:09.840
            send code. So we'll put this in the send j s file. And then down below, we have the receive code.

            07:47:13.120 --> 07:47:18.480
            And we will paste that on in there. So I'll just make this bigger. And we'll take a quick look here

            07:47:18.480 --> 07:47:24.960
            at what it's doing. So what this does is it imports the SDK for service bus, we need to set

            07:47:24.960 --> 07:47:29.440
            a connection string, we need to set the queue name, here is a bunch of messages that we are going to

            07:47:29.440 --> 07:47:35.200
            be passing along. Here, we establish a service bus client very common in all SDKs, a set of client

            07:47:35.200 --> 07:47:42.080
            first, then we are creating a sender. And then here we are doing create batch messages. So it's

            07:47:42.080 --> 07:47:48.080
            a way of sending messages in batch very efficiently. So we have a for loop here. And so it says there's

            07:47:48.080 --> 07:47:54.000
            a batch. And then it says try to add the message to the batch. If it's not wait until it's ready,

            07:47:54.000 --> 07:47:59.680
            then send the message. Okay, so pretty straightforward for that code receives going

            07:47:59.680 --> 07:48:05.360
            to be similar. So connection string, queue name, create that client, create a receiver.

            07:48:05.360 --> 07:48:11.280
            And then from there, we will set up a handler for the receiver and error. And so then we'll

            07:48:11.280 --> 07:48:17.680
            subscribe. And we will listen for the message and handler. So even though we are doing queues,

            07:48:17.680 --> 07:48:22.880
            it's called a subscription still, so just don't get too mixed up with that. What I want to do

            07:48:22.880 --> 07:48:27.200
            is just make sure that we're passing our environment variables in safely or configuration.

            07:48:27.200 --> 07:48:32.960
            So this is pretty standard or good best practices when working with any language. The idea is you

            07:48:32.960 --> 07:48:38.000
            don't want to hard code your values. So I'm going to do process ENV. And we'll do connection string

            07:48:38.000 --> 07:48:46.640
            here. And then we'll do process ENV. Q name, this is the way you grab environment variables in

            07:48:46.640 --> 07:48:55.840
            JavaScript for every language, it's a little bit different. Okay. And I believe these are

            07:48:55.840 --> 07:48:59.040
            the same. So I'm just going to go ahead and grab that there like this.

            07:48:59.040 --> 07:49:07.440
            And I'll paste that on in here. And I want to load environment variable. So I'll make a new file

            07:49:07.440 --> 07:49:12.880
            here called dot ENV. This is all part of that ENV dot thing. They were looking at ENV dot,

            07:49:12.880 --> 07:49:20.640
            I'm just pulling that up again here, or dot ENV, you get the right one. Because we need this line

            07:49:20.640 --> 07:49:26.960
            here required dot, dot ENV config that will load the environment variables, it'll load it from that

            07:49:26.960 --> 07:49:37.360
            ENV file. So we will go above here and hit paste. And then we'll go to the receive here and do this

            07:49:37.360 --> 07:49:44.240
            as well. And in here, we need to define these. So I'm just going to copy this, so I don't have

            07:49:44.240 --> 07:49:48.800
            to type it out by hand, we will paste that on in here. And so I just need the queue name.

            07:49:55.920 --> 07:50:02.400
            And connection string, we'll just say equals and then equals. So our queue is called my queue.

            07:50:02.400 --> 07:50:09.040
            And then we need to go grab the connection string.

            07:50:09.040 --> 07:50:15.040
            So I'm just thinking here, this is probably Yeah, it's at the namespace level.

            07:50:15.040 --> 07:50:20.880
            And we'll go to shared access policies. Notice it's called shared access policies. Remember,

            07:50:20.880 --> 07:50:25.840
            when we're doing the storage key, it was called key access. So it's totally different interface.

            07:50:25.840 --> 07:50:30.240
            This is what I'm talking about where Azure is inconsistent, we're clicking on the root managed

            07:50:30.240 --> 07:50:34.800
            shared access key, probably could create your own so it doesn't have full privileges. But for this

            07:50:34.800 --> 07:50:39.280
            purpose, we're just going to use this one. On the left hand side, we have a primary and secondary,

            07:50:39.280 --> 07:50:44.720
            we're gonna use the primary one. And we will go back here and we will paste on that value in.

            07:50:46.960 --> 07:50:51.360
            So I'll paste that in there. Notice we don't have to do double quotations here, it should

            07:50:51.360 --> 07:50:56.640
            already escape in double quotations. But we're doing the CLI when we did the storage accounts,

            07:50:56.640 --> 07:51:00.960
            that wasn't something that we could do. So we have these two values here. So they should get

            07:51:00.960 --> 07:51:07.360
            loaded when we use them. And this should all be good. So we'll type in node, send JS, and hopefully

            07:51:07.360 --> 07:51:13.120
            it just works. Fingers crossed. And so it sent a batch of messages to the queue. So we'll go back

            07:51:13.120 --> 07:51:19.360
            over to our queue here and see if we can see anything. And we'll click into here.

            07:51:19.360 --> 07:51:27.360
            I'm just trying to see. So there's 10 active messages that are here right now.

            07:51:27.360 --> 07:51:34.800
            And so what we'll do is we'll receive all those messages. So we'll go up and hit node, receive JS.

            07:51:38.640 --> 07:51:43.680
            So this code is now receiving those messages from the service bus queue. And we're just going to

            07:51:43.680 --> 07:51:48.560
            wait here because it takes time for whatever reason to finish here. But we'll give it a

            07:51:48.560 --> 07:52:00.560
            little bit of time here to figure out that it's done. Still waiting. There we go. And so that's

            07:52:00.560 --> 07:52:06.560
            all there really is to it. So that is Q. And we will do this again, but next time with topics.

            07:52:07.200 --> 07:52:11.840
            So what I want you to do is make your way over back to your resource groups, we'll find the one

            07:52:11.840 --> 07:52:19.760
            that we just created, which was this one here. AZ 204 service bus queue will delete this service

            07:52:19.760 --> 07:52:26.880
            group. Hit Delete, delete. And there you go. And as always, double check to make sure that you've

            07:52:26.880 --> 07:52:32.800
            for sure delete that stuff. And that's it for service bus queue. We'll do topics next. Okay.

            07:52:32.800 --> 07:52:41.440
            Hey, this is Andrew Brown from exam Pro. And we are looking at service bus. And this time we're

            07:52:41.440 --> 07:52:46.000
            looking at topics. So what I want you to do just like before is go to the top, we'll type in service

            07:52:46.000 --> 07:52:52.080
            bus. And we'll go to the service bus service, you can still see the old one is there, it should be

            07:52:52.080 --> 07:52:58.160
            deleting. That's how slow this thing is. But we'll create a new one. And we will create a new resource

            07:52:58.160 --> 07:53:07.600
            group. And we will call it AZ 204. Service bus topic, we'll say okay, we'll name this service

            07:53:07.600 --> 07:53:14.720
            bus topic. And this time, it already exists. If it does just dump a bunch of numbers here on the end,

            07:53:14.720 --> 07:53:19.040
            because it's unique based on that. So it's like having a domain name of somebody who has it,

            07:53:19.040 --> 07:53:22.880
            you're gonna have a problem. And so here, I'm going to go to standard because in order for us

            07:53:22.880 --> 07:53:27.440
            to use those additional features, we will need to be on the standard plan. So we'll go ahead and hit

            07:53:27.440 --> 07:53:32.880
            review and create. And that'll take a little bit of time to create. But while that's going, I'm

            07:53:32.880 --> 07:53:38.800
            going to launch my environment here. So this was the one I was just using a moment ago with GitHub.

            07:53:38.800 --> 07:53:44.560
            And so what I'm going to do is I'm just going to go back to our repo here, I'm just doing it

            07:53:44.560 --> 07:53:51.600
            off screen because I don't want to expose all my stuff here. Again, if you want to, you can do this

            07:53:51.600 --> 07:53:56.480
            in your local Visual Studio code, I just want to show everything from scratch every time. So here's

            07:53:56.480 --> 07:54:00.720
            my empty repo with get pod. And so I'll just close this one and it will vanish. All that code is now

            07:54:00.720 --> 07:54:04.240
            gone. Let's get pod, this will launch a new environment. It's trying to tell me to open the

            07:54:04.240 --> 07:54:08.880
            last one. Nope, I'm going to make a new one for this workspace here. And we'll get going here in

            07:54:08.880 --> 07:54:19.600
            a moment. So this namespace has been created. So we'll go ahead and hit Create. And I guess it's

            07:54:19.600 --> 07:54:23.280
            still making I thought I already deployed it there, but I guess I didn't.

            07:54:23.280 --> 07:54:31.760
            Okay, while that's going, we'll go ahead and install the Azure CLI. So we'll type in Azure

            07:54:31.760 --> 07:54:39.280
            CLI Linux, because that is what we're using here today. We'll go to Linux here, we'll scroll on

            07:54:39.280 --> 07:54:45.760
            down, grab this one liner here to install it, I'm going to open up my terminal, your terminal might

            07:54:45.760 --> 07:54:52.640
            be somewhere else. Allow, I'm going to go ahead and paste that on in there. That's going to install

            07:54:52.640 --> 07:54:59.680
            our Azure CLI. As that's installing, it will be done here in a moment. Let's see if this is done,

            07:54:59.680 --> 07:55:08.880
            this is still creating the namespace, I think. And this is still installing shouldn't take too

            07:55:08.880 --> 07:55:13.520
            long. While this is going, we can start grabbing the code for this. So for this, we'll type in

            07:55:13.520 --> 07:55:24.320
            Azure, Azure service bus documentation. And this I found it under the quickstart. So we will go to

            07:55:24.320 --> 07:55:28.560
            quickstart serve topics and services, because there's some code here that I want under the

            07:55:28.560 --> 07:55:37.280
            JavaScript. And we have one for send to topic. So we'll just grab that name there, make a new file

            07:55:37.280 --> 07:55:48.320
            sent to topic j s. And we will go down here to this other one, this is receive from subscription,

            07:55:48.320 --> 07:55:52.160
            you're going to notice this is very similar to doing a queue. The difference is that you can

            07:55:52.160 --> 07:55:58.960
            have multiple subscriptions consume the same stuff. Our CLI is done. So we'll type in AZ login.

            07:55:58.960 --> 07:56:04.240
            I can't remember what it is, we'll hit Enter here. I know this is the wrong way. But I just can't

            07:56:04.240 --> 07:56:08.240
            remember what it is. I want use device code. That's what it is. So I'll go ahead and grab this.

            07:56:08.240 --> 07:56:14.320
            And I'll just hit Ctrl C to exit out of that and then paste that in there. And then we'll do it

            07:56:14.320 --> 07:56:18.560
            the way that we actually want to do it. So then we will go ahead and grab this for device login.

            07:56:20.320 --> 07:56:23.520
            We will provide the code as suggested here.

            07:56:23.520 --> 07:56:34.480
            We will continue, we will close this. And it will say that we are authenticated. So we are now

            07:56:34.480 --> 07:56:44.000
            authenticated, we can use AZ, or the Azure CLI. I don't know if we need the CLI. Well, we have it

            07:56:44.000 --> 07:56:47.520
            anyway, at least we had to authenticate. So at least that was out of the way. I'm not sure we're

            07:56:47.520 --> 07:56:52.560
            actually going to use the CLI in this one. But what we'll do is go to the resource here.

            07:56:52.560 --> 07:56:59.360
            And we want to create a topic this time around. And I'm going to call this my topic,

            07:56:59.360 --> 07:57:03.440
            we have a topic size between one to five, you have a TTL,

            07:57:03.440 --> 07:57:08.800
            you can do make sure there aren't duplicates, we're gonna go ahead and create this topic.

            07:57:14.000 --> 07:57:20.080
            Okay, so just like last time, we need to install a couple things. So if we go to the top here,

            07:57:20.080 --> 07:57:25.360
            there should be like an NPM install here, it is NPM install service bus. So we'll paste that on

            07:57:25.360 --> 07:57:30.560
            in there, we'll need our dot ENV. So look up dot ENV again, and we will just install NPM install

            07:57:30.560 --> 07:57:37.440
            dot ENV for environment variables, hit enter, we will create ourselves a new dot ENV file.

            07:57:37.440 --> 07:57:42.800
            And we will need to look at what environment variables we are going to need.

            07:57:42.800 --> 07:57:48.720
            So it looks like we didn't copy the center topic content, at least I didn't. So we will go back

            07:57:48.720 --> 07:57:56.000
            over to here and go up here and get sent a topic, paste that on in there. We'll go all the way to

            07:57:56.000 --> 07:58:00.800
            the top. And I'm looking for what we need here. So here we have one which is connection string,

            07:58:00.800 --> 07:58:07.760
            whoops. Not mean to delete all that. So we'll hit process ENV connection string.

            07:58:09.920 --> 07:58:12.000
            And we have to spell it right, or it's going to have a problem.

            07:58:12.000 --> 07:58:16.640
            And then we have process ENV.

            07:58:16.640 --> 07:58:24.240
            Topic name, I think of this one, it actually also has subscription. So we'll have to have

            07:58:24.240 --> 07:58:28.800
            a third one. So I'm just going to copy these two over. So I'm to type it 100 times.

            07:58:28.800 --> 07:58:37.760
            This one will be process ENV subscription name, you're noticing I'm not having the

            07:58:38.640 --> 07:58:43.440
            semi colon that is optional in JavaScript. So it won't break anything if I don't have them there.

            07:58:43.440 --> 07:58:51.040
            subscription name. And so these are the three that we'll need, I'm going to just split this

            07:58:51.040 --> 07:58:55.040
            to make my life a little bit easier. And I'm just going to copy this here paste.

            07:58:55.040 --> 07:59:01.680
            Not exactly how I wanted to paste it, but that's totally fine. I'm going to copy this.

            07:59:01.680 --> 07:59:06.960
            I don't think we made a subscription yet. But I know we're going to call it my subscription to

            07:59:06.960 --> 07:59:16.000
            make our lives easy. So we'll say, my topic, my subscription. And we'll grab this in a moment.

            07:59:16.000 --> 07:59:22.240
            So we'll go back over to Azure, we got too many tabs open here. While we're here, we might as

            07:59:22.240 --> 07:59:27.120
            well go grab this code. Before we go back to Azure, so we can grab grab this dot ENV config,

            07:59:27.120 --> 07:59:32.480
            that is going to load our configure configuration environment. So we go to the top here,

            07:59:33.200 --> 07:59:35.200
            paste that on in there for both files.

            07:59:35.200 --> 07:59:42.000
            Again, best practice never to hard code your values always pass it in like that with environment

            07:59:42.000 --> 07:59:46.000
            variables. We'll go back to our service bus. The first thing we need will be at a topic,

            07:59:46.000 --> 07:59:51.040
            we're going to need a subscription. So we go to topic here and click into it, we can create

            07:59:51.040 --> 07:59:56.640
            ourselves a subscription. So we'll go here, we'll say my subscription. Notice we have max delivery

            07:59:56.640 --> 08:00:00.560
            count, we have to set this between a value of one and 2000. I'm going to say 12. For fun,

            08:00:01.360 --> 08:00:07.280
            we can set the idle notice here, if we want to have first in first out, we would checkbox enable

            08:00:07.280 --> 08:00:13.120
            sessions, we're going to leave that alone does not matter too much for our demo. So we'll go

            08:00:13.120 --> 08:00:16.880
            ahead and create that subscription, it is created. Now what I need you to do is go back to the

            08:00:16.880 --> 08:00:22.720
            service bus topic namespace. And from there on the left hand side, we're going to shared access

            08:00:22.720 --> 08:00:26.960
            policies, we're going to click into the route manage shared access, we're going to grab the

            08:00:26.960 --> 08:00:31.520
            primary connection string key, the secondary would work too, it's just a second optional one,

            08:00:31.520 --> 08:00:36.240
            because they always give you a two, we'll paste that on in there. And if this is all correct,

            08:00:36.240 --> 08:00:43.680
            these should just work. So now what we'll do is type in node. Actually, we did want to see a

            08:00:43.680 --> 08:00:49.120
            line installed, because I wanted to show you that there was stuff in the queue, whereas with storage

            08:00:49.120 --> 08:00:53.760
            queue, when we're doing Azure storage queue, I couldn't show you because I just didn't know of

            08:00:53.760 --> 08:00:58.400
            a command, I believe, at least I think that was the case. But we'll take a look and see what we

            08:00:58.400 --> 08:01:05.680
            can see. Okay. So actually, we didn't do it at any time, I wonder which one I did that for. Let's

            08:01:05.680 --> 08:01:12.800
            just double check here. I have off screen here somewhere. My instructions because I wrote it

            08:01:12.800 --> 08:01:19.760
            for one of these maybe was for the queue that we did it. Yeah, I didn't do the last one. But I did

            08:01:19.760 --> 08:01:23.920
            an Azure service bus queue show. And the idea was to show you that there was a message count 10. So

            08:01:23.920 --> 08:01:28.400
            you could see the queue. But I think that since we saw it in the UI, I just wasn't too worried about

            08:01:28.400 --> 08:01:33.360
            it. Now, did I do it for this one? I'm not sure. Yeah, we do a topic show. So we'll do that for

            08:01:33.360 --> 08:01:39.280
            fun. But first, we need to insert our messages, which are part of the topic send, I don't think

            08:01:39.280 --> 08:01:44.000
            we read through these. So let's just quickly read. They look very, very similar to the last one. So

            08:01:44.000 --> 08:01:49.360
            you have your messages that you want to send, you create yourself a client, you create yourself a

            08:01:49.360 --> 08:01:57.120
            sender, you create a batch message, send message, like it's basically identical. Like, I can't even

            08:01:57.120 --> 08:02:04.640
            tell the difference here, except here, we're supplying a topic name. So I mean, I see it here.

            08:02:04.640 --> 08:02:10.320
            Ah, here, it creates centered, the topic name is specified there. So I just imagine that instead

            08:02:10.320 --> 08:02:14.080
            of providing a topic name, you provide the queue name. And that's how it knows the difference.

            08:02:14.080 --> 08:02:17.920
            But anyway, what we'll do is go ahead and execute this code, we'll say node sent a topic,

            08:02:18.480 --> 08:02:24.800
            j s. Okay, so it sent the stuff. Now, we didn't do this last time. So let's do it this time around.

            08:02:24.800 --> 08:02:31.040
            So we'll type in Azure service bus topic show. And here, we'll need to set the resource group. So

            08:02:31.040 --> 08:02:36.720
            this was called, I don't know, let's go take a look here. What is our service group called?

            08:02:39.280 --> 08:02:51.680
            It is called AZ 204. Bring that down a bit here. AZ 204. Service bus topic, we need to specify the

            08:02:51.680 --> 08:03:04.480
            namespace name. So that's just called service bus topic, hyphen 723849, because we couldn't get the

            08:03:04.480 --> 08:03:09.520
            number we want. And then we need to specify the name. So I assume it's the name of the topic. So

            08:03:09.520 --> 08:03:20.800
            the top is my topic and enter. And it says service bus, that name is misspelled. We're not recognized

            08:03:20.800 --> 08:03:29.360
            by the service. Did you mean service bus? Yeah, I guess spell that right. Hit enter. And that looks

            08:03:29.360 --> 08:03:33.520
            fine. But I just want to specify it as output yaml, just hit up on your keyboard, if you want

            08:03:33.520 --> 08:03:37.360
            to go back to those previous commands, would enter. So this is a little bit easier to read.

            08:03:37.360 --> 08:03:41.360
            And so what we're looking for here is just kind of like the message count.

            08:03:41.360 --> 08:03:46.320
            Does it show us here, which is the description count?

            08:03:46.320 --> 08:03:54.640
            I don't see it. So I guess it's not visible in the same way as the queue is like if we did this,

            08:03:54.640 --> 08:03:57.760
            and we didn't do the last one, it would we just saw like that message count there.

            08:03:58.560 --> 08:04:04.240
            But let's take a look at what we can see in the CLI to just see what information or a UI that our

            08:04:04.240 --> 08:04:08.240
            portal so we can see some information here. So we have one subscription here, we'll click into here.

            08:04:08.240 --> 08:04:14.320
            We have max size, incoming request 12.

            08:04:14.320 --> 08:04:23.920
            Yeah, I don't really see it message count 10. Max delivery count 12.

            08:04:26.320 --> 08:04:30.640
            Okay, so I guess there was 10. And that's the 12. So I guess that's where it's being counted.

            08:04:30.640 --> 08:04:34.480
            Let's go run the other one to receive. I'm gonna just double check to make sure that we set those

            08:04:34.480 --> 08:04:40.080
            we did. That's all good. So we'll type in node receive. If you're wondering how I'm auto completing

            08:04:40.080 --> 08:04:46.960
            without typing that just hit tab on my keyboard. So it's receiving those. Good. And that finished,

            08:04:46.960 --> 08:04:50.800
            I'm going to go ahead and refresh, see if there's any difference here. Notice that the message count

            08:04:50.800 --> 08:04:56.000
            is zero. So when the topics were there, it was held in the subscription saying 10 is here.

            08:04:56.000 --> 08:05:01.360
            And they've yet to be delivered. When we ran it, they were received. And so that number cleared out.

            08:05:01.360 --> 08:05:06.960
            That's all we really need to learn for topics. So we are done with topics. So let's make our way

            08:05:06.960 --> 08:05:15.840
            over to resource groups. And we'll go over to our service bus topic. Go ahead and delete this here.

            08:05:21.280 --> 08:05:30.320
            Delete. There it is deleting, we are all good to go. And you know, just as always,

            08:05:30.320 --> 08:05:33.600
            don't ever trust Azure to delete these things, go back and check in three, four minutes,

            08:05:33.600 --> 08:05:38.800
            make sure it's deleted. So you just don't have things lingering around. But yeah, there you go.

            08:05:38.800 --> 08:05:48.720
            Hey, this is Andrew Brown from exam Pro. In this section, we're diving into Azure Event Grid.

            08:05:48.720 --> 08:05:52.960
            Azure Event Grid is a service that allows you to manage event routing from any source to any

            08:05:52.960 --> 08:05:58.240
            destination. Event Grid provides a simple and strong customizable event delivery process that

            08:05:58.240 --> 08:06:02.240
            allows you to manage at a minimum level which types of events will be received as well as which

            08:06:02.240 --> 08:06:06.960
            subscribers will receive those events. One of the Event Grid strengths is its event fan out

            08:06:06.960 --> 08:06:12.160
            capability combined with 24 hour retry reliability ensuring your events are consistently delivered.

            08:06:12.160 --> 08:06:17.280
            It's a cost effective serverless solution with dynamic scalability, making it an excellent

            08:06:17.280 --> 08:06:22.960
            choice for businesses of all sizes. Azure Event Grid is ideal and event driven architectures,

            08:06:22.960 --> 08:06:27.360
            you can subscribe to events from Azure resources and then route them to an event handler or webhook.

            08:06:27.360 --> 08:06:32.000
            Furthermore, with custom topics, you have the flexibility to craft and publish your

            08:06:32.000 --> 08:06:36.400
            own events within your event grid. So that's an overview of Azure Event Grid.

            08:06:36.400 --> 08:06:45.360
            The next topic we'll be covering our event sources and handlers in Azure Event Grid.

            08:06:46.080 --> 08:06:50.560
            Azure Event Grid is divided into two categories event sources and event handlers.

            08:06:50.560 --> 08:06:55.680
            Azure's Event Grid operates as a central hub coordinating between various event sources and

            08:06:55.680 --> 08:07:01.200
            event handlers. On the side of event sources, which are services that emit data, we have blob storage,

            08:07:01.200 --> 08:07:05.920
            signal R, resource groups, Azure app configuration, subscription, Azure machine learning,

            08:07:05.920 --> 08:07:11.600
            event hub, Azure communication services, media service, Azure cash for release, IoT hub, cloud

            08:07:11.600 --> 08:07:16.800
            events, service bus, Azure policy, Azure maps, custom events, and Azure container registry.

            08:07:16.800 --> 08:07:22.000
            These sources send their data to the event grid. On the other end, we have event handlers, which are

            08:07:22.000 --> 08:07:26.720
            the services that receive and act upon this data. The serverless code category involves functions

            08:07:26.720 --> 08:07:31.360
            for workflow and integration. The services user service bus and logic apps,

            08:07:31.360 --> 08:07:36.640
            buffering and competing consumers handle the influx of data through event hub and storage queue.

            08:07:37.280 --> 08:07:41.520
            Additionally, there are other services and applications which encompass hybrid connections,

            08:07:41.520 --> 08:07:45.760
            web sockets, web hooks, automation, and essentially any service or application.

            08:07:45.760 --> 08:07:51.040
            These handlers effectively process or route the data sent by the event sources through event grid,

            08:07:51.040 --> 08:07:54.320
            enabling a seamless flow of information across Azure services.

            08:07:54.320 --> 08:08:04.160
            The next topic we'll be going over are the key concepts of Azure Event Grid. Domains are used

            08:08:04.160 --> 08:08:08.320
            to group event grid topics that are related to the same application for easier management.

            08:08:08.320 --> 08:08:13.760
            Topics, these serve as the destinations to which events are dispatched. System topics,

            08:08:13.760 --> 08:08:19.040
            Azure services offer these built in topics. In contrast, custom topics pertain to individual

            08:08:19.040 --> 08:08:24.240
            applications and third party topics. Additionally, partner events enable third party software as a

            08:08:24.240 --> 08:08:29.680
            service providers to broadcast events. Events, these encapsulate specific occurrences within

            08:08:29.680 --> 08:08:34.640
            a service. Publishers is the service that published the event. Event sources are where

            08:08:34.640 --> 08:08:39.040
            the event took place. Event subscriptions are the mechanism that routes the events.

            08:08:39.040 --> 08:08:44.080
            Event subscription expiration, this allows users to designate a lifespan for their event

            08:08:44.080 --> 08:08:49.200
            subscriptions after which they become invalid. Event handlers, these are the applications or

            08:08:49.200 --> 08:08:54.240
            services tailored to process or act upon the received events. Event delivery is the delivery

            08:08:54.240 --> 08:08:59.360
            of events and batches or a single events. Batching is the sending of a group of events in a single

            08:08:59.360 --> 08:09:03.520
            request. Overall, these are the key concepts of Azure Event Grid.

            08:09:03.520 --> 08:09:14.320
            Hey, this is Andrew Brown from exam Pro. And we're going to take a look at event grid basics.

            08:09:14.320 --> 08:09:18.000
            So let's get to it. So the first thing we're going to want to do is we're going to search up

            08:09:18.000 --> 08:09:23.600
            subscriptions, because we're going to need to make sure that in, like in order for us to use event

            08:09:23.600 --> 08:09:28.720
            grid that we have it turned on. And so we'll go into our subscription, and we're going to go under

            08:09:29.280 --> 08:09:38.400
            resource providers, resource providers, there it is. And this is all the stuff that is registered

            08:09:38.400 --> 08:09:41.840
            all the providers that are registered. So what we're doing is just make making sure that event

            08:09:41.840 --> 08:09:46.400
            grid is turned on because that one's not always turned on by default. And just make sure that it's

            08:09:46.400 --> 08:09:50.720
            registered. Okay, so you'll know that it's registered because it'll have a green check

            08:09:50.720 --> 08:09:56.400
            mark here, it'll say registered. And so once that is done, we can proceed to create a storage account,

            08:09:56.400 --> 08:10:02.560
            because we're going to integrate a storage account into our event grid. So what we'll do is create a

            08:10:02.560 --> 08:10:08.320
            new storage account. And we're going to create a new resource group, I'm going to call this resource

            08:10:08.320 --> 08:10:18.960
            group, event grid basics. And we're going to name our storage account event, event grid basics.

            08:10:21.680 --> 08:10:24.800
            All right. And yes, you can have hyphens, you can't have anything else.

            08:10:24.800 --> 08:10:28.400
            And we'll just make sure we spelt that right event.

            08:10:28.400 --> 08:10:34.800
            Event grid basics, I can't remember if these are fully qualified domains, if they are, you might

            08:10:34.800 --> 08:10:40.080
            have to add some numbers on the end there. But it is what it is. We're doing us East, I mean,

            08:10:40.080 --> 08:10:44.560
            it just randomizes every time. But this is where you should probably set it to. We have standard

            08:10:44.560 --> 08:10:49.200
            premium, we'll leave it as standard. And everything else seems fine. So we'll go ahead and create

            08:10:49.200 --> 08:10:54.640
            review, and create, and then it's going to allow us to review, we'll go ahead and hit Create.

            08:10:54.640 --> 08:11:00.480
            And it's going to create the resource group here, we'll just wait for it to finish deploying. And

            08:11:00.480 --> 08:11:05.040
            then we'll go into the resource. Alright, looks like it is finished deploying. So we're going to

            08:11:05.040 --> 08:11:08.080
            go ahead and go to that resource, we're going to go to containers, and we're gonna have to create

            08:11:08.080 --> 08:11:12.320
            a couple containers. The first is the first one is going to be called basic, we're going to leave it

            08:11:12.320 --> 08:11:17.680
            as private, just make sure it's basic, not basics. And we'll create another container called basic

            08:11:17.680 --> 08:11:22.160
            all the idea is that we're going to use an event grid in order to move one file from one storage

            08:11:22.160 --> 08:11:27.280
            account to another. And that's going to be facilitated by large via a logic app, because

            08:11:27.280 --> 08:11:32.720
            that's going to be the easiest way to use event grid. So what I want you to do is search for

            08:11:32.720 --> 08:11:38.240
            logic apps up here. And we're going to go ahead and add a new logic app.

            08:11:38.240 --> 08:11:45.600
            And what we want to do is choose our resource group. And we'll just go event grid basics here,

            08:11:46.720 --> 08:11:50.560
            we are going to name this event grid basics.

            08:11:50.560 --> 08:12:00.160
            Maybe we'll do LG to indicate that it is a logic app or LG, maybe l Yeah, LG is fine,

            08:12:00.160 --> 08:12:05.680
            like short for logic. And from here, we have a workflow or Docker container, we're going to stick

            08:12:05.680 --> 08:12:12.880
            with a workflow. Just to knock on wood, we're going to just put in the same region as our

            08:12:13.440 --> 08:12:18.400
            storage account. So each us, we have standard consumption, I'd rather do consumption for this.

            08:12:18.400 --> 08:12:23.920
            So you pay only as much as you use, because we don't need enterprise level service application

            08:12:23.920 --> 08:12:29.120
            here, we just need a consumption model, we're going to leave this to disable. So that is totally

            08:12:29.120 --> 08:12:35.680
            fine. There's nothing else to do here. So we'll go review plus create. And we'll go ahead and

            08:12:35.680 --> 08:12:42.720
            create this logic app. And we just have to wait for this to finish deploying. Alright, so that

            08:12:42.720 --> 08:12:47.600
            should have been very, very quick, like under 10 seconds there. So we've gone into the resource,

            08:12:47.600 --> 08:12:52.880
            I just click go to the resource. And so we have this very fun interface. And so what we need to

            08:12:52.880 --> 08:12:56.960
            do is start with a common trigger, there's a few different ways to get to it. But there should be

            08:12:56.960 --> 08:13:05.920
            something on the front here. I don't know if they redesigned this recently. So I'm just going to

            08:13:05.920 --> 08:13:12.560
            search start with a common trail. Yeah, it's up here. Okay, I'm being silly. And so what we want

            08:13:12.560 --> 08:13:18.160
            to do is, because this is an event grid, follow along, we want to click on when an event grid

            08:13:18.160 --> 08:13:24.640
            occurs. And so this is the designer where we can make things a lot easier for ourself. And so we're

            08:13:24.640 --> 08:13:29.680
            gonna have to first sign in to authenticate sign, this is my tenant example, training, Inc. So we'll

            08:13:29.680 --> 08:13:36.400
            go ahead and get connected there. Just give it a moment. We'll select Andrew Brown, which is totally

            08:13:36.400 --> 08:13:43.120
            fine. And now that is connected. So that is great. So once we are signed in, we click Continue. And

            08:13:43.120 --> 08:13:52.480
            we're going to go ahead and select our subscription here. And we need to choose a resource here. So

            08:13:53.040 --> 08:14:00.800
            I guess in this case, it's going to be event grid. event grid. Or

            08:14:00.800 --> 08:14:11.600
            because for Yeah, yeah, I think that's what we want to do. Let me just double check here. Oh,

            08:14:11.600 --> 08:14:15.760
            you know what, it's just not it for some reason. I'm, I'm searching. It's not auto completing

            08:14:15.760 --> 08:14:21.920
            properly. Okay. I just wasn't sure there. And as far as I can remember, this would be probably

            08:14:21.920 --> 08:14:29.040
            an event grid topic. And then we need to give this a resource name. So

            08:14:29.040 --> 08:14:37.520
            let me just think about this for a moment. Okay. Alright, so I think I understand where my

            08:14:37.520 --> 08:14:41.680
            confusion was, it was because we click Continue. And I never I didn't see event grid anymore. So

            08:14:41.680 --> 08:14:45.280
            I thought we had to configure it when it was already configured. Right. So this is where we

            08:14:45.280 --> 08:14:49.760
            were. So we're not we at this stage, like event grids already hooked up, so it's ready to be

            08:14:49.760 --> 08:14:54.400
            triggered. So this is the step that follows into it, which is where we want to do our storage

            08:14:54.400 --> 08:15:01.200
            account. So that's where I was getting confused. So we'll choose our subscription here. It's okay,

            08:15:01.200 --> 08:15:05.360
            you know, if you ever get confused, just step, step back a couple steps and just double check

            08:15:05.360 --> 08:15:13.760
            what you're doing happens to me all the time. So what we want to do is actually connect storage,

            08:15:13.760 --> 08:15:19.840
            storage accounts. So we type in storage accounts here. Great. We'll have that selected. And then

            08:15:19.840 --> 08:15:25.040
            we need to select our storage account. So this one's called event grid basics. And then we're

            08:15:25.040 --> 08:15:31.520
            gonna have to enter in some additional information event type. So we want to have it happen when we

            08:15:31.520 --> 08:15:36.080
            add something to the container. So the basic container, so we'll do blob created.

            08:15:36.080 --> 08:15:41.600
            And then from there, we need to actually filter out the information. So we need to add a new

            08:15:41.600 --> 08:15:46.240
            parameter. And I think we'll have to do it on the prefix filter. So a filter like whatever. Yeah,

            08:15:46.240 --> 08:15:51.600
            so that's probably a good idea. Because then we could place it into a particular place. And I

            08:15:51.600 --> 08:16:02.160
            believe that there are very specific filters that you can do for this. Because if I recall,

            08:16:02.160 --> 08:16:08.160
            there's like standardized ones. Yeah, see here, like it's always going to be forward slash blob

            08:16:08.160 --> 08:16:12.320
            services, default containers, etc. And you'll know that because you know, if you read the

            08:16:12.320 --> 08:16:15.840
            documentation, and you have to do that stuff, you'll figure that out. So I'm just going to type

            08:16:15.840 --> 08:16:22.160
            it by hand here blob services, default containers, and then we can put our container name. So basic,

            08:16:22.160 --> 08:16:31.120
            I believe we have it without the s there. So services, see, I don't trust my writing here.

            08:16:31.120 --> 08:16:39.760
            So I'm just going to copy paste it in. Okay, and that looks good to me. So I think that is

            08:16:39.760 --> 08:16:45.440
            what it needs to be. So we'll go ahead and hit the next step. So the idea is anything in that folder,

            08:16:45.440 --> 08:16:51.040
            like when something's added that folder, then follow up with this operation, right.

            08:16:55.200 --> 08:17:01.680
            And maybe before we do that, we should probably, you know, observe that this stuff works,

            08:17:01.680 --> 08:17:06.080
            that's probably a good idea. So what I'm going to do here is I'm going to make my way back over to

            08:17:06.080 --> 08:17:09.360
            our storage account. So we'll just close this tab here, I'm gonna open a new tab.

            08:17:09.360 --> 08:17:16.160
            And we're gonna make our way over to storage accounts. And we'll go to event grid basics.

            08:17:16.160 --> 08:17:23.360
            And we will go to containers. And we'll click into our basic container, because I want to just see

            08:17:23.360 --> 08:17:29.040
            that this is working. And I'm going to need a file to upload. So let me just go grab an image

            08:17:29.040 --> 08:17:33.600
            really quick. Alright, so I just grabbed an image off the internet. So I just have data here. But

            08:17:33.600 --> 08:17:38.080
            before we upload, we probably should save what we have, because if we don't save it, we're not gonna

            08:17:38.080 --> 08:17:41.920
            be able to observe it. So I went back to logic app, and we just hit Save in the top left corner.

            08:17:41.920 --> 08:17:48.800
            So we'll give it a moment to save. And it looks like it's saved. Now I'm just gonna go back over

            08:17:48.800 --> 08:17:55.040
            to here. If we can look at some of the code that gets executed, I'm just trying to remember

            08:17:55.040 --> 08:18:02.400
            where it is, because once it executes, we want to see what happened, right. So what I'll do is I'm

            08:18:02.400 --> 08:18:06.160
            going to go all the way back over here. And I'm just going to go and drag or actually I'll hit

            08:18:06.160 --> 08:18:10.720
            the upload button. So I don't trust that that there and I'll drag it onto here. Nope, I still

            08:18:10.720 --> 08:18:14.960
            don't trust it. So what I'm going to do is just click the files. And I'm just going to grab it

            08:18:14.960 --> 08:18:23.360
            this way and say open and we'll do upload. And so that is now uploaded. And so there is somewhere

            08:18:23.360 --> 08:18:30.560
            where we can observe where stuff has happened. So I'm just trying to remember where it is.

            08:18:30.560 --> 08:18:40.400
            I mean, we could run the trigger. We Yeah, we probably should run the trigger, right?

            08:18:42.560 --> 08:18:50.000
            Run.

            08:18:50.000 --> 08:18:56.320
            I think it's running. So we'll just give it a moment. Okay.

            08:18:56.320 --> 08:19:01.440
            You know, I was thinking about it, it doesn't make sense, we shouldn't have to run it,

            08:19:01.440 --> 08:19:06.560
            because it should just happen automatically. I think it's on the overview page. Ah, okay. So

            08:19:07.440 --> 08:19:12.880
            if we look here, we can see the run history. And so and there's also trigger history of when the

            08:19:12.880 --> 08:19:16.160
            things are triggered. So we could we could manually fire it, but doesn't make sense. So

            08:19:16.160 --> 08:19:20.880
            I think this is the run that we just did. If we click into here. Yes, this is what it is. So here

            08:19:20.880 --> 08:19:26.080
            we can see what what has happened. So if we expand it, we can see the inputs, right? So it's we have

            08:19:26.080 --> 08:19:34.000
            a blob created. It might show some information. So here we can see data. Yep. And it's a web P file.

            08:19:34.000 --> 08:19:37.840
            And so it's gotten this far through. And so that's a great way to kind of like debug. So you can

            08:19:37.840 --> 08:19:43.840
            logic run app, you can do it each step. But right now we are using event grid to do that integration,

            08:19:43.840 --> 08:19:50.240
            right? If we're just doing through logic, logic app, because it's a lot easier. So now that we

            08:19:50.240 --> 08:19:55.920
            have that, what we should do is go back to our designer. And we're going to have to add the

            08:19:55.920 --> 08:20:02.800
            follow up step. So we have this. Oh, yeah. Okay. So that's the first step event grid doesn't show

            08:20:02.800 --> 08:20:08.080
            up there, which is weird. But so we have this step here from our storage account. And so the next step,

            08:20:08.080 --> 08:20:14.880
            what we want to do is put it into another container. So that will be the tricky part.

            08:20:14.880 --> 08:20:22.000
            So I'm just trying to remember what we do. So we'll hit next step. And

            08:20:22.000 --> 08:20:31.120
            I think what we need to do is initialize a variable first, because we're going to have to

            08:20:31.120 --> 08:20:37.600
            get some way to grab the name of the string. Because if we go back to our run over here,

            08:20:37.600 --> 08:20:44.080
            just give it a moment here. And we go into a run again here,

            08:20:44.080 --> 08:20:50.400
            where we need to extract some data to pass along, because there are some limitations in

            08:20:50.400 --> 08:20:56.240
            terms of how JSON gets passed along, or data gets passed along. And so what we want is we just want

            08:20:56.240 --> 08:21:02.320
            this part of the name, we want to say, take this name as the identifier, so that when we're copying

            08:21:02.320 --> 08:21:07.200
            stuff over, it will work. And so what we'll have to do is store that into an intermediate variable.

            08:21:07.200 --> 08:21:23.040
            So we'll just type in variables here. And I'm just seeing Oh, yeah, so they look like this,

            08:21:23.040 --> 08:21:25.760
            because I can remember they might be in the built in. Yeah, that looks a lot better.

            08:21:25.760 --> 08:21:32.960
            And so we need a variable, and it's initialized variable. And we're gonna name this file name.

            08:21:32.960 --> 08:21:41.520
            And this is a string, of course. And now we need to insert the value. So in here, what we need to

            08:21:41.520 --> 08:21:48.000
            do is write an expression in order to extract that information out. So what we'll do is go to the

            08:21:48.000 --> 08:21:52.960
            expression tab. And over here, you can see we have all sorts of expressions that we can use. So I

            08:21:52.960 --> 08:22:00.160
            type in last parentheses, and then in there, we'll do split parentheses. And then what we're looking

            08:22:00.160 --> 08:22:12.160
            for is trigger body. And then we'll do question mark, square braces, single quotations, subject,

            08:22:12.160 --> 08:22:18.960
            how did I know how to do that? I looked it up, I looked it up somewhere. And you know, I just don't

            08:22:18.960 --> 08:22:24.080
            feel like there's much reason to teach this part. Because you mean, if you really need to know,

            08:22:24.080 --> 08:22:28.720
            you can go here and learn all about it. But a lot of times, like if you need something,

            08:22:28.720 --> 08:22:32.960
            you can just say, I need this kind of function, somebody has already done it, right? Because

            08:22:32.960 --> 08:22:37.280
            there's so many common use cases. So I probably searched something like, how do I get the name

            08:22:37.280 --> 08:22:43.040
            out of the thing, you know, like for the blob, and somebody had that there. But it makes sense to me.

            08:22:43.040 --> 08:22:47.840
            So let's hit OK here. And it should turn purple, because it is a dime expression. If you type it

            08:22:47.840 --> 08:22:51.920
            in here, it probably won't work correctly, you have to type it in here and then hit OK. So it

            08:22:51.920 --> 08:22:57.200
            shows up like that. But you notice we typed in like trigger body. So if we go back over to our

            08:22:57.200 --> 08:23:03.680
            run here, is the body here. So when I say trigger body, they're talking about here. And then it was

            08:23:03.680 --> 08:23:10.160
            just grabbing that subject line there. All right. So that would be the second step. And that gets

            08:23:10.160 --> 08:23:17.520
            it into a variable. But the next part is we need to actually get the blob content and then insert

            08:23:17.520 --> 08:23:21.920
            it and then create a new blob. So what we'll do is hit next step. And we'll type in blob and see if

            08:23:21.920 --> 08:23:35.040
            we can find anything here. And from here, we need to get the get blob content using path version two.

            08:23:35.040 --> 08:23:39.200
            So I'm just gonna scroll down here and take a look for it. There it is,

            08:23:39.200 --> 08:23:50.240
            based on the path. And we'll go down here and I guess it would be access key. Oh, because we're

            08:23:50.240 --> 08:23:57.680
            setting up a connection for the first time. So enter name for connection.

            08:23:57.680 --> 08:24:06.800
            I know what the storage account is. But what is the connection connection name? I do not remember

            08:24:06.800 --> 08:24:10.960
            give me two seconds. Okay. There wasn't much to help me here. Because what I remembered before

            08:24:10.960 --> 08:24:14.480
            was that you click it and you'd authenticate it like the event grid, but it's not doing that. So

            08:24:14.480 --> 08:24:19.120
            maybe we just have to name it something. So I don't know, we'll just say Azure storage account,

            08:24:19.120 --> 08:24:25.760
            maybe just wants a name. Maybe it doesn't really matter. Oh, yeah, like their sign in.

            08:24:25.760 --> 08:24:33.840
            That's what I want. So connection name. Yeah. So we'll say, you know, storage account event grid.

            08:24:33.840 --> 08:24:40.160
            Okay. Because if we can just single sign on, let's do that. That's super easy.

            08:24:40.160 --> 08:24:44.560
            And we'll click that there.

            08:24:47.040 --> 08:24:52.560
            Okay, so this is starting to look how I expected to look. And so we need the storage account name,

            08:24:52.560 --> 08:24:58.560
            I don't know why it's not showing me any names here. But that's okay, we'll just go over back

            08:24:58.560 --> 08:25:05.040
            to our storage account here. And it's called event grid basics. So we'll type in event grid basics.

            08:25:05.040 --> 08:25:11.600
            Event grid basics.

            08:25:16.320 --> 08:25:21.600
            That's custom value. Sure. I mean, that's what its name is. I'm not sure why it's not auto

            08:25:21.600 --> 08:25:28.000
            completing. But here, what we need to do is we need to provide the path. So it's going to be

            08:25:28.000 --> 08:25:33.520
            basic. And so now there's our environment or that variable. So we'll just click that there.

            08:25:33.520 --> 08:25:40.720
            So that will make it super, super easy. Now notice that it is showing basic now. So I just

            08:25:40.720 --> 08:25:44.960
            clicked here the folder, we typed it in manually, but we could have clicked here and then put the

            08:25:44.960 --> 08:25:50.160
            environment variable in or the this this initialized variable in here. But I did type that

            08:25:50.160 --> 08:25:55.600
            manually. And it still did work correctly. So we are okay here and for the content type. Sure, why

            08:25:55.600 --> 08:26:02.720
            not? It doesn't matter if they do. So this gets the content. So now this gets the path. And so the

            08:26:02.720 --> 08:26:07.680
            next thing is actually to create the blob. You can't like do an easy clone, you have to do it

            08:26:07.680 --> 08:26:14.400
            this intermediate step. That's just how it works. And so what we'll need to do is go to our built

            08:26:14.400 --> 08:26:24.800
            in ones here, we'll type in a blob again, maybe standard. And this time, we want to create a blob.

            08:26:24.800 --> 08:26:34.960
            So there it is. Block blob, no, we just want a blob. And so what we'll do is, I guess we have

            08:26:34.960 --> 08:26:38.960
            to connect again. I'm surprised it's not showing the name. Yeah, it's just the name. That's fine.

            08:26:38.960 --> 08:26:45.200
            So we'll go back over here. I just don't want to type it wrong. So we'll just copy paste it in

            08:26:45.200 --> 08:26:52.080
            event grid basics. Then grid basics, enter custom value because it's giving us so much trouble for

            08:26:52.080 --> 08:26:55.840
            no particular reason. Make sure there's no space on the end there. There now works fine.

            08:26:55.840 --> 08:27:04.640
            And in this case, what we want is basic alt. And the blob name can be the file name,

            08:27:04.640 --> 08:27:12.160
            which is totally fine. And the blob content will be the file content. And I don't think we need

            08:27:12.160 --> 08:27:18.000
            anything else. So what we'll do is go ahead and click off. And we will save.

            08:27:18.000 --> 08:27:23.280
            Alright, so that's just the way we're going to have to do it.

            08:27:23.280 --> 08:27:32.080
            So what we can do is go back to our overview. And we'll go back to our basic folder.

            08:27:33.680 --> 08:27:36.400
            And we'll delete data. Say okay.

            08:27:36.400 --> 08:27:43.200
            And we'll go upload. We'll select our file again, we'll grab it,

            08:27:43.200 --> 08:27:49.440
            we will upload and then we will make our way back over to our logic app.

            08:27:49.440 --> 08:27:58.560
            Close this tab here so we don't get too mixed up. Refresh the page. And it failed. So it failed for

            08:27:58.560 --> 08:28:04.240
            some reason. So something has not been configured correctly. It failed on the initialized variable.

            08:28:04.240 --> 08:28:08.720
            So something's wrong there. So unable to process the template language expression in the actions

            08:28:08.720 --> 08:28:14.080
            initialized variable inputs at line zero column zero, template function split is not defined is

            08:28:14.080 --> 08:28:19.200
            not valid. So it's possible I just spelt it wrong. So what we'll do is go back to our event grid,

            08:28:19.200 --> 08:28:24.640
            we'll go back to our logic app designer here, initialize variable, we will click it.

            08:28:26.000 --> 08:28:30.880
            And we probably just spelt it wrong. spilt.

            08:28:30.880 --> 08:28:38.000
            spilt, what if we do li t spilt, split.

            08:28:38.000 --> 08:28:43.360
            So if that's wrong, we'll just scroll on down and we'll just take a look.

            08:28:43.360 --> 08:28:48.960
            I could have swore that auto completed for us.

            08:28:53.440 --> 08:28:59.840
            Oh, you know what it is spelled wrong, it should be SPI li t split. All right.

            08:28:59.840 --> 08:29:03.840
            And I'm just double checking to see if there's any other problems here.

            08:29:03.840 --> 08:29:09.600
            Nope, looks fine to me. So go ahead and say update, we will save it in the top left corner.

            08:29:09.600 --> 08:29:12.800
            We'll go back, we'll delete our file here, we'll say okay.

            08:29:12.800 --> 08:29:19.360
            And we'll have to select a new file. We'll click open, just double check, make sure that's been

            08:29:19.360 --> 08:29:23.440
            saved. It looks like it's been saved, we'll hit upload, we'll go back to our overview page.

            08:29:23.440 --> 08:29:29.520
            It's already running super fast, by the way. And we'll click into it. And we'll see if we get any

            08:29:29.520 --> 08:29:35.360
            other failure. So there's another failure, that's totally okay. So we'll just expand it. This request

            08:29:35.360 --> 08:29:40.640
            is not authorized to perform this operation using the permissions. So does not like the

            08:29:40.640 --> 08:29:46.560
            permissions I gave it. Totally fine. So we will go back to our app designer.

            08:29:48.000 --> 08:29:52.720
            We will go to this second step here, even though it did select this properly.

            08:29:52.720 --> 08:29:58.480
            So we'll change the connection. I guess we'll add a new one.

            08:29:58.480 --> 08:30:07.200
            So we did ad integrated. Let's do managed identity, you must enable managed identities

            08:30:07.200 --> 08:30:09.840
            and logic app to use managed identities authentication, you must grant

            08:30:09.840 --> 08:30:14.640
            required access to the identity and the target resource.

            08:30:16.960 --> 08:30:22.000
            Okay. There is an identity tab. So we can go over there and take a look there quickly.

            08:30:22.000 --> 08:30:27.440
            I don't remember it being that hard to do. system assigned managed identities restricted to one

            08:30:27.440 --> 08:30:32.000
            person, one person resource is tied to lifecycle, you can grant permissions, etc, etc.

            08:30:32.000 --> 08:30:37.120
            Can we just turn that on and hit save?

            08:30:37.120 --> 08:30:43.680
            Well, it can be granted access to resources protected by a zip. Sure, let's give it a go.

            08:30:43.680 --> 08:30:55.760
            All right, so it seems like we have to assign some role stuff.

            08:30:55.760 --> 08:31:08.240
            So we can try and assign a role. Can we do the subscription level? contributor? Okay.

            08:31:10.560 --> 08:31:13.360
            So there's a few different ways you can authenticate. So hopefully,

            08:31:13.360 --> 08:31:19.440
            this will be the easiest way to do it. We'll refresh here to design it.

            08:31:33.200 --> 08:31:42.000
            And I don't think it said it. All right, so give me a moment. And let me see what I can figure out.

            08:31:42.000 --> 08:31:47.360
            Okay. You know, just to make this easier, I think what we should do is just do the access key,

            08:31:47.360 --> 08:31:51.600
            because that seems like the easiest way to do it. I was just hoping that we could have, you know,

            08:31:51.600 --> 08:31:55.920
            just did a simple sign in here, but it's not a big deal. So we'll hit change connection,

            08:31:55.920 --> 08:32:07.920
            we're going to add a new connection, just a storage account, event, event grid key. And so

            08:32:07.920 --> 08:32:13.680
            this is going to want the Azure storage account name. So this one will be the name of the storage

            08:32:13.680 --> 08:32:21.600
            account, if we can find it called event grid basics. And then we need the Azure storage account

            08:32:21.600 --> 08:32:30.800
            access key. So there's probably a tab called keys. Yep. And we will show the key and we will copy the

            08:32:30.800 --> 08:32:39.920
            key. If I don't have to pass along keys, I like to not do that. Please check your account info.

            08:32:39.920 --> 08:32:44.480
            Again, storage account access key should be a correct base 64 encoded string. Come on,

            08:32:44.480 --> 08:32:51.680
            give me a break here. I am doing what you asked me to do. So we will try this again.

            08:32:51.680 --> 08:33:04.960
            This thing just hates me today. Give me a second. Okay. You know what, it was really short. So I

            08:33:04.960 --> 08:33:08.880
            really don't trust it. So let's just do I just cleared it out there. I didn't do anything else.

            08:33:08.880 --> 08:33:15.440
            What we're going to do is go back here, click the copy, and then right click and paste. That's so

            08:33:15.440 --> 08:33:22.080
            much longer. Okay, that has to be the right key. Well, I create and we'll give it a moment.

            08:33:22.080 --> 08:33:31.200
            Okay, great. So that's for that one. But this has to have the right connection as well. So

            08:33:31.200 --> 08:33:38.320
            what we'll do is just change the connection. You have a few here. And the one we want is

            08:33:38.720 --> 08:33:45.520
            the one that's valid. So we'll go this one down below, as you can see a few attempts here.

            08:33:45.520 --> 08:33:53.600
            And we'll save it. And we'll go back to our overview here. I'm just gonna close that tab

            08:33:53.600 --> 08:33:58.640
            out. We're gonna close this out. We're gonna go back into here, we're gonna go into our containers,

            08:33:58.640 --> 08:34:02.960
            we're going to go into our basic, we're going to go ahead and delete this, we'll say okay.

            08:34:05.280 --> 08:34:10.240
            And we will upload a new file, we will choose the new file, we'll choose data,

            08:34:10.240 --> 08:34:19.040
            upload it. We'll go back over here. And I want to see the latest run here. Give us a refresh.

            08:34:19.040 --> 08:34:26.560
            Is it running? It looks like it's running. It's hard because this one looks like it just failed.

            08:34:26.560 --> 08:34:32.640
            And and now the the messaging is getting really muddy here. What is it doing? So we'll click off

            08:34:32.640 --> 08:34:36.720
            here. Sometimes the portal is a bit funny. Is it just triggering over and over again?

            08:34:36.720 --> 08:34:45.040
            Did we make an infinite loop? Oh, okay, I think we have a problem here.

            08:34:45.040 --> 08:34:55.920
            Well, if we go here, is it basic or basic? It's basic alt. This one's basic. So what's the problem?

            08:34:57.840 --> 08:35:03.680
            We'll refresh. Failed. Why did it fail?

            08:35:03.680 --> 08:35:14.800
            Conflict. Another active upload session exists, please retry after some time. Okay.

            08:35:14.800 --> 08:35:22.960
            Well, let's just go take a look here. Go back. It's here. So it's it's here.

            08:35:24.320 --> 08:35:30.960
            So clearly has worked why it's triggering multiple times. I don't know. Don't particularly like that.

            08:35:30.960 --> 08:35:38.160
            We're gonna just go ahead and delete this one here. It's just it's just going over and over

            08:35:38.160 --> 08:35:41.920
            and over again. So there's something wrong with my workflow.

            08:35:42.320 --> 08:35:44.960
            So this looks fine to me. That looks fine to me.

            08:35:44.960 --> 08:36:06.560
            Maybe it's triggering Oh, you know what the parameters out of here. So this is supposed

            08:36:06.560 --> 08:36:12.720
            to have a prefix here. So what's happening is that it's triggering on any time a basic one

            08:36:12.720 --> 08:36:16.960
            is set up or basic alt one, and it's just stuck in an infinite loop, which is really, really bad.

            08:36:16.960 --> 08:36:23.520
            So we did do this earlier, but for whatever reason, the changes still are not here.

            08:36:23.520 --> 08:36:32.720
            So what we'll need to do is set up that prefix. So what we'll do is type in blob services, default,

            08:36:34.320 --> 08:36:41.600
            containers. Basic, because we really don't want to trigger it on a but that that container there.

            08:36:41.600 --> 08:36:51.920
            And did it save it? It doesn't look Yeah, I mean, it should be there. So what we'll do is go ahead.

            08:36:51.920 --> 08:36:55.920
            Like, why is it not filtering?

            08:37:00.400 --> 08:37:03.040
            Oh, I guess it wants to filter based on name.

            08:37:03.040 --> 08:37:17.440
            But we gave it its name. So I'm not sure what else we would have to type there. Okay.

            08:37:17.440 --> 08:37:28.880
            I'm just going to put dot. It's the prefix filter. So data, I guess, I don't know, like,

            08:37:29.840 --> 08:37:32.160
            it's not letting me save. Okay, there we go. So we'll save that.

            08:37:32.160 --> 08:37:35.360
            I just want to stop the infinite loop there for a moment.

            08:37:35.360 --> 08:37:45.280
            So go back over to the overview. And we'll just make sure we're not running up our bill here.

            08:37:45.280 --> 08:37:50.000
            I'm just refreshing, I just want to see that's not triggering anymore. So it stopped triggering,

            08:37:50.000 --> 08:37:56.080
            which is good. And we'll go back over to here. And we'll look at this prefix filter, because I

            08:37:56.080 --> 08:38:02.000
            don't remember having to do that. So a filter like sample, etc, etc. So we'll type it in again,

            08:38:02.000 --> 08:38:07.920
            I guess, blob services, defaults, containers, basic.

            08:38:07.920 --> 08:38:20.000
            It's very odd, because like, we typed it. Oh, you know what I probably did, I typed in the

            08:38:20.000 --> 08:38:23.120
            filter parameter here, we're supposed to add it, then put it in there. So it's just me getting

            08:38:23.120 --> 08:38:30.080
            confused by the UI. Silly me. Okay, so what we'll do is go back to the overview. And this time,

            08:38:30.080 --> 08:38:34.160
            we just want to see trigger once. So go back to basic all, we'll go ahead and delete this,

            08:38:34.160 --> 08:38:41.280
            we'll say okay. And we'll go back to our event grid, we'll go in our event grid, our basic,

            08:38:41.280 --> 08:38:46.720
            our basic container, we're going to go ahead and delete data here again. And we're going to go

            08:38:46.720 --> 08:38:52.240
            upload one more time. It's actually good that we had that problem, because I got to show you

            08:38:53.120 --> 08:39:00.480
            why filters are so important when we're dealing with the app logic there, or logic apps. So we'll

            08:39:00.480 --> 08:39:04.800
            go ahead and hit upload, we'll go make our way back over here, we're going to give this a refresh.

            08:39:04.800 --> 08:39:10.320
            And now we have a new one. And it only happened once. And that's what we wanted to happen. So

            08:39:10.320 --> 08:39:17.120
            we'll go back over to here. And we go to basic alt. There it is. So that's a means to which we

            08:39:17.120 --> 08:39:22.160
            can use event grid to integrate stuff. You can see logic app is extremely useful for developers,

            08:39:22.160 --> 08:39:28.720
            building all sorts of tools. But we are all done here. And what we'll do is make our way over to

            08:39:28.720 --> 08:39:33.760
            our resource group. And we are going to just go ahead and clean up. So we'll go into event grid

            08:39:33.760 --> 08:39:45.360
            basics. And we'll go ahead and delete this resource group. There we go. And it's going to go ahead

            08:39:45.360 --> 08:39:58.880
            and delete there. Yeah, and there you go. Hey, this is Andrew Brown from exam Pro. And in this

            08:39:58.880 --> 08:40:04.400
            section, we'll be covering Azure Event Hub. Azure Event Hub serves as a critical component for event

            08:40:04.400 --> 08:40:09.360
            ingestion capable of consuming millions of events from myriad sources and processing them in real

            08:40:09.360 --> 08:40:14.080
            time or via micro batching. It's potent auto inflate feature automatically scales throughput

            08:40:14.080 --> 08:40:18.800
            units to accommodate varying demands ensuring seamless processing even during traffic spikes.

            08:40:18.800 --> 08:40:23.840
            Notably, Azure Event Hub offers seamless integration with Apache Kafka applications

            08:40:23.840 --> 08:40:29.520
            and clients bridging the capabilities of both platforms. Azure Event Hub helps you build your

            08:40:29.520 --> 08:40:34.480
            big data pipeline to analyze logging anomalies user and device telemetry where you only pay for

            08:40:34.480 --> 08:40:40.000
            what you use. Breaking down the key concepts of Azure Event Hub. namespace is an endpoint for

            08:40:40.000 --> 08:40:44.800
            receiving and distributing events to event hubs. Event Hub is where your events will be delivered.

            08:40:44.800 --> 08:40:52.080
            Event Hub cluster is a dedicated event hub with a 99.99% SLA. Event Hub capture allows you to

            08:40:52.080 --> 08:40:57.680
            automatically capture and save streaming events. Events hubs for Apache Kafka event hub and points

            08:40:57.680 --> 08:41:03.440
            are compatible with Apache Kafka. Event publishers or applications or services that publish events to

            08:41:03.440 --> 08:41:09.840
            an event hub. Publisher policy is a unique ID used to identify publishers. partitions are used to

            08:41:09.840 --> 08:41:15.360
            organize the sequence of events in an event hub. Event consumers or applications or services that

            08:41:15.360 --> 08:41:20.400
            read events from an event hub. Consumer group enable consuming applications to each have a

            08:41:20.400 --> 08:41:25.520
            separate view of the event stream. Stream offset holds the position of an event inside a partition.

            08:41:25.520 --> 08:41:29.840
            Checkpointing is the process of distinguishing between read and unread events.

            08:41:29.840 --> 08:41:36.640
            Diving into scaling with Azure Event Hub. Auto inflate a dynamic feature that enables automatic

            08:41:36.640 --> 08:41:42.000
            scaling up to the pinnacle of to use predicated on traffic exigencies. However, it's worth noting

            08:41:42.000 --> 08:41:47.360
            that this feature is not accessible within the basic pricing tier. The image showcases various

            08:41:47.360 --> 08:41:53.280
            configuration options related to Azure Event Hub. Pricing tier the standard tier is selected price

            08:41:53.280 --> 08:41:58.560
            at approximately $22 USD per throughput unit monthly. Other plans can be browsed for more

            08:41:58.560 --> 08:42:04.240
            features. throughput units the selected number is one in Azure Event Hub throughput units dictate

            08:42:04.240 --> 08:42:09.920
            the events process per second and related data volume. Auto inflate maximum throughput units the

            08:42:09.920 --> 08:42:14.160
            maximum number of throughput units that can be scaled to using the auto inflate feature is set

            08:42:14.160 --> 08:42:24.400
            to 12. The next topic we'll be covering are the pricing tiers for Azure Event Hub plans and their

            08:42:24.400 --> 08:42:31.200
            key features. Basic plan cost one cent divided by hour for every throughput unit data input charges

            08:42:31.200 --> 08:42:36.960
            two cents for every million events storage holds up to 84 gigabytes of data data whole time keeps

            08:42:36.960 --> 08:42:42.720
            data for only one day does not offer capture Apache Kafka schema registry or extended retention

            08:42:42.720 --> 08:42:50.080
            standard plan cost three cents divided by hour per two data input same cost is basic two cents per

            08:42:50.080 --> 08:42:56.560
            million events capture available at an additional $73 divided by month for each to storage same as

            08:42:56.560 --> 08:43:03.280
            basic 84 gigabytes data whole time keeps data for seven days offers Apache Kafka and schema registry

            08:43:03.280 --> 08:43:11.280
            however it lacks extended retention. Previum plan cost a bit pricier at $1.23 divided by hour but

            08:43:11.280 --> 08:43:16.880
            now it's for every processing unit data input included in the plan no extra cost capture

            08:43:16.880 --> 08:43:22.560
            included as well storage a lot more space with one terabyte for each poo data whole time retains

            08:43:22.560 --> 08:43:28.080
            data for a longer 90 days offers Apache Kafka schema registry and also has extended retention

            08:43:28.080 --> 08:43:36.080
            at 12 cents GB month with one terabyte already included dedicated plan cost the highest at $6.84

            08:43:36.080 --> 08:43:42.400
            divided by hour for each capacity unit data input included in the plan no extra cost capture also

            08:43:42.400 --> 08:43:48.640
            included storage huge space with 10 terabytes for each cu data whole time holds data for 90 days

            08:43:48.640 --> 08:43:54.400
            same as premium offers all the features of premium and its extended retention is also at 12 cents GB

            08:43:54.400 --> 08:44:00.320
            month but generously includes 10 terabytes terms capacity unit a measure of capacity for the

            08:44:00.320 --> 08:44:06.320
            dedicated plan processing unit a measure of capacity for the premium plan throughput unit

            08:44:06.320 --> 08:44:15.840
            a measure of capacity for both basic and standard plans. The next thing we'll be going over is the

            08:44:15.840 --> 08:44:21.200
            producer in Azure Event Hub also known as the publisher. The producer is responsible for sending

            08:44:21.200 --> 08:44:27.840
            data to the stream. Publishers can publish events using the following protocols. HTTPS the majority

            08:44:27.840 --> 08:44:36.160
            of Azure SDKs prefer HTTPS. AMQP 1.0 advanced message queuing protocol. Kafka protocol compatible

            08:44:36.160 --> 08:44:42.560
            with the Apache Kafka ecosystem. Generally developers use the Azure SDK for publishing events.

            08:44:42.560 --> 08:44:47.440
            You can publish an event either one at a time events can be published individually or batches

            08:44:47.440 --> 08:44:51.600
            multiple events can be grouped and published together. However there's a size limit of one

            08:44:51.600 --> 08:44:56.320
            megabyte for both individual and batched events. Any event or batch exceeding this limit will be

            08:44:56.320 --> 08:45:03.120
            rejected. For authorization publishers use either Azure ad with OAuth 2 issued JWT tokens or shared

            08:45:03.120 --> 08:45:12.000
            access signature. Comparison HTTPS versus AMQP for publishing events. AMQP requires the establishment

            08:45:12.000 --> 08:45:18.320
            of a persistent bidirectional socket in addition to transport level security or SSL TLS. AMQP has

            08:45:18.320 --> 08:45:23.600
            higher network costs when initializing the session. AMQP has higher performance for frequent publishers

            08:45:23.600 --> 08:45:29.440
            and can achieve much lower latencies when used with a synchronous publishing code. HTTPS requires

            08:45:29.440 --> 08:45:35.440
            additional TLS overhead for every request. Publisher policies. Event hubs enables granular

            08:45:35.440 --> 08:45:40.960
            control over event publishers through publisher policies. Publisher policies are runtime features

            08:45:40.960 --> 08:45:46.320
            designed to facilitate large numbers of independent event publishers. With publisher policies each

            08:45:46.320 --> 08:45:50.880
            publisher uses its own unique identifier when publishing events to an event hub ensuring that

            08:45:50.880 --> 08:45:55.760
            events are properly segregated authenticated and managed for each individual source enhancing

            08:45:55.760 --> 08:46:04.960
            security and traceability within the system. The next topic we'll be covering is a consumer in

            08:46:04.960 --> 08:46:10.800
            Azure event hub. The Azure event hub consumer also commonly referred to as a reader is responsible

            08:46:10.800 --> 08:46:16.240
            for receiving and processing data from the stream. Connection protocol. All event hubs consumers

            08:46:16.240 --> 08:46:21.760
            connect using the AMQP 1.0 protocol. As events become available they are delivered through the

            08:46:21.760 --> 08:46:26.480
            session. This eliminates the need for the client to continuously check or pull for the availability

            08:46:26.480 --> 08:46:32.320
            of new data. A consumer group represents a particular view like a state position or offset

            08:46:32.320 --> 08:46:37.440
            of an entire event hub. Consumer groups enable multiple consuming applications to each have a

            08:46:37.440 --> 08:46:41.680
            separate view of the event stream and to read the stream independently at their own pace and with

            08:46:41.680 --> 08:46:47.360
            their own offsets. Typically in a stream processing architecture each downstream application equates

            08:46:47.360 --> 08:46:52.160
            to a consumer group. There's always a default consumer group in an event hub and you can create

            08:46:52.160 --> 08:46:56.880
            up to the maximum number of consumer groups for the corresponding pricing tier. There can be at

            08:46:56.880 --> 08:47:01.280
            most five concurrent readers on a partition per consumer group. However it's recommended that

            08:47:01.280 --> 08:47:06.240
            there's only one active receiver on a partition per consumer group. Some clients offered by the

            08:47:06.240 --> 08:47:10.960
            Azure SDKs are intelligent consumer agents that automatically manage the details of ensuring that

            08:47:10.960 --> 08:47:15.280
            each partition has a single reader and that all partitions for an event hub are being read from.

            08:47:15.280 --> 08:47:19.600
            This allows your code to focus on processing the events being read from the event hub so it can

            08:47:19.600 --> 08:47:24.960
            ignore many of the details of the partitions. So that's an overview of a consumer in Azure Event

            08:47:24.960 --> 08:47:35.440
            Hub. Next let's talk about offsets in Azure Event Hub. In the realm of Azure Event Hub the term

            08:47:35.440 --> 08:47:40.560
            offset refers to the position of an event within a specific partition. Offsets enables a consumer

            08:47:40.560 --> 08:47:45.200
            to specify a point in the event stream from which they want to begin reading events. You have the

            08:47:45.200 --> 08:47:49.680
            option to specify the offset either as a distinct timestamp or as a numerical offset value.

            08:47:49.680 --> 08:47:54.800
            Consumers are responsible for storing their own offset values outside of the event hub service.

            08:47:54.800 --> 08:48:01.040
            Every event situated within a partition comes equipped with an offset. Azure Event Hub

            08:48:01.040 --> 08:48:05.920
            Checkpointing. Checkpointing is a process by which readers mark or commit their position within a

            08:48:05.920 --> 08:48:10.880
            partition event sequence. Checkpointing is the responsibility of the consumer and occurs on a

            08:48:10.880 --> 08:48:16.320
            per partition basis within a consumer group. The consumer is fully responsible for checkpointing.

            08:48:16.320 --> 08:48:21.360
            This means that for each consumer group every individual partition reader must monitor its

            08:48:21.360 --> 08:48:26.640
            ongoing position within the event stream and notify the event hub service once it recognizes the data

            08:48:26.640 --> 08:48:31.840
            stream to be complete or processed. So that's an overview of offsets in Azure Event Hub.

            08:48:31.840 --> 08:48:41.600
            The next topic we'll be covering is the event retention for Azure Event Hub. Published events

            08:48:41.600 --> 08:48:46.000
            are removed from an event hub based on a configurable time-based retention policy.

            08:48:46.000 --> 08:48:51.360
            The default value and shortest possible retention period is one hour. For event hub standard the

            08:48:51.360 --> 08:48:57.120
            maximum retention period is seven days. For event hubs premium and dedicated the maximum retention

            08:48:57.120 --> 08:49:02.240
            period is 90 days. If you change the retention period it applies to all messages including

            08:49:02.240 --> 08:49:06.800
            messages that are already in the event hub. It's important to note that individual events cannot

            08:49:06.800 --> 08:49:12.320
            be explicitly deleted. The reason for event hubs limit on data retention based on time is to prevent

            08:49:12.320 --> 08:49:16.640
            large volumes of historic customer data getting trapped in a deep store that is only indexed by

            08:49:16.640 --> 08:49:22.320
            a time stamp and only allows for sequential access. If you need to archive events beyond the allowed

            08:49:22.320 --> 08:49:26.720
            retention period you can have them automatically stored in Azure Storage or Azure Data Lake by

            08:49:26.720 --> 08:49:32.000
            turning on the event hubs capture feature. If you need to search or analyze such deep archives you

            08:49:32.000 --> 08:49:36.240
            can easily import them into Azure Synapse or other similar stores and analytics platforms.

            08:49:36.240 --> 08:49:40.080
            So that's an overview of event retention for Azure Event Hub.

            08:49:45.200 --> 08:49:49.280
            Let's break down a comparison between event grid, event hub, and service bus.

            08:49:49.280 --> 08:49:54.800
            Event grid, event hub, and service bus all are event driven services for application integration

            08:49:54.800 --> 08:50:00.560
            and use an event bus as means to work with event data. Azure event grid provides the backbone for

            08:50:00.560 --> 08:50:05.200
            event driven architectures without the need for infrastructure management. Azure service to

            08:50:05.200 --> 08:50:09.840
            service communication primarily designed for communication between various Azure services,

            08:50:09.840 --> 08:50:14.720
            dynamically scalable, cost efficient, and guarantees at least once delivery of an event.

            08:50:15.520 --> 08:50:21.120
            Azure event hub, streaming data ideal for ingesting massive amounts of streaming data,

            08:50:21.120 --> 08:50:26.880
            low latency processes events with minimal delay, high throughput capable of receiving and processing

            08:50:26.880 --> 08:50:32.960
            millions of events every second, and guarantees at least once delivery of an event. Azure service bus

            08:50:32.960 --> 08:50:38.800
            supports both queues and publish subscribe patterns making it suitable for a range of web applications,

            08:50:39.440 --> 08:50:44.480
            reliable asynchronous message delivery that requires polling, advanced messaging features

            08:50:44.480 --> 08:50:49.760
            like first in and first out, batching sessions, transactions, dead lettering, temporal control,

            08:50:49.760 --> 08:50:54.800
            routing and filtering, and duplicate detection, guarantees at least once delivery of a message

            08:50:54.800 --> 08:51:00.000
            and offers an optional feature to ensure messages are delivered in sequence. The breakdown highlights

            08:51:00.000 --> 08:51:04.400
            the differences between Azure's event grid, event hub, and service bus showcasing their

            08:51:04.400 --> 08:51:14.640
            unique strengths tailored to different scenarios. Hey, this is Andrew Brown from exam Pro. And this

            08:51:14.640 --> 08:51:19.680
            fall long, we are going to learn all about Azure event hub. So what I want you to do is go to the

            08:51:19.680 --> 08:51:24.800
            top here and type in event hub and we are going to create ourselves a new event hub namespace.

            08:51:24.800 --> 08:51:29.360
            So we'll go here and hit Create. And we'll create a new resource group as we always do and call it

            08:51:29.360 --> 08:51:36.480
            my event hub. And then for the namespace name, we'll say my event hub. If it doesn't let you

            08:51:36.480 --> 08:51:40.480
            do that, you'll have to put some numbers on the end. I'm just putting some numbers here because

            08:51:40.480 --> 08:51:46.080
            often these are taken up doesn't matter what location is just choose whichever one we go with

            08:51:46.080 --> 08:51:50.000
            basic because there's not a huge difference between the pricing terms in terms of feature sets

            08:51:50.000 --> 08:51:54.720
            that we want to use today. So go ahead and create this namespace. So we'll give it a moment.

            08:51:55.360 --> 08:52:00.880
            And we'll go ahead and hit Create. And then we'll just wait for this namespace to provision.

            08:52:00.880 --> 08:52:05.040
            Alright, so after waiting about a couple of minutes, there are namespaces deployed, we're

            08:52:05.040 --> 08:52:07.920
            going to go ahead and create ourselves an event hub, I'm going to call this one,

            08:52:07.920 --> 08:52:16.240
            my hub, we'll go ahead and hit Review and Create. And we'll create. And these create very, very

            08:52:16.240 --> 08:52:20.800
            quickly. So we're not gonna have to wait too long, we need to set some shared access policies here.

            08:52:20.800 --> 08:52:28.000
            So I'm going to go into the hub here, go ahead and manage I call this my SAS, SAS shared access

            08:52:28.000 --> 08:52:33.680
            policy. And there we will now have the ability to have a primary key and connection key. So we can

            08:52:33.680 --> 08:52:39.360
            actually connect to it. So what we're going to do is go to GitHub, and I want to create a new

            08:52:39.360 --> 08:52:48.560
            repository. And we'll go ahead here. And we'll go down below, go to exam Pro, we'll say, my event

            08:52:48.560 --> 08:52:54.400
            hub. That's already taken because I've done this before. So for mining, I call it new. And we'll

            08:52:54.400 --> 08:52:58.560
            go down to private, we're going to use Node JS. So let's type in Node JS, so that ignores the node

            08:52:58.560 --> 08:53:04.640
            modules, you're going to want to have Gitpod or a Visual Studio code installed on your computer,

            08:53:04.640 --> 08:53:08.640
            the easiest ways on to get pod because these environments are temporary, and it's free to

            08:53:08.640 --> 08:53:14.320
            utilize it. So if you can go get the Chrome extension, or if you don't want to install the

            08:53:14.320 --> 08:53:18.880
            Chrome extension, all you got to do is attach this to the end of the repo to launch a GitHub

            08:53:18.880 --> 08:53:25.680
            or get pod environment. So give that a moment to launch. And there we go. So I do have some code

            08:53:25.680 --> 08:53:35.680
            for this. So I'm just looking for it off screen here. And we're going to need to have a couple

            08:53:35.680 --> 08:53:40.800
            files here, we're going to need a new file called send j s. And we're going to a new file here

            08:53:40.800 --> 08:53:45.680
            called receive j s. I'm not typing the full word receive because I'm always really bad at spelling

            08:53:45.680 --> 08:53:53.120
            it. So I'm just trying to save myself some trouble. And we're also going to have to initialize a new

            08:53:53.120 --> 08:54:01.120
            package JSON file. So there we go. And we're going to have to get a couple things installed.

            08:54:01.120 --> 08:54:13.600
            Yeah, so we'll need npm install Azure event, event hubs, Azure storage, blob, Azure event hubs,

            08:54:13.600 --> 08:54:23.840
            checkpoint, store blob, save dev, and make our lives a bit easier. Looks seems like I type

            08:54:23.840 --> 08:54:30.800
            something wrong here, I'll just hit up. I forgot the forward slash here. And so we'll just go event

            08:54:30.800 --> 08:54:43.120
            hub. Azure JavaScript. Because I believe Yeah, I kind of use this one, but I modified it to make

            08:54:43.120 --> 08:54:48.400
            it a little bit easier. I think this is the one I was doing. No, I don't think so tutorial.

            08:54:51.440 --> 08:54:58.640
            Might be this one. Yeah, it looks like this. So this is just the JavaScript there. So for send,

            08:54:58.640 --> 08:55:03.600
            we will grab this code here. We're not going to do exactly the way they do it, but pretty close.

            08:55:03.600 --> 08:55:08.560
            And then there is a receive code. So go down below. And we'll grab this, as you can see,

            08:55:08.560 --> 08:55:17.200
            there's a lot going on here. That will be a receive a couple things we need to properly set.

            08:55:17.200 --> 08:55:20.800
            So these will be all environment variables. So what we'll do is go to the top here, and we'll

            08:55:20.800 --> 08:55:26.720
            just do constant process requires process that's going to allow us to import our environment

            08:55:26.720 --> 08:55:38.160
            variables. So to say, copy, save that. We'll paste that in there as well. And then this is where we

            08:55:38.160 --> 08:55:42.240
            need to replace all our environment variables. As you can see, I always have things pinging up

            08:55:42.240 --> 08:55:52.640
            on me here. So just close my teams out. And just lines to make this a little bit faster.

            08:55:52.640 --> 08:55:59.440
            So default will be what we'll keep here. This will be our storage connection string.

            08:56:01.200 --> 08:56:14.320
            Say process ENV storage connection string, then this will be process ENV container name,

            08:56:14.320 --> 08:56:26.480
            and we need process ENV event hub name. And up here, we'll have process ENV event hub

            08:56:27.440 --> 08:56:32.320
            connection string. And then we'll go over to our center here, we'll do something very similar. So

            08:56:32.320 --> 08:56:44.480
            process ENV event hub connection string. And then we'll have process in the event hub name.

            08:56:44.480 --> 08:56:49.600
            So we need to set all of these, I'm just going to copy this for a moment here, I'm going to make a

            08:56:49.600 --> 08:56:56.320
            new file, file new file. Sure, it doesn't really matter. We're just using this as a quick scratch

            08:56:56.320 --> 08:57:05.200
            pad. And so what I want to do here is just delete out this part. And we're going to do export on the

            08:57:05.200 --> 08:57:10.240
            end here, we'll take out this one here. And the idea is that we'll just set them all here. And

            08:57:10.240 --> 08:57:16.720
            then we will make our lives a little bit easier when we have to mass set the mass set these.

            08:57:16.720 --> 08:57:23.360
            So we do have the connection string because we saw it over here. So we will grab the primary one

            08:57:23.360 --> 08:57:31.600
            doesn't matter which one primary secondary. And that is for the event hub. We call the

            08:57:31.600 --> 08:57:42.080
            the event hub was called my hub, I believe. We'll just double check what the hub was called. Yeah,

            08:57:42.080 --> 08:57:46.480
            it's called my hub up there. We'll need a storage account. So what I'm going to do,

            08:57:46.480 --> 08:57:52.240
            which this thing we get out of here, get out of here, I'm not. I'm not trying to save a frickin

            08:57:52.240 --> 08:57:56.800
            file. There we go, hit escape a bunch of times. And we'll go back here and we'll create ourselves

            08:57:56.800 --> 08:58:00.160
            a new storage account, I actually make this in a new tab. So we can see what we're doing.

            08:58:00.160 --> 08:58:04.240
            So we'll go over to storage accounts.

            08:58:04.240 --> 08:58:11.280
            And we'll create ourselves a new storage account, we'll create this storage account in the same

            08:58:11.280 --> 08:58:20.480
            namespace. So we'll go down to my event hub, we'll just say my or we'll just say my event hub,

            08:58:21.040 --> 08:58:24.320
            8888. Again, you might have to change it based on your standards, but

            08:58:24.320 --> 08:58:29.360
            are like what is available to you. Go ahead and go review, create.

            08:58:29.360 --> 08:58:37.920
            And for the container name, we'll probably just call container, maybe container one.

            08:58:37.920 --> 08:58:42.960
            We just have to wait for this crate to grab that connection string.

            08:58:42.960 --> 08:58:47.280
            So this usually doesn't take too long, just a couple seconds.

            08:58:47.280 --> 08:58:57.600
            Okay, so there we are, we'll go over to access keys. And we'll grab the connection string from

            08:58:57.600 --> 08:59:05.600
            here, I believe this one should work. Let me just double check. Yeah, I think this will work. So

            08:59:05.600 --> 08:59:09.520
            what we'll do is go back over here, if it doesn't, we'll find out pretty soon. And we'll just generate

            08:59:09.520 --> 08:59:16.560
            out a shared policy. We'll go ahead and paste that on in here. And just double checking that this is

            08:59:16.560 --> 08:59:21.600
            the correct one, this looks identical to that one that can't be correct. So we'll go back here. This

            08:59:21.600 --> 08:59:26.240
            is the storage account. So we'll go Oh, I have to actually hit the copy button. That's what I didn't

            08:59:26.240 --> 08:59:30.560
            do. We'll go ahead and paste that in. And so theoretically, this should work. So we'll go

            08:59:30.560 --> 08:59:38.880
            ahead and copy these, we'll drag our terminal up a bit, we'll paste these in here. And what I'll do

            08:59:38.880 --> 08:59:46.400
            is just double check that they're here. So we'll say env grep, event hub. So those are both set.

            08:59:46.400 --> 08:59:54.000
            And then we'll do storage, that one is set. And we'll do container. That one is set. So these are

            08:59:54.000 --> 08:59:58.800
            all in good shape. For our storage account, we still have to create the container. So go here

            08:59:58.800 --> 09:00:04.320
            and create a new container. So container one, we'll go ahead and create that we'll make our way back

            09:00:04.320 --> 09:00:10.320
            over here. And then instead of just having export, we'll do GP, ENV, this is just in case we have to

            09:00:10.320 --> 09:00:14.800
            restart the environment for any reason, so that these environment variables get exported twice.

            09:00:14.800 --> 09:00:19.040
            So paste that in there. I believe those are all set, I had to hit enter on the last one there.

            09:00:19.040 --> 09:00:26.160
            And let's see if our code works. So we'll do a send. Actually, we have to set up

            09:00:26.160 --> 09:00:31.280
            two scripts here so that we can actually call them. That one called here is called send.

            09:00:31.280 --> 09:00:39.120
            This will be node send j s. And we'll have received so REC just because I always spell

            09:00:39.120 --> 09:00:42.880
            receive wrong, and I just don't want to have to type in 1000 times, we'll have that there.

            09:00:42.880 --> 09:00:47.600
            So now what we'll do is do NPM run send, see if that works.

            09:00:47.600 --> 09:00:53.680
            Says a batch of three events have been sent, we'll go and confirm that over an event hub,

            09:00:53.680 --> 09:00:58.240
            if it worked, because the overview, it should show us some messages were received.

            09:00:58.240 --> 09:01:03.600
            Sometimes there's a bit of delay. So we'll just give it a teeny tiny amount of time,

            09:01:03.600 --> 09:01:08.320
            we'll hit refresh here. Because we know we sent them. But while we're waiting for those to kind

            09:01:08.320 --> 09:01:11.600
            of propagate, what we'll go back here and just kind of look at the code because we didn't really

            09:01:11.600 --> 09:01:18.400
            look at it. So the way it works is you are defining a client, and it will be the producer,

            09:01:18.400 --> 09:01:23.920
            client. And then down below, so we say, okay, a producer is someone that produces events is very

            09:01:23.920 --> 09:01:28.160
            common in a messaging system to have a producer and consumer, we're going to create a batch job,

            09:01:28.160 --> 09:01:32.000
            and we're going to add them all to the batch job, then we're going to send them all at once,

            09:01:32.000 --> 09:01:36.240
            and it's going to close, and it'll, and it'll complete. And if there are any errors, it will

            09:01:36.240 --> 09:01:44.160
            alert us about it. So we'll go back over here, and we'll do a refresh. So I want to see messages,

            09:01:44.160 --> 09:01:49.520
            messages would normally show up here. So since I don't trust it, I'm just going to run it again.

            09:01:49.520 --> 09:01:51.440
            I mean, clearly worked because there was no errors.

            09:01:51.440 --> 09:02:00.240
            And we'll go back over here, and not here. But we'll go back here, we'll refresh.

            09:02:03.360 --> 09:02:06.800
            And I'm just waiting to see something here.

            09:02:06.800 --> 09:02:21.680
            Processing data is like something that's really powerful with a band hub here. So

            09:02:21.680 --> 09:02:28.640
            still don't see the messages, just give me a second to debug this. I've done this lab like

            09:02:28.640 --> 09:02:33.120
            four times. So it should work. But you know, sometimes, sometimes there's trouble. So just a

            09:02:33.120 --> 09:02:39.520
            moment. Alright, so I literally did nothing. And now it's actually showing up in the messaging queue.

            09:02:39.520 --> 09:02:44.720
            So you know, or the hub, the funnel. So that's just something you have to consider is that sometimes

            09:02:44.720 --> 09:02:48.320
            you just have to be a little bit patient. Let's see if we can go receive those messages now by

            09:02:48.320 --> 09:02:55.840
            running the other scripts. So what I'm going to do here is do NPM, run receive. And it should receive

            09:02:55.840 --> 09:03:00.320
            the messages as long as something isn't typed incorrectly. So we'll go back over here, we've

            09:03:00.320 --> 09:03:03.600
            seemed to introduce a little mistake. So I'll go ahead and save that we'll hit up.

            09:03:03.600 --> 09:03:11.040
            And it should receive the events. So should print the three out. So there we go. And so we are

            09:03:11.040 --> 09:03:15.520
            streaming this or the consumer is technically storage storage accounts. But we go to the

            09:03:15.520 --> 09:03:21.200
            storage account, there's nothing really intelligible in terms of what's in here. So

            09:03:21.200 --> 09:03:27.280
            like there are stuff in here checkpoints. I guess it's saved a checkpoint. I personally don't know

            09:03:27.280 --> 09:03:31.520
            what I'm looking at. So I'm not exactly sure what the point of doing that I guess is just saying the

            09:03:31.520 --> 09:03:36.320
            checkpoint is like the last point it wrote. But if we just take a look at the code here quickly,

            09:03:36.320 --> 09:03:41.680
            you can see it is called consumer. So we can a consumer client, there's a blob checkpoint store,

            09:03:41.680 --> 09:03:46.320
            then we have the consumer client we are subscribing. So it's saying, Hey, are there

            09:03:46.320 --> 09:03:51.840
            any events, let's consume them. If there are no events, throw a console log. So tell us about it,

            09:03:51.840 --> 09:03:57.120
            iterate through them, then update the checkpoint. So move it to the next point. Just say, hey,

            09:03:57.120 --> 09:04:01.360
            this is where it is now. And that's pretty much all I want you to do, we can go ahead and save

            09:04:01.360 --> 09:04:06.960
            this code. So we'll say event hub code, doesn't matter what you name it, there will sync the

            09:04:06.960 --> 09:04:11.520
            changes. And we'll go ahead and clean up. So we'll go back to our resource groups.

            09:04:12.480 --> 09:04:19.760
            We'll go to vent hub. And we will then go and delete this resource group. And we'll go here and

            09:04:19.760 --> 09:04:21.840
            there you go.

            09:04:21.840 --> 09:04:31.920
            Hey, this is Andrew Brown from exam Pro. And in this section, we'll be covering the Azure cloud

            09:04:31.920 --> 09:04:37.280
            adoption framework. Cloud adoption framework is a white paper that is a step by step process to

            09:04:37.280 --> 09:04:42.720
            help organizations plan and migrate their workloads to Azure. The image outlines the Microsoft cloud

            09:04:42.720 --> 09:04:47.200
            adoption framework for Azure a systematic approach to transitioning to the Azure cloud.

            09:04:47.200 --> 09:04:52.240
            The process is categorized into stages, defined strategy here, the focus is on

            09:04:52.240 --> 09:04:58.560
            understanding motivations, grasping the reasons for cloud adoption, business outcomes, identifying

            09:04:58.560 --> 09:05:04.160
            the desired results, business justification, validating the moves reasons, first adoption

            09:05:04.160 --> 09:05:10.160
            project, kickstarting the cloud journey plan, this stage includes rationalizing digital estate,

            09:05:10.160 --> 09:05:14.960
            evaluating current digital assets, initial organization alignment, ensuring everyone is

            09:05:14.960 --> 09:05:20.880
            aligned with the migrations goals, skills readiness plan equipping teams with necessary cloud skills,

            09:05:20.880 --> 09:05:25.840
            cloud adoption plan laying out a roadmap for the cloud transition ready, this phase ensures

            09:05:25.840 --> 09:05:31.280
            preparedness, Azure readiness guide preparing the environment for Azure first landing zone,

            09:05:31.280 --> 09:05:36.240
            setting up an initial secure Azure environment, expanding the blueprint broadening the Azure

            09:05:36.240 --> 09:05:41.840
            setup is per requirements, best practice validation, ensuring adherence to Azure best practices,

            09:05:41.840 --> 09:05:48.000
            adopt the actionable phase where migrate existing workloads are moved to Azure. This entails the

            09:05:48.000 --> 09:05:53.520
            first workload migration, understanding expanded scenarios, validating best practices and making

            09:05:53.520 --> 09:05:59.360
            process improvements, innovate transform services in the Azure environment using innovation guides,

            09:05:59.360 --> 09:06:04.240
            exploring new scenarios, validating best practices and furthering process improvements.

            09:06:04.240 --> 09:06:09.920
            Govern this is about oversight and management, establish a methodology and benchmark for

            09:06:09.920 --> 09:06:15.520
            governance, implement initial best practices standards for Azure use, measure governance

            09:06:15.520 --> 09:06:21.200
            maturity, how well governance rules are followed, manage the steals with ongoing operations,

            09:06:21.200 --> 09:06:26.880
            ensure business commitments are met during the transition, set and assess the operations baseline,

            09:06:26.880 --> 09:06:30.800
            determine operations maturity, gauge the efficiency of cloud operations.

            09:06:30.800 --> 09:06:36.880
            Now let's take a look at the security roles and responsibilities of the Azure cloud adoption

            09:06:36.880 --> 09:06:43.280
            framework, business and technology outcomes, goals and results expected from security functions,

            09:06:43.280 --> 09:06:50.080
            security outcomes, results and organization aims for including governance, prevention and response,

            09:06:50.080 --> 09:06:56.080
            role types, security leadership, provide security direction and strategy, security architect,

            09:06:56.080 --> 09:07:01.680
            designs and implements security blueprints, platform app security engineers, ensure security

            09:07:01.680 --> 09:07:06.960
            of platforms and applications, security operations, manages real-time security threats,

            09:07:06.960 --> 09:07:13.680
            responsibilities, security leadership, set security strategy, security architecture,

            09:07:13.680 --> 09:07:20.640
            design secure systems, security compliance, ensures adherence to regulations, policy and standards,

            09:07:20.640 --> 09:07:27.280
            set security policies, posture management, manages overall security stance, phases of security

            09:07:27.280 --> 09:07:34.160
            implementation, plan identifies security needs, build implement strategies including access control

            09:07:34.160 --> 09:07:40.000
            and asset protection, run manages ongoing operations including prevention and response,

            09:07:40.000 --> 09:07:46.080
            feedback loop, continuous improvement cycle and security operations. In summary, the framework

            09:07:46.080 --> 09:07:51.120
            offers a structured way to transition to Azure ensuring strategy alignment, preparation, adoption,

            09:07:51.120 --> 09:08:00.480
            governance and effective management. Let's talk about the Azure Well-Architected Framework.

            09:08:00.480 --> 09:08:05.440
            Azure Well-Architected Framework provides best practices for designing and implementing

            09:08:05.440 --> 09:08:11.680
            solutions on Azure. It is structured around five key pillars. Cost optimization, this pillar focuses

            09:08:11.680 --> 09:08:16.880
            on maximizing the value delivered by managing and controlling costs. Proper cost management can lead

            09:08:16.880 --> 09:08:22.320
            to significant savings without compromising function or performance. Operational excellence,

            09:08:22.320 --> 09:08:26.880
            this emphasizes implementing and maintaining system processes to ensure smooth and efficient

            09:08:26.880 --> 09:08:31.920
            operations in a production environment. It involves routine operations, deployment practices,

            09:08:31.920 --> 09:08:37.440
            monitoring and iterative improvement. Performance efficiency refers to ensuring that systems can

            09:08:37.440 --> 09:08:42.640
            scale appropriately and adapt to varying loads, both expected and unexpected. It's not just about

            09:08:42.640 --> 09:08:48.080
            speed but ensuring resources are used efficiently to meet performance requirements. Reliability

            09:08:48.080 --> 09:08:52.880
            concerns the system's ability to recover from interruptions such as failures or outages and

            09:08:52.880 --> 09:08:57.280
            continue to operate without significant degradation. This pillar stresses designing for high

            09:08:57.280 --> 09:09:02.880
            availability and disaster recovery. Security, central to the Azure Well-Architected Framework,

            09:09:02.880 --> 09:09:07.840
            this pillar emphasizes the protection of data and applications from potential threats. It covers a

            09:09:07.840 --> 09:09:12.640
            broad spectrum from access controls and encryption to threat detection and response strategies.

            09:09:12.640 --> 09:09:16.320
            So that's an overview of the Azure Well-Architected Framework.

            09:09:16.320 --> 09:09:26.480
            The next topic we'll be covering is Azure Migrate. Azure Migrate offers a streamlined service for

            09:09:26.480 --> 09:09:32.000
            migration, modernization and optimization on Azure. It simplifies the pre-migration processes like

            09:09:32.000 --> 09:09:36.880
            discovering, assessing and appropriately sizing on-premises resources for infrastructure,

            09:09:36.880 --> 09:09:41.840
            data and applications. With an extensible framework, Azure Migrate easily integrates

            09:09:41.840 --> 09:09:46.400
            with third-party tools, broadening its range of supported scenarios. Here's what it offers.

            09:09:46.400 --> 09:09:52.400
            Unified Migration Platform, a centralized portal to initiate, execute and monitor your Azure

            09:09:52.400 --> 09:09:57.920
            Migration journey. Diverse toolset, Azure Migrate provides a suite of tools for both assessment and

            09:09:57.920 --> 09:10:02.560
            migration. It features tools such as Azure Migrate, discovery and assessment in migration

            09:10:02.560 --> 09:10:06.880
            and modernization. Furthermore, it seamlessly integrates with other Azure services,

            09:10:06.880 --> 09:10:12.960
            tools and third-party offerings from independent software vendors. Comprehensive migration and

            09:10:12.960 --> 09:10:18.080
            modernization capabilities in the Azure Migrate Hub, you can assess, migrate and modernize.

            09:10:18.080 --> 09:10:24.240
            Servers, databases and web apps assess and migrate on-premises servers, web apps and SQL

            09:10:24.240 --> 09:10:30.640
            server instances to Azure. Databases, analyze on-premises SQL server instances and databases

            09:10:30.640 --> 09:10:36.240
            and migrate them to Azure SQL on a VM, Azure SQL Managed Instance or Azure SQL database.

            09:10:36.240 --> 09:10:41.680
            Web applications, evaluate on-premises web applications and transition them to the Azure

            09:10:41.680 --> 09:10:47.280
            App Service or Azure Kubernetes Service. Virtual desktops, review your on-site virtual desktop

            09:10:47.280 --> 09:10:52.720
            infrastructure and move it to Azure Virtual Desktop. Data transfer, efficiently and affordably

            09:10:52.720 --> 09:10:58.640
            transfer vast data volumes to Azure using Azure Data Box products. By using Azure Migrate,

            09:10:58.640 --> 09:11:03.520
            organizations can streamline and simplify their migration process, reduce downtime and improve

            09:11:03.520 --> 09:11:12.720
            the overall efficiency and cost-effectiveness of their cloud migration. The next thing we'll be

            09:11:12.720 --> 09:11:18.160
            covering are the integrated tools in Azure Migrate. The Azure Migrate Hub includes these tools,

            09:11:18.160 --> 09:11:24.160
            Azure Migrate Discovery and Assessment. Discover and assess servers including SQL and web apps.

            09:11:24.160 --> 09:11:29.040
            Discover and assess on-premises servers running on VMware, Hyper-V and physical servers in

            09:11:29.040 --> 09:11:36.160
            preparation for migration to Azure. Migration and modernization. Migrate servers. Migrate VMware VMs,

            09:11:36.160 --> 09:11:41.920
            Hyper-V VMs, physical servers, other virtualized servers and public cloud VMs to Azure. Data

            09:11:41.920 --> 09:11:48.400
            Migration Assistant. Assess SQL Server databases for migration to Azure SQL Database, Azure SQL

            09:11:48.400 --> 09:11:54.640
            Managed Instance or Azure VMs running SQL Server. Data Migration Assistant assesses SQL Servers,

            09:11:54.640 --> 09:11:59.520
            identifies potential migration problems, unsupported features and suggests the best path for

            09:11:59.520 --> 09:12:05.520
            database migration. Azure Database Migration Service. Migrate on-premises databases to Azure

            09:12:05.520 --> 09:12:12.320
            VMs running SQL Server, Azure SQL Database or SQL Managed Instances. Azure Database Migration

            09:12:12.320 --> 09:12:16.640
            Service is a managed service for seamless migrations to Azure data platforms with minimal

            09:12:16.640 --> 09:12:22.800
            downtime. Mover. Assess servers. Mover is a SaaS platform that enhances business intelligence by

            09:12:22.800 --> 09:12:28.400
            accurately depicting it environments within a day. Web App Migration Assistant. Assess on-premises

            09:12:28.400 --> 09:12:33.360
            web apps and migrate them to Azure. Azure App Service Migration Assistant is a standalone tool

            09:12:33.360 --> 09:12:39.120
            to assess on-premises websites for migration to Azure App Service. Azure Data Box. Migrate

            09:12:39.120 --> 09:12:44.560
            offline data. Use Azure Data Box products to move large amounts of offline data to Azure.

            09:12:44.560 --> 09:12:47.680
            So that's an overview of the integrated tools in Azure Migrate.

            09:12:47.680 --> 09:12:57.040
            The next type of migration solution we'll be going over is Azure Database Migration Service.

            09:12:57.040 --> 09:13:02.240
            Azure Database Migration Service is a fully managed service that enables seamless migrations

            09:13:02.240 --> 09:13:07.120
            from various database sources to Azure data platforms with minimal downtime. It simplifies

            09:13:07.120 --> 09:13:11.760
            the process of moving databases to the cloud and reduces the risks associated with migration.

            09:13:11.760 --> 09:13:16.640
            The service supports various source database engines such as SQL Server,

            09:13:16.640 --> 09:13:23.280
            MySQL, Oracle, and PostgreSQL and targets Azure database platforms such as Azure SQL Database,

            09:13:23.280 --> 09:13:28.080
            Azure SQL Managed Instance, and Azure Database for PostgreSQL and MySQL.

            09:13:28.720 --> 09:13:34.880
            Azure Database Migration Service currently offers two versions. Database Migration Service via Azure

            09:13:34.880 --> 09:13:41.200
            SQL Migration Extension for Azure Data Studio, Azure Portal, PowerShell, and Azure CLI. Database

            09:13:41.200 --> 09:13:48.640
            Migration Service via Azure Portal, PowerShell, and Azure CLI. Use cases. Migrations of on-premises

            09:13:48.640 --> 09:13:54.000
            databases to Azure SQL services. Database consolidation and migration to a single

            09:13:54.000 --> 09:14:00.480
            platform in Azure. Cloud bursting and disaster recovery solutions. Features. Support for a wide

            09:14:00.480 --> 09:14:05.760
            range of source and target database platforms. Automated schema and data migration with minimal

            09:14:05.760 --> 09:14:10.640
            downtime. Migration assessment to identify potential issues and guidance for a successful

            09:14:10.640 --> 09:14:16.400
            migration. Real-time migration monitoring and error notifications. Pre- and post-migration

            09:14:16.400 --> 09:14:21.760
            validation and cleanup tools. Integration with Azure services such as Azure Security Center and

            09:14:21.760 --> 09:14:28.320
            Azure Monitor for enhanced security and monitoring capabilities. How it works. Set up the migration

            09:14:28.320 --> 09:14:33.360
            project. Create a new migration project in Azure DMS. Define the source and target environments

            09:14:33.360 --> 09:14:38.400
            and specify the database objects to migrate. Configure the source and target. Configure the

            09:14:38.400 --> 09:14:42.880
            network connectivity and security settings for the source and target environments and install the

            09:14:42.880 --> 09:14:48.320
            Azure DMS extension on the source database server. Start the migration. Start the migration and

            09:14:48.320 --> 09:14:53.040
            monitor the progress in the Azure DMS portal. The service automatically replicates the source

            09:14:53.040 --> 09:14:57.360
            database to the target environment and tracks the changes that occur during the migration.

            09:14:57.360 --> 09:15:03.280
            Perform Qt over and post-migration tasks after replication. Initiate the Qt over to transition

            09:15:03.280 --> 09:15:08.880
            the application to the target environment. Azure DMS offers validation and cleanup tools post-migration.

            09:15:08.880 --> 09:15:17.760
            The next migration tool we'll be covering is Storage Migration Service.

            09:15:17.760 --> 09:15:22.400
            The Storage Migration Service simplifies the process of migrating storage to Windows Server

            09:15:22.400 --> 09:15:27.200
            or Azure. It comes with a user-friendly graphical tool that takes stock of data on Windows,

            09:15:27.200 --> 09:15:33.440
            Linux, and NetApp CIFS servers and facilitates its transfer to newer servers or Azure virtual machines.

            09:15:33.440 --> 09:15:37.760
            The service also enables the migration of a server's identity to the destination server,

            09:15:37.760 --> 09:15:42.400
            ensuring that applications and users can access their data without any changes to links or paths.

            09:15:43.440 --> 09:15:48.000
            Why use Storage Migration Service? Use Storage Migration Service because you've got a server

            09:15:48.000 --> 09:15:52.240
            or multiple servers that you want to migrate to newer hardware or virtual machines.

            09:15:52.240 --> 09:15:56.400
            Storage Migration Service is designed to help by doing the following tasks.

            09:15:56.400 --> 09:16:01.840
            Inventory multiple servers and their data. Rapidly transfer files, file shares, and security

            09:16:01.840 --> 09:16:06.880
            configuration from the source servers. Optionally, take over the identity of the source servers,

            09:16:06.880 --> 09:16:10.960
            also known as cutting over, so that users and apps don't have to change anything to access

            09:16:10.960 --> 09:16:16.160
            existing data. Manage one or multiple migrations from the Windows Admin Center user interface.

            09:16:16.160 --> 09:16:22.080
            Migration is a three-step process. Why do inventory servers to gather info about their

            09:16:22.080 --> 09:16:27.040
            files and configuration, shown in the following figure. Two, transfer data from the source

            09:16:27.040 --> 09:16:32.240
            servers to the destination servers. Three, cut over to the new servers. The destination

            09:16:32.240 --> 09:16:36.160
            servers assume the source server's former identity so that apps and users don't have

            09:16:36.160 --> 09:16:40.880
            to change anything. Although the source servers retain their files, they enter a maintenance mode

            09:16:40.880 --> 09:16:45.280
            and become inaccessible. At a suitable time, these servers can be decommissioned.

            09:16:45.280 --> 09:16:47.840
            So that's an overview of Storage Migration Service.

            09:16:47.840 --> 09:16:58.320
            The next migration solution we'll be covering is Azure Data Box. The Microsoft Azure Data Box

            09:16:58.320 --> 09:17:03.040
            cloud solution lets you send terabytes of data into and out of Azure in a quick, inexpensive,

            09:17:03.040 --> 09:17:08.560
            and reliable way. Each storage device has a maximum usable storage capacity of 80 terabytes

            09:17:08.560 --> 09:17:12.800
            and is transported to your data center through a regional carrier. It is designed to help

            09:17:12.800 --> 09:17:17.440
            customers with slow or limited internet connectivity to move large volumes of data to the cloud.

            09:17:17.440 --> 09:17:23.920
            Let's take a look at some of Azure Data Box's use cases. Data Box is used to import data to

            09:17:23.920 --> 09:17:29.440
            Azure for one-time migrations, moving large on-premises data, transitioning offline tapes,

            09:17:29.440 --> 09:17:34.880
            relocating VMs, SQL servers, applications, and transferring historical data for Azure-based

            09:17:34.880 --> 09:17:40.720
            analysis, initial bulk transfers, large-scale transfers using Data Box, followed by incremental

            09:17:40.720 --> 09:17:45.120
            network transfers, for example, moving vast backups with partners like Convault,

            09:17:45.120 --> 09:17:50.960
            periodic uploads, transferring large volumes of data generated periodically, like video content

            09:17:50.960 --> 09:17:57.440
            from oil rigs or windmill farms. For exporting from Azure, Data Box is used for disaster recovery,

            09:17:57.440 --> 09:18:03.120
            restoring Azure data on-premises quickly, security requirements, meeting mandates that require data

            09:18:03.120 --> 09:18:09.120
            extraction from Azure storage tiers like US Secret, migration, moving data back to on-premises or to a

            09:18:09.120 --> 09:18:15.280
            different cloud provider. Here's how Azure Data Box works. Customers order a Data Box from the

            09:18:15.280 --> 09:18:20.560
            Azure portal. When the Data Box arrives, customers connect it to their network and configure it using

            09:18:20.560 --> 09:18:26.240
            the Azure portal. Customers copy data to the Data Box using standard file transfer protocols,

            09:18:26.240 --> 09:18:32.080
            such as SMB or NFS. Once the data transfer is complete, customers ship the Data Box back to

            09:18:32.080 --> 09:18:36.640
            Azure. Azure copies the data from the Data Box to the customer's Azure storage account.

            09:18:36.640 --> 09:18:41.040
            So that's an overview of Azure Data Box, its use cases and workflow.

            09:18:41.040 --> 09:18:50.320
            Let's talk about networking for Azure. And so everything kind of revolves around the virtual

            09:18:50.320 --> 09:18:54.720
            network, also known as the VNet. And this is a logically isolated section of your Azure network

            09:18:54.720 --> 09:19:01.680
            where you launch your Azure resources. And here's a very simple diagram of using VNet. But there's a

            09:19:01.680 --> 09:19:06.560
            lot of networking components that you're going to be utilizing. And we're not going to go through

            09:19:06.560 --> 09:19:11.360
            the exhaustive list here. But let's just go through some of them. Just to give you an idea of like all

            09:19:11.360 --> 09:19:17.120
            the things you can do within Azure networking. So you have Azure DNS, this manages your your DNS

            09:19:17.120 --> 09:19:21.680
            domain, then you have the VNet itself. And so underneath that, it'll have like address spaces,

            09:19:21.680 --> 09:19:26.000
            route table subnets, then you have network security groups, this acts as a virtual firewall

            09:19:26.000 --> 09:19:30.800
            at the subnet or NIC level, you have ExpressRoute, this helps you create a very fast connection

            09:19:30.800 --> 09:19:36.720
            between your on prem to your VNet, then you have virtual LAN, this is a centralized network to route

            09:19:36.720 --> 09:19:42.560
            different network connections, then you have virtual network gateway. This is a site to site

            09:19:42.560 --> 09:19:48.400
            VPN connection between VNets and local networks, then you have your NICs, or your network interfaces.

            09:19:48.400 --> 09:19:53.680
            And these are virtual network devices to allow VMs to communicate using IP protocols. And then you

            09:19:53.680 --> 09:19:59.760
            have like all your load balancers and other things like that. So again, not an exhaustive list,

            09:19:59.760 --> 09:20:03.520
            but just shows you that there's a lot you can do with the networking on Azure.

            09:20:03.520 --> 09:20:12.800
            So as your private links allows you to establish secure connections between Azure resources,

            09:20:12.800 --> 09:20:17.440
            so traffic remains within your Azure network. And so I got this big old graphic here.

            09:20:17.440 --> 09:20:22.320
            And so let's just define a few things, I'm going to pull up my pen here. And so imagine you have

            09:20:22.320 --> 09:20:28.320
            workloads on your on prem, or you have your own virtual network on Azure. And so you have some

            09:20:28.320 --> 09:20:33.440
            VMs doing some stuff. And the idea is that you want to connect them to some other services over

            09:20:33.440 --> 09:20:39.040
            here. But the thing is, is that if you wanted to connect them, they might try to transverse the

            09:20:39.040 --> 09:20:44.400
            internet. So if you're on prem, it's going out here, it's going over here. And so the issue

            09:20:44.400 --> 09:20:52.480
            with this is that it's not necessarily secure. Another issue could be, you know, it's just

            09:20:52.480 --> 09:20:57.760
            faster if it would just stay within the actual network, because if you're already connected,

            09:20:57.760 --> 09:21:02.560
            you know, your stuff over here, then why wouldn't it just go through the actual network? Another

            09:21:02.560 --> 09:21:06.480
            thing is like data transfer costs. So it's always going out the internet and coming back in. And

            09:21:06.480 --> 09:21:12.960
            that's not a great scenario. So I'm just going to erase all that stuff there. The idea with private

            09:21:12.960 --> 09:21:18.000
            link is that it's just keeping everything within the Azure network. And so that's what it's doing.

            09:21:18.000 --> 09:21:26.400
            So if you want to, you know, connect your workloads in your V net, or your on prem that connects to

            09:21:26.400 --> 09:21:30.720
            a specific v net, the idea is that you can launch a private link endpoint, which is a network

            09:21:30.720 --> 09:21:34.240
            interface. And this is what's establishing that connection. And you're going to have to give that

            09:21:34.240 --> 09:21:39.280
            private endpoint a private IP address from your v net. And so then the idea is that on the right

            09:21:39.280 --> 09:21:42.880
            hand side, that's what you want to connect to, there's a lot of Azure services by default works

            09:21:42.880 --> 09:21:47.520
            with private link. So there's no additional configuration, you'll just be able to say use

            09:21:47.520 --> 09:21:52.960
            private link and they will. Same thing with some third party providers in the marketplace, they

            09:21:52.960 --> 09:21:57.680
            might be powered by private link. And then there's a third case where let's say you have like a private

            09:21:57.680 --> 09:22:04.480
            subnet, and you have some VMs there. So what you could do is if you have a load balancer, and you

            09:22:04.480 --> 09:22:08.880
            need to have an internal load balancer there, where you can launch the private link service,

            09:22:08.880 --> 09:22:15.920
            and this is going to basically make your your workload in that v net become compatible or

            09:22:15.920 --> 09:22:25.360
            powered by private link. So there you go. Let's take a look at subnets. And a subnet is a logical

            09:22:25.360 --> 09:22:29.680
            division of an address space. So we just looked at address spaces. So we're cutting it up one step

            09:22:29.680 --> 09:22:34.480
            further. And subnets help you define different kinds of workloads and allows you to apply

            09:22:34.480 --> 09:22:39.680
            virtual isolation isolation within your network. So when you launch an Azure resource, you choose

            09:22:39.680 --> 09:22:45.520
            the subnet you want to launch with within and an IP from that subnet is assigned to your resource.

            09:22:45.520 --> 09:22:51.920
            So the thing is, is that when you create row tables, that's how you are associating the subnet

            09:22:51.920 --> 09:22:57.120
            so it can access the internet or access anything. And then there's public and private subnets. But

            09:22:57.120 --> 09:23:02.800
            this thing is interesting, because, like, again, if you if you're using AWS, those are very clearly

            09:23:02.800 --> 09:23:08.960
            defined things. But in Azure, they don't have this concept of public and private, you have to define

            09:23:08.960 --> 09:23:13.840
            it yourself. So really, a public or private subnet is just a subnet that doesn't have access to the

            09:23:13.840 --> 09:23:20.960
            internet. And so we saw that when we had the row table, and we over over road, the access to the

            09:23:20.960 --> 09:23:26.560
            internet to none, that essentially made it a private subnet. Another thing you can do with

            09:23:26.560 --> 09:23:30.880
            subnets is you can associate a network security group. And this is going to help protect protect

            09:23:30.880 --> 09:23:35.200
            your traffic entering and leaving the subnet. So you're making rules based on the IP address,

            09:23:35.200 --> 09:23:41.600
            port and protocol. And then there's a special thing called a gateway subnet. So it's a specialized

            09:23:41.600 --> 09:23:47.440
            type of subnet. And it's just for Azure virtual network gateways. And so it's interesting,

            09:23:47.440 --> 09:23:52.320
            you'll go in and there'll be a separate section just for it. And so you'll create it, it's just

            09:23:52.320 --> 09:24:02.320
            for that service. So virtual private networks also known as VPNs, what they do is they extend a

            09:24:02.320 --> 09:24:08.960
            private network across a public network and enables your users to send and receive data across shared

            09:24:08.960 --> 09:24:14.160
            or public networks as if they're computing devices were directly connected to the private network.

            09:24:14.160 --> 09:24:20.640
            All right. And so now we have to talk about what is a virtual network gateway. And so

            09:24:20.640 --> 09:24:26.480
            virtual network gateway is the software a VPN device for your Azure virtual network. So that's

            09:24:26.480 --> 09:24:31.520
            how these devices are going to connect to your network. So when you deploy a virtual network

            09:24:31.520 --> 09:24:38.000
            gateway, it will deploy two or two or more specialized VMs in specific subnets, you need

            09:24:38.000 --> 09:24:44.480
            to create a gateway subnet. And these deployed VMs contain routing tables and run specific gateway

            09:24:44.480 --> 09:24:49.360
            services, you can choose the type of gateway you want it to be. And this is going to determine

            09:24:49.360 --> 09:24:53.840
            whether you'd use something like VPN gateway or ExpressRoute gateway. So it's as simple as an

            09:24:53.840 --> 09:24:58.160
            option like that. But to really understand these virtual network gateways, we should just look at

            09:24:58.160 --> 09:25:07.040
            some VPN gateway design. So you understand why you're creating these things. So to understand

            09:25:07.040 --> 09:25:12.240
            VPN gateway, we need to understand the utility of the service. And so we'll look at some different

            09:25:12.240 --> 09:25:17.840
            topologies. And the first one is site to site. This is when you connect Azure to on premise data

            09:25:17.840 --> 09:25:22.400
            center or vice versa. And the idea is you create a VPN gateway that's that's going to establish

            09:25:22.400 --> 09:25:27.600
            connection to your on premise environment creating IP sec tunnel, which is a secure connection,

            09:25:27.600 --> 09:25:31.680
            IP connection there. But you might be asking, well, isn't that what ExpressRoute is for? Well,

            09:25:31.680 --> 09:25:37.600
            ExpressRoute goes through a part, a edge partner. So there's a lot more work involved in that setup,

            09:25:37.600 --> 09:25:42.320
            this one just goes over the internet. So it's not going to be as fast. And there's some other

            09:25:42.320 --> 09:25:46.640
            downsides. But the idea is it's the easiest way to get connected from your your on premise to

            09:25:46.640 --> 09:25:51.840
            Azure. The next one is multi site, this is when you connect Azure to multiple on premise data

            09:25:51.840 --> 09:25:57.600
            centers. So it's just like the same model, except there's more than one tunnel here to more than one

            09:25:58.400 --> 09:26:03.760
            site. Then you have point to site, this is when you connect Azure to multiple individual computers.

            09:26:03.760 --> 09:26:07.760
            So imagine you have a bunch of employees around the world and they have laptops,

            09:26:07.760 --> 09:26:14.880
            and they just need to connect securely to the to the private v net, or just the v net in general.

            09:26:14.880 --> 09:26:19.440
            And so that's where we're going to need VPN gateway. And the last one is v net to v net,

            09:26:19.440 --> 09:26:22.960
            this is where you're going to connect to v nets in two different regions and subscriptions,

            09:26:23.840 --> 09:26:29.760
            or have different deployment models. And so that's, again, those are transversing the internet

            09:26:29.760 --> 09:26:34.480
            in all these cases here. But yeah, that's pretty much it. And I guess I think that if you were to

            09:26:34.480 --> 09:26:39.600
            set up ExpressRoute, I think you'd have to set up VPN gateways anyway. But anyway, that's what

            09:26:39.600 --> 09:26:48.400
            that is there. So hopefully that now makes sense. So Azure Express routes creates private connections

            09:26:48.400 --> 09:26:53.200
            between Azure data centers and infrastructure on your premises or in co location environments. And

            09:26:53.200 --> 09:26:58.400
            so connections don't go over the public internet and as a result offer more reliability, faster

            09:26:58.400 --> 09:27:03.040
            speeds, consistent latencies and higher security. So here's a big old graphic here kind of

            09:27:03.040 --> 09:27:08.080
            representing what's going on here. And the idea is that you're going to have connectivity from

            09:27:08.080 --> 09:27:14.240
            different things like from any to any. So that's IP VPN network, a point to point ethernet network,

            09:27:14.240 --> 09:27:18.240
            a virtual cross connection, and this is all going to be going through a connectivity

            09:27:18.240 --> 09:27:24.640
            provider at a co location facility. So this example would be a an edge partner. And so you

            09:27:24.640 --> 09:27:28.960
            would be the customer network, that'd be your on premise or whatever you want to connect so that

            09:27:28.960 --> 09:27:34.400
            you can make it all the way to your Azure services. And the way you would establish connection is you

            09:27:34.400 --> 09:27:39.840
            create these ExpressRoute circuits, it's pretty common to have more than one because you want to

            09:27:39.840 --> 09:27:44.560
            have high availability just in case the other one goes out. The idea is that you can route them

            09:27:44.560 --> 09:27:49.920
            route this traffic to a couple different places. So the first one would be things like peering to

            09:27:49.920 --> 09:27:57.120
            Office 365, Dynamics 365, or even your Azure public services. So when we say public services,

            09:27:57.120 --> 09:28:03.360
            imagine you just launch a virtual machine that is in a public subnet that has an IP that's reachable

            09:28:03.360 --> 09:28:08.800
            from the internet, that could just be to that, or maybe you're using like Cosmo DB, or like you have

            09:28:08.800 --> 09:28:13.680
            fully qualified domains for other services. So it's just a way that you can get there. And then

            09:28:13.680 --> 09:28:20.000
            let's talk about the other side, which is doing private peering for v net. So the idea is that

            09:28:20.000 --> 09:28:24.640
            you have a private v net. So the subnets are private. And so the only way is going to be

            09:28:24.640 --> 09:28:30.240
            access it, you want a direct way to access it that way. So that's the two ways there. And just

            09:28:30.240 --> 09:28:36.400
            to note there is ExpressRoute direct. And so this is like ExpressRoute with an additional benefit

            09:28:36.400 --> 09:28:42.480
            that has greater bandwidth connections from 50 megabytes per second, up to 10 gigabytes per

            09:28:42.480 --> 09:28:46.160
            second. And this is really ideal if you have hybrid solutions where you're, you're moving

            09:28:46.160 --> 09:28:53.680
            massive amounts of data or where latency matters because you want to feel like these cloud services

            09:28:53.680 --> 09:28:56.800
            are right there with your on premise environment, you're going to need a lot of speed for that.

            09:28:56.800 --> 09:29:06.560
            Azure Firewall is a managed cloud based network security service that protects Azure v nets

            09:29:06.560 --> 09:29:10.640
            resources. And it's a fully stateful firewall as a service. So you're going to get built in

            09:29:10.640 --> 09:29:15.840
            high availability and unrestricted cloud scalability. And what you can do is essentially

            09:29:15.840 --> 09:29:20.880
            create enforce and log application network connectivity policies across subscription

            09:29:20.880 --> 09:29:26.240
            and virtual networks. So as your firewall uses a static public IP address for your v net resources,

            09:29:26.240 --> 09:29:33.040
            allowing outside firewalls identify originating from your virtual network, and the service is

            09:29:33.040 --> 09:29:39.120
            fully integrated with Azure Monitor for logging and analytics. So here is a representation of

            09:29:39.120 --> 09:29:43.680
            Azure Firewall. And so the idea is that you're going to launch an Azure Firewall into its own v

            09:29:43.680 --> 09:29:48.800
            nets, and then other v nets and your on premise or other things are going to pass through that

            09:29:48.800 --> 09:29:53.840
            central v net onto wherever they want to go. And the idea is that we're going to be able to

            09:29:53.840 --> 09:29:58.880
            do things like utilize Microsoft Threat Intelligence, this is going to block known

            09:29:58.880 --> 09:30:05.120
            malicious IPs and FQ DNS, that it stands for fully qualified domain names. And by default,

            09:30:05.120 --> 09:30:11.680
            the traffic is set to deny, but you can set connectivity policies to filter out traffic

            09:30:11.680 --> 09:30:17.280
            in a variety of ways to make sure that you are protected there. So yeah, that's all there is to

            09:30:17.280 --> 09:30:28.000
            it. So network security groups filter network traffic to and from the Azure resource in a v net.

            09:30:28.640 --> 09:30:35.120
            And so an NSG is composed of many security rules. And so here's an example of setting an inbound

            09:30:35.120 --> 09:30:40.480
            security rule. And each security rule has the following properties. So you can give it a unique

            09:30:40.480 --> 09:30:45.440
            name, which is all the way at the bottom there, you can set the source or destination. So you're

            09:30:45.440 --> 09:30:49.760
            going to set an IP address, CIDR block, service tag, application group, things like that,

            09:30:49.760 --> 09:30:56.240
            then you set the port range. So it could just be port 80, it could be all ports where it shows an

            09:30:56.240 --> 09:31:01.040
            asterisk, it could be a range of ports, you're gonna set the protocol. So you got TCP, UDP,

            09:31:01.040 --> 09:31:06.320
            ICMP, you set the action, whether it's allowed or denied, and then you set the priority, which is a

            09:31:06.320 --> 09:31:13.600
            number between 100 and 4096. And we have two types of security rules, we got inbound rules, which

            09:31:13.600 --> 09:31:18.720
            applies to traffic entering the NSG and outbound rules that apply to traffic leaving the NSG.

            09:31:18.720 --> 09:31:24.320
            Let's take a look at some of the default security rules that NSG sets for you. So when you create

            09:31:24.320 --> 09:31:28.400
            an NSG, you're going to have some created for you by default. And that's going to be for outbound

            09:31:28.400 --> 09:31:34.880
            rules and inbound rules. So for inbound rules, you're going to be able to accept any virtual

            09:31:34.880 --> 09:31:42.640
            networks into your through the NSG, it's going to allow Azure load balancer to make its way in,

            09:31:42.640 --> 09:31:49.360
            and it's going to deny everything else. All right, then for your outbound rules, it's allowed to go

            09:31:49.360 --> 09:31:53.520
            to any other virtual network, it's allowed to make its way out to the internet, and then everything

            09:31:53.520 --> 09:32:02.960
            else is denied. So there you go. Let's take a look here at the logic for security rules. And

            09:32:02.960 --> 09:32:06.560
            there's a lot of logic here. So we'll work our way through it. And unfortunately, there's no

            09:32:06.560 --> 09:32:10.720
            fun way to visualize this. So we just got to work through the text. So you may not create two

            09:32:10.720 --> 09:32:16.160
            security rules with the same priority priority and direction, you can have 5000 NSGs per subscription

            09:32:16.160 --> 09:32:23.280
            and 1000 NSGs rules per NSG. For priority rules are processed in priority order with lowest number

            09:32:23.280 --> 09:32:28.480
            process before the higher number. And network security groups rules are evaluated by priority

            09:32:28.480 --> 09:32:34.240
            using a five tuple information to allow or deny traffic based on source source ports, destination

            09:32:34.240 --> 09:32:39.920
            destination ports and protocol. Honestly, I don't know what they mean by that. And I couldn't make

            09:32:39.920 --> 09:32:44.480
            any sense. It's in the documentation. So I'm just showing it to you here. Then there's flow records,

            09:32:44.480 --> 09:32:50.400
            they don't exactly explain what they are. But I assume the idea is that when a request throws

            09:32:50.400 --> 09:32:55.680
            up flows to the NSG, they're attaching additional information to it. So the flow record allows a

            09:32:55.680 --> 09:33:01.200
            network security group to be stateful, a flow record is created for existing connections,

            09:33:01.200 --> 09:33:06.720
            communication is allowed or denied based on the connection state of the flow record. And so let's

            09:33:06.720 --> 09:33:11.840
            talk about statefulness. So if you specify an outbound security port, you don't need to set

            09:33:11.840 --> 09:33:17.200
            the inbound port since it will be set for you, you only need to specify an inbound security rule if

            09:33:17.200 --> 09:33:22.880
            the communication is initially initially externally initiated externally. And the opposite is also

            09:33:22.880 --> 09:33:27.680
            true. If inbound traffic is allowed over a port, it's not necessary to specify an outbound security

            09:33:27.680 --> 09:33:33.280
            rule to respond to traffic over the port. And the reason I know this went up when another port is

            09:33:33.280 --> 09:33:36.800
            set with another one, that's when it's stateful. If it didn't do that, that would be considered

            09:33:36.800 --> 09:33:42.960
            stateless. But it's stateful. Let's talk about interruption. So existing connections may not be

            09:33:42.960 --> 09:33:48.960
            interrupted when you remove a security rule that enabled the flow and traffic flows are interrupted

            09:33:48.960 --> 09:33:52.960
            when connections are stopped and no traffic is flowing in either direction for at least a few

            09:33:52.960 --> 09:33:58.800
            minutes. So there's the rules. There are a lot of stuff there. Honestly, I won't even remember

            09:33:58.800 --> 09:34:02.560
            90% of the stuff, but I just wanted to go through it with you. So there you go.

            09:34:02.560 --> 09:34:11.440
            Hey, this is Andrew Brown from exam Pro. And in this section, we'll be covering Azure DDoS

            09:34:11.440 --> 09:34:17.120
            protection. What is a DDoS attack, a malicious attempt to disrupt normal traffic by flooding a

            09:34:17.120 --> 09:34:22.400
            website with large amounts of fake traffic. DDoS attacks are big worries for people moving their

            09:34:22.400 --> 09:34:27.680
            apps to the cloud. These attacks try to use up all of an app's resources so real users can access it.

            09:34:27.680 --> 09:34:32.800
            Any online point can be a target for these attacks. Azure DDoS protection offers advanced

            09:34:32.800 --> 09:34:37.920
            features to counteract DDoS attacks when integrated with recommended application design practices.

            09:34:38.480 --> 09:34:42.720
            This service is specifically designed for Azure resources within a virtual network.

            09:34:42.720 --> 09:34:46.560
            Enabling this protection on both new and established virtual networks is simple and

            09:34:46.560 --> 09:34:53.600
            doesn't require any changes to apps or resources. Most frequent types of DDoS attack volumetric

            09:34:53.600 --> 09:34:57.840
            attacks. These are volume driven attacks that deluge the network with seemingly legitimate

            09:34:57.840 --> 09:35:02.560
            traffic. By doing so they exhaust available bandwidth, leaving legitimate users unable

            09:35:02.560 --> 09:35:07.840
            to access the website. These are typically measured in bits per second. Protocol attacks.

            09:35:07.840 --> 09:35:13.200
            These attacks exhaust server resources by sending fake protocol requests that exploit vulnerabilities.

            09:35:13.200 --> 09:35:18.320
            Examples include UDP and TCP flooding at layers three and four. These are measured in packets per

            09:35:18.320 --> 09:35:24.160
            second. Application layer attacks. These attacks target the application layer. Examples include

            09:35:24.160 --> 09:35:30.800
            HTTP floods, SQL injections, cross-site scripting, parameter tampering, and solaris attacks. To

            09:35:30.800 --> 09:35:36.960
            defend against these, web application firewalls are often employed. Azure offers two tiers of

            09:35:36.960 --> 09:35:42.960
            DDoS protection. DDoS network protection. When combined with best practices and application

            09:35:42.960 --> 09:35:48.720
            design, Azure DDoS network protection offers advanced DDoS mitigation tools. It's automatically

            09:35:48.720 --> 09:35:55.040
            configured to safeguard specific Azure resources in a virtual network. DDoS IP protection. This is

            09:35:55.040 --> 09:35:59.920
            a paper protected IP model. While it shares core features with DDoS network protection,

            09:35:59.920 --> 09:36:05.600
            it provides additional services like rapid DDoS response support, cost protection, and discounts

            09:36:05.600 --> 09:36:21.920
            on WAF. So that's an overview of Azure DDoS protection. So Azure has a few different kinds

            09:36:21.920 --> 09:36:26.720
            of load balancers. And one in particular is the application gateway. And this is for application

            09:36:26.720 --> 09:36:32.080
            level routing and load balancing service. So application gateway operates at the OSI layer

            09:36:32.080 --> 09:36:37.520
            seven, which is also known as the application layer. And the idea here is that when you're

            09:36:37.520 --> 09:36:43.760
            working about applications, you're working with HTTP requests, that's what it is. And so the idea

            09:36:43.760 --> 09:36:49.200
            is that it can look at the contents of the HTTP request and do some interesting things. So maybe

            09:36:49.200 --> 09:36:54.720
            it's looking at the path and saying, Okay, you're if you have a path, and it's payments, go to the

            09:36:54.720 --> 09:37:00.480
            VM that has our payment system, and then you've got support slash admin, go to the VM that does

            09:37:00.480 --> 09:37:08.320
            that. Maybe it has to do something with cookies, or maybe you want to apply a WAF policy to it. And

            09:37:08.320 --> 09:37:13.440
            so you can look at those HTTP requests and determine if it is malicious traffic and filter

            09:37:13.440 --> 09:37:19.360
            it out. So yeah, it's all about the application, which has to do with HTTP requests. To configure

            09:37:19.360 --> 09:37:24.480
            this thing, you need to set up a front ends, routing rules and back end pools. And there are

            09:37:24.480 --> 09:37:28.400
            two configurations for the front end, you can either have it with a private IP, which makes

            09:37:28.400 --> 09:37:33.040
            it now an internal load balancer, or a public IP, which makes it either we would call a public or

            09:37:33.040 --> 09:37:38.640
            external load balancer. And there's a both, I've never used that option before. But I mean, you

            09:37:38.640 --> 09:37:43.040
            just need really need to know the public and private. For the back ends, you create back end

            09:37:43.040 --> 09:37:47.120
            pools and a back end pool is just a collection of resources to which your application gateway

            09:37:47.120 --> 09:37:52.400
            sends traffic. And so a back end pool can contain virtual machines, virtual machine scale sets,

            09:37:52.400 --> 09:37:58.800
            IP addresses, domain names, app service. And I think you can also send it to like on prem.

            09:37:58.800 --> 09:38:03.440
            So let's just talk about routing rules, which connects the front end and the back end together.

            09:38:03.440 --> 09:38:11.440
            And so here is a more complex example gives you a better idea of the service at full. And so the

            09:38:11.440 --> 09:38:16.720
            idea is that you have your application gateway, it's going to send traffic, or sorry, like a DNS

            09:38:16.720 --> 09:38:20.960
            is going to send to application gateway, and then you have these listeners, and they listen for

            09:38:20.960 --> 09:38:27.520
            incoming traffic. And then what it will do, it will pass on that to a rule. And a rule just really

            09:38:27.520 --> 09:38:32.880
            says, Who should we pass the data to? And then if you are defining a back end pool, then you need to

            09:38:32.880 --> 09:38:38.480
            have an HTTP setting that says how do we handle the HTTP requests? Okay, and so now we'll just

            09:38:38.480 --> 09:38:48.000
            look at more granular detail about requests for routing rules. Let's take a closer look at routing

            09:38:48.000 --> 09:38:53.200
            rules. This is where all the magic happens. So a listener listens on a specified port, an IP address

            09:38:53.200 --> 09:38:58.240
            for traffic that uses a specified protocol, if the listener criteria met, the application gateway will

            09:38:58.240 --> 09:39:02.960
            apply the routing rule. And these come in two flavors, we got basic which forwards all requests

            09:39:02.960 --> 09:39:07.600
            for any domain to back end pools, and multi site forward requests to different back end pools based

            09:39:07.600 --> 09:39:12.960
            on host header and host name. So the thing is, is that you can have multiple listeners, and you can

            09:39:12.960 --> 09:39:18.320
            have an order of them. And the idea is that you really want the basic to be on the be in last in

            09:39:18.320 --> 09:39:22.720
            priority, because if it's a first, it's going to capture everything because that's his job. It's

            09:39:22.720 --> 09:39:28.960
            like a catch all. So just make sure that if you're using multiple listeners, you put basic last. So

            09:39:28.960 --> 09:39:32.720
            that's just something you need to know. Then for those back end targets, this is where we either

            09:39:32.720 --> 09:39:38.560
            define a back end pool or redirection. redirection is just an HTTP redirection, like 403, or whatever

            09:39:38.560 --> 09:39:44.000
            you have their temporary or permanent, very simple. But for back end pools, you have to create HTTP

            09:39:44.000 --> 09:39:49.120
            settings. And this tells us a little bit more about how we want to handle HTTP, you know, cookies,

            09:39:49.120 --> 09:39:53.760
            connection, training, port requests, etc. Let's talk about a little bit more. So here are the

            09:39:53.760 --> 09:39:59.760
            actual options that we can configure for HTTP settings. So you have your back end port. So

            09:39:59.760 --> 09:40:06.160
            generally, it's either port 80, or 443. It just depends on where you're doing your SSL termination.

            09:40:06.960 --> 09:40:13.200
            But generally, if you need end to end encryption, it'll be 443. And then if you are doing connect,

            09:40:13.200 --> 09:40:18.400
            or if you're doing SSL termination at the load balancer, then it's 80. Then you have cookie

            09:40:18.400 --> 09:40:22.560
            base affinity, this allows you to keep a user session on the same server. So if you need to

            09:40:22.560 --> 09:40:26.800
            persist cookies and use them for authentication, you'll want to enable that you got connection

            09:40:26.800 --> 09:40:31.680
            draining this gracefully removes back end pool members during plan service updates. So the idea

            09:40:31.680 --> 09:40:36.000
            is that you know, when there is an update, it's not just going to abruptly cut over, it's going

            09:40:36.000 --> 09:40:42.000
            to wait until a connection disconnects from a server before not no longer sending more requests

            09:40:42.000 --> 09:40:45.840
            there because you don't want a connection dropping in the middle of an update. It's not great for a

            09:40:45.840 --> 09:40:50.240
            user, then you have request timeouts, this is the number of seconds the application gateway will

            09:40:50.240 --> 09:40:54.400
            wait to receive a response from the back end pool before it returns a connection timeout error

            09:40:54.400 --> 09:41:00.080
            message and last are Oh, sorry, we have override back end path, these allow you to override the

            09:41:00.080 --> 09:41:04.000
            path in the URL. So the request for a specific a specific path can be routed to another path.

            09:41:04.000 --> 09:41:09.920
            The idea is imagine you want to send it to bananas, and you want bananas actually internally

            09:41:09.920 --> 09:41:13.840
            route to oranges, I don't know why you want to do that. Or maybe to plantains, that'd make a lot

            09:41:13.840 --> 09:41:18.800
            more sense. So something you can do. And the last one is the override the hostname. So application

            09:41:18.800 --> 09:41:23.920
            gateway normally leaves the hostname alone. But you know, if you're using multi tenant services,

            09:41:23.920 --> 09:41:30.640
            like apps, like app service, or API management, it needs very specific host header set. So this

            09:41:30.640 --> 09:41:34.960
            is where you can override them and change them for those services. So hopefully that really gives you

            09:41:34.960 --> 09:41:38.240
            a good picture of application gateway, but I feel that that's all you really need to know.

            09:41:38.240 --> 09:41:46.720
            So let's take a look here at Azure scale sets. And these are used to automatically increase or

            09:41:46.720 --> 09:41:52.800
            decrease your virtual machine capacity. So imagine you have a web application behind an application

            09:41:52.800 --> 09:41:58.000
            load balancer, and you have an increase in traffic, you want to be able to quickly add more

            09:41:58.000 --> 09:42:04.560
            capacity by adding another identical virtual machine, or when there's a decrease in traffic,

            09:42:04.560 --> 09:42:10.720
            remove it to save costs. And that is what Azure scale sets do. So you're creating scale policies

            09:42:10.720 --> 09:42:16.560
            to automatically add or remove based on host metrics, host metrics could be like CPU utilization

            09:42:16.560 --> 09:42:23.040
            or networking, you're going to create health checks. And you can also set a repair policy

            09:42:23.040 --> 09:42:28.640
            to replace unhealthy instances, you can associate a load balancer to distribute virtual machines

            09:42:28.640 --> 09:42:35.520
            across availability zones. And you can scale to 100 or even 1000 VMs using scale sets.

            09:42:35.520 --> 09:42:43.360
            So one thing you're going to probably want to do with your scale set is associate with a load

            09:42:43.360 --> 09:42:49.760
            balancer. And in honest, I don't run any kind of application workload, unless it is in a scale set

            09:42:49.760 --> 09:42:53.680
            and behind a load balancer, because it's just good practice to do that. And the reason why you're

            09:42:53.680 --> 09:42:57.440
            going to want to load balancer is that it's going to help you evenly distribute your VMs across

            09:42:57.440 --> 09:43:02.400
            multiple availability zones. And that's going to give you high availability, because you definitely

            09:43:02.400 --> 09:43:10.000
            want to try to run three VMs across three AZS to get that high availability. You can also use a

            09:43:10.000 --> 09:43:14.320
            load balancer probe checks. And these are more robust health checks than what skill set provides

            09:43:14.320 --> 09:43:20.960
            you. So that's just an added benefit there. And when we're talking about load balancers, we have

            09:43:20.960 --> 09:43:27.200
            two different choices here, we have the application gateway. And so this is for HTTP, HTTPS, web

            09:43:27.200 --> 09:43:33.120
            traffic load balancer. And then you also have Azure load balancer. And this is going to support TCP

            09:43:33.120 --> 09:43:39.280
            and UDP, network traffic and things like that. So depending on what OSI layer you need to operate on

            09:43:39.280 --> 09:43:47.600
            is going to determine what kind of load balancer you need to use. So let's take a look at scaling

            09:43:47.600 --> 09:43:51.440
            policies. And these determine when a virtual machine should be added or removed to meet the

            09:43:51.440 --> 09:43:56.560
            current requirements. And you have this little wizard here, this is what the wizard you see or

            09:43:56.560 --> 09:44:01.040
            form you see when you're creating a skill set initially with very simple features. But let's

            09:44:01.040 --> 09:44:05.200
            just focus on two things scaling out and scaling and scaling it out is when an instance should be

            09:44:05.200 --> 09:44:10.560
            added to a skill set to increase capacity. So you choose your metric, which is hard coded in this

            09:44:10.560 --> 09:44:15.920
            case, to CPU threshold. So you choose your metric, the duration, how many VMs you want to add,

            09:44:15.920 --> 09:44:21.280
            and then the scale in is the opposite, that's when you're removing something from the scale set to

            09:44:21.280 --> 09:44:26.880
            decrease your capacity. And again, that interface is very simple. When you actually go ahead and

            09:44:26.880 --> 09:44:31.040
            create a skill set, after you go and update it, you're going to end up with a lot more options.

            09:44:31.040 --> 09:44:36.880
            And here are the options, you can see they're extremely robust. And so you have the option

            09:44:36.880 --> 09:44:41.440
            to choose one of the built in host metrics that are already being collected on your virtual machine.

            09:44:41.440 --> 09:44:46.800
            So the most popular here, and there's more than this, but the most popular here is CPU network in

            09:44:46.800 --> 09:44:51.840
            network out, discreet and right, then you have your aggregates. So you can decide how you want

            09:44:51.840 --> 09:44:58.400
            to group or collect that data before you apply your final operations on it, then you have your

            09:44:58.400 --> 09:45:03.520
            operators. So you can say greater than or greater than or equal to, then you have your actions,

            09:45:03.520 --> 09:45:10.400
            you can say increase the count of so add x amount of servers, or you can say, increase by percentage.

            09:45:10.400 --> 09:45:16.640
            So imagine you had 10 servers, you want to increase the load by 30%. That would add three

            09:45:16.640 --> 09:45:21.280
            additional servers. If you want more metrics than just the built in host metrics, you can absolutely

            09:45:21.280 --> 09:45:26.800
            get more. But you're gonna have to install a couple things for app. If you want more app specific

            09:45:26.800 --> 09:45:31.440
            metrics like page performance, or page load performance and sessions count, you would

            09:45:31.440 --> 09:45:36.960
            install a small instrumentation package for app insights. And if you want to have more detailed

            09:45:36.960 --> 09:45:40.560
            host metrics, so you might have host metrics, but you want them in more detail or more available

            09:45:40.560 --> 09:45:47.680
            host metrics, you'd install the Azure diagnostic extension within your VM. There are a few other

            09:45:47.680 --> 09:45:52.800
            scaling policy options that are well, they're not exactly in that form, but they are around or

            09:45:52.800 --> 09:45:57.520
            are associated with them. One is the scale in policy not to be confused with the scale in option.

            09:45:57.520 --> 09:46:03.280
            And this determines what virtual machine should be removed when you decrease capacity. So it's

            09:46:03.280 --> 09:46:06.880
            just a simple drop down. And you have a few different options. So there's the default option,

            09:46:06.880 --> 09:46:10.720
            this is where it deletes the VM with the highest instance ID. And it's going to do that,

            09:46:10.720 --> 09:46:17.040
            taking consideration, the balancing across AZs and ADs, or it can delete the newest virtual

            09:46:17.040 --> 09:46:23.520
            machine. So delete the newest VM. Again, this one's only across virtual or availability zones,

            09:46:23.520 --> 09:46:28.960
            or delete the oldest via this is going to delete the oldest VM and balance across availability

            09:46:28.960 --> 09:46:35.680
            zones, then you have an update policy. And this determines how how VM instances are brought up to

            09:46:35.680 --> 09:46:40.880
            date with the latest scale set model. So again, it's another drop down. And you have a few options

            09:46:40.880 --> 09:46:46.960
            here. So you have automatic so increasing the start upgrade immediately in random over order or

            09:46:46.960 --> 09:46:53.840
            manual. So existing or existing instances must be manually upgraded or rolling. And so this update

            09:46:53.840 --> 09:46:59.840
            upgrades roll out in batches with optional pause. And just one other note here is that if you want

            09:46:59.840 --> 09:47:04.960
            to do automatic OS upgrades, you can enable this to help ease update management by safely and

            09:47:04.960 --> 09:47:14.400
            automatically upgrade the OS disk for all instances. So there you go. Health monitoring

            09:47:14.400 --> 09:47:19.120
            is a feature with skill sets, you're absolutely going to want to turn on. And what it does is it

            09:47:19.120 --> 09:47:23.120
            determines whether your instance your virtual machine instance is healthy or unhealthy. So

            09:47:23.120 --> 09:47:27.680
            you have that option to disable or enable it. And it comes in two different modes, we're going to

            09:47:27.680 --> 09:47:32.080
            have the application health extension, which is what we're seeing on the right hand side here.

            09:47:32.080 --> 09:47:39.440
            And this is where you ping an HTTP or HTTPS request with a specific path and expect back a

            09:47:39.440 --> 09:47:44.960
            specific status. So the status here would be 200. So the idea is that you could say ping the homepage

            09:47:44.960 --> 09:47:49.440
            at the homepage appears, then therefore the server must be healthy, or you can make it your own custom

            09:47:49.440 --> 09:47:54.720
            page. That's what I like to do, I have like a health check page. The other mode is load balancer

            09:47:54.720 --> 09:48:01.040
            probe, this is only going to work if you have an associated load balancer. And here you can check

            09:48:01.040 --> 09:48:08.960
            based on TCP UDP HTTP request. So this is a little bit more robust. So I generally would recommend

            09:48:08.960 --> 09:48:14.240
            using this mode over the first mode, because generally, when you have a scale set, you're

            09:48:14.240 --> 09:48:20.320
            going to also want to have a load balancer. Now, if you want to replace unhealthy instances,

            09:48:20.320 --> 09:48:24.640
            they have an automatic repair policy. So this is an automatic, I mean, like it's not turned on by

            09:48:24.640 --> 09:48:29.440
            default. So you have to explicitly say you want to turn it on. And what that will do is that if it

            09:48:29.440 --> 09:48:33.680
            finds an instance that is unhealthy, it's just going to terminate it and then launch a new

            09:48:33.680 --> 09:48:42.880
            instance. Alright, and so there you go. Alright, so now that we have our scale set, we're going to

            09:48:42.880 --> 09:48:47.600
            continue on learning more about availability by creating an application gateway. So this is

            09:48:47.600 --> 09:48:51.680
            actually a type of load balancer, even though it has gateway in the name, then there's Azure load

            09:48:51.680 --> 09:48:55.440
            balancers. And the difference between these two is this one's layer seven for the applications.

            09:48:55.440 --> 09:49:02.880
            And this is layer four. So TCP UDP, like at a lower layer. So you know, since we have a web

            09:49:02.880 --> 09:49:07.120
            application, which is a simple Apache page, we're going to want to serve it up via the application

            09:49:07.120 --> 09:49:12.000
            gateway. Alright, so make your way over to the top here. And we'll click on application gateway,

            09:49:12.000 --> 09:49:16.720
            or just type that in. And we'll go ahead and add ourselves a new application gateway. We'll choose

            09:49:16.720 --> 09:49:26.240
            wolf here, I'm going to name this wolf application, a gw. And then we do not, we don't need any auto

            09:49:26.240 --> 09:49:29.920
            scaling right now. So we'll just leave that alone, I'm gonna set that to one, we're gonna choose two,

            09:49:29.920 --> 09:49:34.160
            one in three, because the rule of three counts here, we always want three. And then down below,

            09:49:34.160 --> 09:49:38.560
            make sure you choose the correct virtual network. If you're not confident, make sure you go over to

            09:49:38.560 --> 09:49:43.920
            your skill set and just double check to make sure where it resides. So if I go over here into my

            09:49:43.920 --> 09:49:51.200
            skill set, and check it's in wolf net, wolf v net 499. I ended up with more than one, I don't know,

            09:49:51.200 --> 09:49:54.160
            I just had the tutorial, I've done this few revisions. So I've ended up with an additional

            09:49:54.160 --> 09:49:58.720
            one there. Notice it's complaining because it's trying to put this in the default, but it needs

            09:49:58.720 --> 09:50:04.720
            its own subnet. So here under subnets, we're going to create one just for the VGW. So VGW,

            09:50:04.720 --> 09:50:10.480
            and we're going to need a range first. So go over to address space ranges. And we'll pick out the

            09:50:10.480 --> 09:50:19.360
            next number. So 10.0 dot dot 2.0 forward slash 24. We'll hit save. And once that has created,

            09:50:19.360 --> 09:50:23.200
            we'll make our way over to the subnet. And when we hit subnet, it will automatically select the

            09:50:23.200 --> 09:50:29.360
            next one for us. I'm gonna put VGW in here, we'll hit save. And then once that's saved, we'll make

            09:50:29.360 --> 09:50:33.680
            our way back to the wizard notice up here, the breadcrumbs. If we click one back, we can make

            09:50:33.680 --> 09:50:39.760
            our way back to where we are and then choose that VGW subnet, we'll go to the front to the front end

            09:50:39.760 --> 09:50:45.040
            section here, we got public, private, or both, we want public today, and we will need a new IP

            09:50:45.040 --> 09:50:53.760
            address. So I'm going to call this wolf VGW. We'll go ahead and hit OK, we'll go to backends here at

            09:50:53.760 --> 09:50:59.440
            a back end pool, I'm just going to call this back end. And we'll drop down and choose virtual machine

            09:50:59.440 --> 09:51:03.600
            scale set. If you do not see it here, it's because they're not in the same V net, make sure that's

            09:51:03.600 --> 09:51:08.000
            the case. And then we'll go to configuration. So we got a front end a back end, now we got to glue

            09:51:08.000 --> 09:51:13.680
            them together with routing rules. We'll just say my rules. We have listeners and back end targets.

            09:51:13.680 --> 09:51:18.880
            So we'll name our listener name, my listener, if you can spell it, that's a hard one for me. So I'm

            09:51:18.880 --> 09:51:24.720
            just going to copy paste that in, take out the space there. The front end IP is it's going to

            09:51:24.720 --> 09:51:30.720
            be public, we're gonna have HTTP on port 80. We'll have basic if we had multi site. So if you have

            09:51:30.720 --> 09:51:36.000
            more than one destination, but we do not, we'll go to back end targets. And we will choose the

            09:51:36.000 --> 09:51:41.840
            back end pool that we created. And then we have to choose or add HTTP settings. This is all kind of

            09:51:41.840 --> 09:51:46.320
            crammed together doesn't really line up very well. So I get a bit confused here. So I think what we

            09:51:46.320 --> 09:51:53.600
            want to do is hit Add New here. And then we'll say my HTTP settings. Port 80 is good. We do not have

            09:51:53.600 --> 09:51:58.560
            cookies, we do not care about connection draining. All these options are not important to us for our

            09:51:58.560 --> 09:52:04.480
            very simple application. But if you were creating a real web application that that has a session,

            09:52:04.480 --> 09:52:09.840
            you probably would want to turn these both on. Okay, we'll go ahead and hit add. And we do have

            09:52:09.840 --> 09:52:13.920
            path based routing. But this is not something we need to worry about right now. This is where you

            09:52:13.920 --> 09:52:19.680
            could say, you could have multiple targets. So you could say, okay, anytime it is cookie,

            09:52:19.680 --> 09:52:24.160
            then go to this virtual machine. And then if it's another one, you could say go somewhere else or

            09:52:24.160 --> 09:52:29.440
            even do a redirect. That's a great way of attaching things to your virtual machine there,

            09:52:29.440 --> 09:52:35.760
            we'll go ahead and hit add. And so now we have all of our information. We'll hit tags. And we will go

            09:52:35.760 --> 09:52:41.840
            ahead and create. And I'll see you back here when this is done deploying. Okay. Alright, so I've been

            09:52:41.840 --> 09:52:46.960
            waiting a while here for this to complete, but it looks like that we're still having a bit of trouble.

            09:52:46.960 --> 09:52:52.240
            So what I'm going to do is make my way over to the actual load balancer here, because I just

            09:52:52.240 --> 09:52:56.160
            remembered and this happens because I don't normally make a scale set separately, I usually

            09:52:56.160 --> 09:53:00.080
            make it with the load balancer. But if we make our way over to the back end pool, and we're to click

            09:53:00.080 --> 09:53:05.200
            into here, it actually has a thing that says down here, virtual machine scale set was added to this

            09:53:05.200 --> 09:53:10.320
            back end pool upgrade all instances of wolf scale set for this change to work. So those the scale

            09:53:10.320 --> 09:53:14.560
            set needs to get updated is the is the problem here. So what I'm going to do is make my way over

            09:53:14.560 --> 09:53:21.600
            to the scale set. And we'll see if we can do an upgrade here. So if we just checkbox them all on

            09:53:21.600 --> 09:53:26.320
            there, I'm going to go hit upgrade. And then this will perform an upgrade on the instances.

            09:53:26.320 --> 09:53:30.240
            And we'll just give that some time and I'll see you back here in a moment.

            09:53:32.080 --> 09:53:35.360
            Okay, so that didn't take too long for the upgrade. And if you just hit the refresh here,

            09:53:35.360 --> 09:53:39.440
            you're going to wait for the status goes running. And now they're all healthy. So if we make our

            09:53:39.440 --> 09:53:43.440
            way back to our load balancer tab here, if you still have something open, just go to back end

            09:53:43.440 --> 09:53:49.600
            pools, you should see three targets. If we go up to our overview over here, we'll go grab whoops,

            09:53:49.600 --> 09:53:54.880
            our IP address. Now why the they copy the text there, I have no idea. But if we go paste that

            09:53:54.880 --> 09:54:00.240
            up into here and take that out, we get our page. So there you go. That's all it took to get the

            09:54:00.240 --> 09:54:07.520
            availability for the actual server running. If we go on the left hand side, and we go over to health

            09:54:07.520 --> 09:54:11.840
            probes. This is interesting to look at, we're not going to set it up, but I just want to show you

            09:54:11.840 --> 09:54:16.880
            that you'd write in your health check here. And then you could specify a different path. So if

            09:54:16.880 --> 09:54:20.720
            you had like a page called, and it's pretty common for a lot of places, they'll have a page called

            09:54:20.720 --> 09:54:25.280
            health check. And so that's a just a kind of like a way to configure a custom health check

            09:54:25.840 --> 09:54:29.760
            for your instances. But this is all I really wanted to accomplish here today.

            09:54:29.760 --> 09:54:33.680
            I don't think there's really much of anything else that I'd like to do here.

            09:54:33.680 --> 09:54:40.560
            So what we'll do is we'll go and make our way back to all of our resources. And we'll try to find our

            09:54:40.560 --> 09:54:45.600
            original resource group here, if we can find it's probably easier to just go to resource groups.

            09:54:52.640 --> 09:54:56.640
            Great, and I'll just go ahead and delete this one here.

            09:54:56.640 --> 09:55:04.720
            There we go, it's gonna delete a whole lot of stuff. But yeah, there we go.
        </p>
    </body>
</html>
